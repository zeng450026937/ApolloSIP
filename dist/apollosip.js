/*!
 * Apollo version 0.1.0
 * 
 * Copyright (c) 2018-2018 Yealink Networks, Inc
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ApolloSIP"] = factory();
	else
		root["ApolloSIP"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/ApolloSIP.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/Config.js":
/*!***********************!*\
  !*** ./lib/Config.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./lib/Grammar.js\");\nvar URI = __webpack_require__(/*! ./URI */ \"./lib/URI.js\");\nvar Socket = __webpack_require__(/*! ./Socket */ \"./lib/Socket.js\");\nvar Exceptions = __webpack_require__(/*! ./Exceptions */ \"./lib/Exceptions.js\");\n\n// Default settings.\nexports.settings = {\n  // SIP authentication.\n  authorization_user: null,\n  password: null,\n  realm: null,\n  ha1: null,\n\n  // SIP account.\n  display_name: null,\n  uri: null,\n  contact_uri: null,\n\n  // SIP instance id (GRUU).\n  instance_id: null,\n\n  // Preloaded SIP Route header field.\n  use_preloaded_route: false,\n\n  // Session parameters.\n  session_timers: true,\n  session_timers_refresh_method: SIP_C.UPDATE,\n  no_answer_timeout: 60,\n\n  // Registration parameters.\n  register: true,\n  register_expires: 600,\n  registrar_server: null,\n\n  // Connection options.\n  sockets: null,\n  connection_recovery_max_interval: 30,\n  connection_recovery_min_interval: 2,\n\n  /*\n   * Host address.\n   * Value to be set in Via sent_by and host part of Contact FQDN.\n  */\n  via_host: Utils.createRandomToken(12) + '.invalid'\n};\n\n// Configuration checks.\nvar checks = {\n  mandatory: {\n    sockets: function sockets(_sockets2) {\n      /* Allow defining sockets parameter as:\n       *  Socket: socket\n       *  Array of Socket: [socket1, socket2]\n       *  Array of Objects: [{socket: socket1, weight:1}, {socket: Socket2, weight:0}]\n       *  Array of Objects and Socket: [{socket: socket1}, socket2]\n       */\n      var _sockets = [];\n\n      if (Socket.isSocket(_sockets2)) {\n        _sockets.push({ socket: _sockets2 });\n      } else if (Array.isArray(_sockets2) && _sockets2.length) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = _sockets2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var socket = _step.value;\n\n            if (Object.prototype.hasOwnProperty.call(socket, 'socket') && Socket.isSocket(socket.socket)) {\n              _sockets.push(socket);\n            } else if (Socket.isSocket(socket)) {\n              _sockets.push({ socket: socket });\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        return;\n      }\n\n      return _sockets;\n    },\n    uri: function uri(_uri) {\n      if (!/^sip:/i.test(_uri)) {\n        _uri = SIP_C.SIP + ':' + _uri;\n      }\n      var parsed = URI.parse(_uri);\n\n      if (!parsed) {\n        return;\n      } else if (!parsed.user) {\n        return;\n      } else {\n        return parsed;\n      }\n    }\n  },\n\n  optional: {\n    authorization_user: function authorization_user(_authorization_user) {\n      if (Grammar.parse('\"' + _authorization_user + '\"', 'quoted_string') === -1) {\n        return;\n      } else {\n        return _authorization_user;\n      }\n    },\n    user_agent: function user_agent(_user_agent) {\n      if (typeof _user_agent === 'string') {\n        return _user_agent;\n      }\n    },\n    connection_recovery_max_interval: function connection_recovery_max_interval(_connection_recovery_max_interval) {\n      if (Utils.isDecimal(_connection_recovery_max_interval)) {\n        var value = Number(_connection_recovery_max_interval);\n\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n    connection_recovery_min_interval: function connection_recovery_min_interval(_connection_recovery_min_interval) {\n      if (Utils.isDecimal(_connection_recovery_min_interval)) {\n        var value = Number(_connection_recovery_min_interval);\n\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n    contact_uri: function contact_uri(_contact_uri) {\n      if (typeof _contact_uri === 'string') {\n        var uri = Grammar.parse(_contact_uri, 'SIP_URI');\n\n        if (uri !== -1) {\n          return uri;\n        }\n      }\n    },\n    display_name: function display_name(_display_name) {\n      if (Grammar.parse('\"' + _display_name + '\"', 'display_name') === -1) {\n        return;\n      } else {\n        return _display_name;\n      }\n    },\n    instance_id: function instance_id(_instance_id) {\n      if (/^uuid:/i.test(_instance_id)) {\n        _instance_id = _instance_id.substr(5);\n      }\n\n      if (Grammar.parse(_instance_id, 'uuid') === -1) {\n        return;\n      } else {\n        return _instance_id;\n      }\n    },\n    no_answer_timeout: function no_answer_timeout(_no_answer_timeout) {\n      if (Utils.isDecimal(_no_answer_timeout)) {\n        var value = Number(_no_answer_timeout);\n\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n    session_timers: function session_timers(_session_timers) {\n      if (typeof _session_timers === 'boolean') {\n        return _session_timers;\n      }\n    },\n    session_timers_refresh_method: function session_timers_refresh_method(method) {\n      if (typeof method === 'string') {\n        method = method.toUpperCase();\n\n        if (method === SIP_C.INVITE || method === SIP_C.UPDATE) {\n          return method;\n        }\n      }\n    },\n    password: function password(_password) {\n      return String(_password);\n    },\n    realm: function realm(_realm) {\n      return String(_realm);\n    },\n    ha1: function ha1(_ha) {\n      return String(_ha);\n    },\n    register: function register(_register) {\n      if (typeof _register === 'boolean') {\n        return _register;\n      }\n    },\n    register_expires: function register_expires(_register_expires) {\n      if (Utils.isDecimal(_register_expires)) {\n        var value = Number(_register_expires);\n\n        if (value > 0) {\n          return value;\n        }\n      }\n    },\n    registrar_server: function registrar_server(_registrar_server) {\n      if (!/^sip:/i.test(_registrar_server)) {\n        _registrar_server = SIP_C.SIP + ':' + _registrar_server;\n      }\n\n      var parsed = URI.parse(_registrar_server);\n\n      if (!parsed) {\n        return;\n      } else if (parsed.user) {\n        return;\n      } else {\n        return parsed;\n      }\n    },\n    use_preloaded_route: function use_preloaded_route(_use_preloaded_route) {\n      if (typeof _use_preloaded_route === 'boolean') {\n        return _use_preloaded_route;\n      }\n    }\n  }\n};\n\nexports.load = function (dst, src) {\n  // Check Mandatory parameters.\n  for (var parameter in checks.mandatory) {\n    if (!src.hasOwnProperty(parameter)) {\n      throw new Exceptions.ConfigurationError(parameter);\n    } else {\n      var value = src[parameter];\n      var checked_value = checks.mandatory[parameter](value);\n\n      if (checked_value !== undefined) {\n        dst[parameter] = checked_value;\n      } else {\n        throw new Exceptions.ConfigurationError(parameter, value);\n      }\n    }\n  }\n\n  // Check Optional parameters.\n  for (var _parameter in checks.optional) {\n    if (src.hasOwnProperty(_parameter)) {\n      var _value = src[_parameter];\n\n      /* If the parameter value is null, empty string, undefined, empty array\n       * or it's a number with NaN value, then apply its default value.\n       */\n      if (Utils.isEmpty(_value)) {\n        continue;\n      }\n\n      var _checked_value = checks.optional[_parameter](_value);\n\n      if (_checked_value !== undefined) {\n        dst[_parameter] = _checked_value;\n      } else {\n        throw new Exceptions.ConfigurationError(_parameter, _value);\n      }\n    }\n  }\n};\n\n//# sourceURL=webpack://ApolloSIP/./lib/Config.js?");

/***/ }),

/***/ "./lib/Constants.js":
/*!**************************!*\
  !*** ./lib/Constants.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar pkg = __webpack_require__(/*! ../package.json */ \"./package.json\");\n\nmodule.exports = {\n  USER_AGENT: pkg.title + ' ' + pkg.version,\n\n  // SIP scheme.\n  SIP: 'sip',\n  SIPS: 'sips',\n\n  // End and Failure causes.\n  causes: {\n    // Generic error causes.\n    CONNECTION_ERROR: 'Connection Error',\n    REQUEST_TIMEOUT: 'Request Timeout',\n    SIP_FAILURE_CODE: 'SIP Failure Code',\n    INTERNAL_ERROR: 'Internal Error',\n\n    // SIP error causes.\n    BUSY: 'Busy',\n    REJECTED: 'Rejected',\n    REDIRECTED: 'Redirected',\n    UNAVAILABLE: 'Unavailable',\n    NOT_FOUND: 'Not Found',\n    ADDRESS_INCOMPLETE: 'Address Incomplete',\n    INCOMPATIBLE_SDP: 'Incompatible SDP',\n    MISSING_SDP: 'Missing SDP',\n    AUTHENTICATION_ERROR: 'Authentication Error',\n\n    // Session error causes.\n    BYE: 'Terminated',\n    WEBRTC_ERROR: 'WebRTC Error',\n    CANCELED: 'Canceled',\n    NO_ANSWER: 'No Answer',\n    EXPIRES: 'Expires',\n    NO_ACK: 'No ACK',\n    DIALOG_ERROR: 'Dialog Error',\n    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',\n    BAD_MEDIA_DESCRIPTION: 'Bad Media Description',\n    RTP_TIMEOUT: 'RTP Timeout',\n\n    // Subscription error causes\n    EXPIRES_HEADER_MISSING: 'Expires Header Missing',\n    INVALID_EXPIRES_HEADER: 'Invalid Expires Header'\n  },\n\n  SIP_ERROR_CAUSES: {\n    REDIRECTED: [300, 301, 302, 305, 380],\n    BUSY: [486, 600],\n    REJECTED: [403, 603],\n    NOT_FOUND: [404, 604],\n    UNAVAILABLE: [480, 410, 408, 430],\n    ADDRESS_INCOMPLETE: [484, 424],\n    INCOMPATIBLE_SDP: [488, 606],\n    AUTHENTICATION_ERROR: [401, 407]\n  },\n\n  // SIP Methods.\n  ACK: 'ACK',\n  BYE: 'BYE',\n  CANCEL: 'CANCEL',\n  INFO: 'INFO',\n  INVITE: 'INVITE',\n  MESSAGE: 'MESSAGE',\n  NOTIFY: 'NOTIFY',\n  OPTIONS: 'OPTIONS',\n  REGISTER: 'REGISTER',\n  REFER: 'REFER',\n  UPDATE: 'UPDATE',\n  SUBSCRIBE: 'SUBSCRIBE',\n  SERVICE: 'SERVICE',\n\n  /* SIP Response Reasons\n   * DOC: http://www.iana.org/assignments/sip-parameters\n   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7\n   */\n  REASON_PHRASE: {\n    100: 'Trying',\n    180: 'Ringing',\n    181: 'Call Is Being Forwarded',\n    182: 'Queued',\n    183: 'Session Progress',\n    199: 'Early Dialog Terminated', // draft-ietf-sipcore-199\n    200: 'OK',\n    202: 'Accepted', // RFC 3265\n    204: 'No Notification', // RFC 5839\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Moved Temporarily',\n    305: 'Use Proxy',\n    380: 'Alternative Service',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    405: 'Method Not Allowed',\n    406: 'Not Acceptable',\n    407: 'Proxy Authentication Required',\n    408: 'Request Timeout',\n    410: 'Gone',\n    412: 'Conditional Request Failed', // RFC 3903\n    413: 'Request Entity Too Large',\n    414: 'Request-URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Unsupported URI Scheme',\n    417: 'Unknown Resource-Priority', // RFC 4412\n    420: 'Bad Extension',\n    421: 'Extension Required',\n    422: 'Session Interval Too Small', // RFC 4028\n    423: 'Interval Too Brief',\n    424: 'Bad Location Information', // RFC 6442\n    428: 'Use Identity Header', // RFC 4474\n    429: 'Provide Referrer Identity', // RFC 3892\n    430: 'Flow Failed', // RFC 5626\n    433: 'Anonymity Disallowed', // RFC 5079\n    436: 'Bad Identity-Info', // RFC 4474\n    437: 'Unsupported Certificate', // RFC 4744\n    438: 'Invalid Identity Header', // RFC 4744\n    439: 'First Hop Lacks Outbound Support', // RFC 5626\n    440: 'Max-Breadth Exceeded', // RFC 5393\n    469: 'Bad Info Package', // draft-ietf-sipcore-info-events\n    470: 'Consent Needed', // RFC 5360\n    478: 'Unresolvable Destination', // Custom code copied from Kamailio.\n    480: 'Temporarily Unavailable',\n    481: 'Call/Transaction Does Not Exist',\n    482: 'Loop Detected',\n    483: 'Too Many Hops',\n    484: 'Address Incomplete',\n    485: 'Ambiguous',\n    486: 'Busy Here',\n    487: 'Request Terminated',\n    488: 'Not Acceptable Here',\n    489: 'Bad Event', // RFC 3265\n    491: 'Request Pending',\n    493: 'Undecipherable',\n    494: 'Security Agreement Required', // RFC 3329\n    500: 'SIP Internal Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Server Time-out',\n    505: 'Version Not Supported',\n    513: 'Message Too Large',\n    580: 'Precondition Failure', // RFC 3312\n    600: 'Busy Everywhere',\n    603: 'Decline',\n    604: 'Does Not Exist Anywhere',\n    606: 'Not Acceptable'\n  },\n\n  ALLOWED_METHODS: 'INVITE,ACK,CANCEL,BYE,UPDATE,MESSAGE,SERVICE,OPTIONS,REFER,INFO',\n  ACCEPTED_BODY_TYPES: 'application/sdp, application/dtmf-relay',\n  MAX_FORWARDS: 69,\n  SESSION_EXPIRES: 120,\n  MIN_SESSION_EXPIRES: 60,\n  SUBSCRIPTION_EXPIRES: 3600\n};\n\n//# sourceURL=webpack://ApolloSIP/./lib/Constants.js?");

/***/ }),

/***/ "./lib/Dialog.js":
/*!***********************!*\
  !*** ./lib/Dialog.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./lib/SIPMessage.js\");\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar Transactions = __webpack_require__(/*! ./Transactions */ \"./lib/Transactions.js\");\nvar Dialog_RequestSender = __webpack_require__(/*! ./Dialog/RequestSender */ \"./lib/Dialog/RequestSender.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:Dialog');\n\nvar C = {\n  // Dialog states.\n  STATUS_EARLY: 1,\n  STATUS_CONFIRMED: 2\n};\n\n// RFC 3261 12.1.\nmodule.exports = function () {\n  _createClass(Dialog, null, [{\n    key: 'C',\n\n    // Expose C object.\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  function Dialog(owner, message, type) {\n    var state = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : C.STATUS_CONFIRMED;\n\n    _classCallCheck(this, Dialog);\n\n    this._owner = owner;\n    this._ua = owner._ua;\n\n    this._uac_pending_reply = false;\n    this._uas_pending_reply = false;\n\n    if (!message.hasHeader('contact')) {\n      return {\n        error: 'unable to create a Dialog without Contact header field'\n      };\n    }\n\n    if (message instanceof SIPMessage.IncomingResponse) {\n      state = message.status_code < 200 ? C.STATUS_EARLY : C.STATUS_CONFIRMED;\n    }\n\n    var contact = message.parseHeader('contact');\n\n    // RFC 3261 12.1.1.\n    if (type === 'UAS') {\n      this._id = {\n        call_id: message.call_id,\n        local_tag: message.to_tag,\n        remote_tag: message.from_tag,\n        toString: function toString() {\n          return this.call_id + this.local_tag + this.remote_tag;\n        }\n      };\n      this._state = state;\n      this._remote_seqnum = message.cseq;\n      this._local_uri = message.parseHeader('to').uri;\n      this._remote_uri = message.parseHeader('from').uri;\n      this._remote_target = contact.uri;\n      this._route_set = message.getHeaders('record-route');\n      this._ack_seqnum = this._remote_seqnum;\n    }\n    // RFC 3261 12.1.2.\n    else if (type === 'UAC') {\n        this._id = {\n          call_id: message.call_id,\n          local_tag: message.from_tag,\n          remote_tag: message.to_tag,\n          toString: function toString() {\n            return this.call_id + this.local_tag + this.remote_tag;\n          }\n        };\n        this._state = state;\n        this._local_seqnum = message.cseq;\n        this._local_uri = message.parseHeader('from').uri;\n        this._remote_uri = message.parseHeader('to').uri;\n        this._remote_target = contact.uri;\n        this._route_set = message.getHeaders('record-route').reverse();\n        this._ack_seqnum = null;\n      }\n\n    this._ua.newDialog(this);\n    debug('new ' + type + ' dialog created with status ' + (this._state === C.STATUS_EARLY ? 'EARLY' : 'CONFIRMED'));\n  }\n\n  _createClass(Dialog, [{\n    key: 'update',\n    value: function update(message, type) {\n      this._state = C.STATUS_CONFIRMED;\n\n      debug('dialog ' + this._id.toString() + '  changed to CONFIRMED state');\n\n      if (type === 'UAC') {\n        // RFC 3261 13.2.2.4.\n        this._route_set = message.getHeaders('record-route').reverse();\n      }\n    }\n  }, {\n    key: 'terminate',\n    value: function terminate() {\n      debug('dialog ' + this._id.toString() + ' deleted');\n      this._ua.destroyDialog(this);\n    }\n  }, {\n    key: 'sendRequest',\n    value: function sendRequest(method) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var eventHandlers = options.eventHandlers || {};\n      var body = options.body || null;\n      var request = this._createRequest(method, extraHeaders, body);\n\n      // Increase the local CSeq on authentication.\n      eventHandlers.onAuthenticated = function () {\n        _this._local_seqnum += 1;\n      };\n\n      var request_sender = new Dialog_RequestSender(this, request, eventHandlers);\n\n      request_sender.send();\n\n      // Return the instance of OutgoingRequest.\n      return request;\n    }\n  }, {\n    key: 'receiveRequest',\n    value: function receiveRequest(request) {\n      // Check in-dialog request.\n      if (!this._checkInDialogRequest(request)) {\n        return;\n      }\n\n      // ACK received. Cleanup this._ack_seqnum.\n      if (request.method === SIP_C.ACK && this._ack_seqnum !== null) {\n        this._ack_seqnum = null;\n      }\n      // INVITE received. Set this._ack_seqnum.\n      else if (request.method === SIP_C.INVITE) {\n          this._ack_seqnum = request.cseq;\n        }\n\n      this._owner.receiveRequest(request);\n    }\n\n    // RFC 3261 12.2.1.1.\n\n  }, {\n    key: '_createRequest',\n    value: function _createRequest(method, extraHeaders, body) {\n      extraHeaders = Utils.cloneArray(extraHeaders);\n\n      if (!this._local_seqnum) {\n        this._local_seqnum = Math.floor(Math.random() * 10000);\n      }\n\n      var cseq = method === SIP_C.CANCEL || method === SIP_C.ACK ? this._local_seqnum : this._local_seqnum += 1;\n\n      var request = new SIPMessage.OutgoingRequest(method, this._remote_target, this._ua, {\n        'cseq': cseq,\n        'call_id': this._id.call_id,\n        'from_uri': this._local_uri,\n        'from_tag': this._id.local_tag,\n        'to_uri': this._remote_uri,\n        'to_tag': this._id.remote_tag,\n        'route_set': this._route_set\n      }, extraHeaders, body);\n\n      return request;\n    }\n\n    // RFC 3261 12.2.2.\n\n  }, {\n    key: '_checkInDialogRequest',\n    value: function _checkInDialogRequest(request) {\n      var _this2 = this;\n\n      if (!this._remote_seqnum) {\n        this._remote_seqnum = request.cseq;\n      } else if (request.cseq < this._remote_seqnum) {\n        if (request.method === SIP_C.ACK) {\n          // We are not expecting any ACK with lower seqnum than the current one.\n          // Or this is not the ACK we are waiting for.\n          if (this._ack_seqnum === null || request.cseq !== this._ack_seqnum) {\n            return false;\n          }\n        } else {\n          request.reply(500);\n\n          return false;\n        }\n      } else if (request.cseq > this._remote_seqnum) {\n        this._remote_seqnum = request.cseq;\n      }\n\n      // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-.\n      if (request.method === SIP_C.INVITE || request.method === SIP_C.UPDATE && request.body) {\n        if (this._uac_pending_reply === true) {\n          request.reply(491);\n        } else if (this._uas_pending_reply === true) {\n          var retryAfter = (Math.random() * 10 | 0) + 1;\n\n          request.reply(500, null, ['Retry-After:' + retryAfter]);\n\n          return false;\n        } else {\n          this._uas_pending_reply = true;\n\n          var stateChanged = function stateChanged() {\n            if (request.server_transaction.state === Transactions.C.STATUS_ACCEPTED || request.server_transaction.state === Transactions.C.STATUS_COMPLETED || request.server_transaction.state === Transactions.C.STATUS_TERMINATED) {\n\n              request.server_transaction.removeListener('stateChanged', stateChanged);\n              _this2._uas_pending_reply = false;\n            }\n          };\n\n          request.server_transaction.on('stateChanged', stateChanged);\n        }\n\n        // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted.\n        if (request.hasHeader('contact')) {\n          request.server_transaction.on('stateChanged', function () {\n            if (request.server_transaction.state === Transactions.C.STATUS_ACCEPTED) {\n              _this2._remote_target = request.parseHeader('contact').uri;\n            }\n          });\n        }\n      } else if (request.method === SIP_C.NOTIFY) {\n        // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted.\n        if (request.hasHeader('contact')) {\n          request.server_transaction.on('stateChanged', function () {\n            if (request.server_transaction.state === Transactions.C.STATUS_COMPLETED) {\n              _this2._remote_target = request.parseHeader('contact').uri;\n            }\n          });\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: 'id',\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: 'local_seqnum',\n    get: function get() {\n      return this._local_seqnum;\n    },\n    set: function set(num) {\n      this._local_seqnum = num;\n    }\n  }, {\n    key: 'owner',\n    get: function get() {\n      return this._owner;\n    }\n  }, {\n    key: 'uac_pending_reply',\n    get: function get() {\n      return this._uac_pending_reply;\n    },\n    set: function set(pending) {\n      this._uac_pending_reply = pending;\n    }\n  }, {\n    key: 'uas_pending_reply',\n    get: function get() {\n      return this._uas_pending_reply;\n    }\n  }]);\n\n  return Dialog;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./lib/Dialog.js?");

/***/ }),

/***/ "./lib/Dialog/RequestSender.js":
/*!*************************************!*\
  !*** ./lib/Dialog/RequestSender.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SIP_C = __webpack_require__(/*! ../Constants */ \"./lib/Constants.js\");\nvar Transactions = __webpack_require__(/*! ../Transactions */ \"./lib/Transactions.js\");\nvar RTCSession = __webpack_require__(/*! ../RTCSession */ \"./lib/RTCSession.js\");\nvar RequestSender = __webpack_require__(/*! ../RequestSender */ \"./lib/RequestSender.js\");\n\n// Default event handlers.\nvar EventHandlers = {\n  onRequestTimeout: function onRequestTimeout() {},\n  onTransportError: function onTransportError() {},\n  onSuccessResponse: function onSuccessResponse() {},\n  onErrorResponse: function onErrorResponse() {},\n  onAuthenticated: function onAuthenticated() {},\n  onDialogError: function onDialogError() {}\n};\n\nmodule.exports = function () {\n  function DialogRequestSender(dialog, request, eventHandlers) {\n    _classCallCheck(this, DialogRequestSender);\n\n    this._dialog = dialog;\n    this._ua = dialog._ua;\n    this._request = request;\n    this._eventHandlers = eventHandlers;\n\n    // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.\n    this._reattempt = false;\n    this._reattemptTimer = null;\n\n    // Define the undefined handlers.\n    for (var handler in EventHandlers) {\n      if (Object.prototype.hasOwnProperty.call(EventHandlers, handler)) {\n        if (!this._eventHandlers[handler]) {\n          this._eventHandlers[handler] = EventHandlers[handler];\n        }\n      }\n    }\n  }\n\n  _createClass(DialogRequestSender, [{\n    key: 'send',\n    value: function send() {\n      var _this = this;\n\n      var request_sender = new RequestSender(this._ua, this._request, {\n        onRequestTimeout: function onRequestTimeout() {\n          _this._eventHandlers.onRequestTimeout();\n        },\n        onTransportError: function onTransportError() {\n          _this._eventHandlers.onTransportError();\n        },\n        onAuthenticated: function onAuthenticated(request) {\n          _this._eventHandlers.onAuthenticated(request);\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          _this._receiveResponse(response);\n        }\n      });\n\n      request_sender.send();\n\n      // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-.\n      if ((this._request.method === SIP_C.INVITE || this._request.method === SIP_C.UPDATE && this._request.body) && request_sender.clientTransaction.state !== Transactions.C.STATUS_TERMINATED) {\n        this._dialog.uac_pending_reply = true;\n\n        var stateChanged = function stateChanged() {\n          if (request_sender.clientTransaction.state === Transactions.C.STATUS_ACCEPTED || request_sender.clientTransaction.state === Transactions.C.STATUS_COMPLETED || request_sender.clientTransaction.state === Transactions.C.STATUS_TERMINATED) {\n            request_sender.clientTransaction.removeListener('stateChanged', stateChanged);\n            _this._dialog.uac_pending_reply = false;\n          }\n        };\n\n        request_sender.clientTransaction.on('stateChanged', stateChanged);\n      }\n    }\n  }, {\n    key: '_receiveResponse',\n    value: function _receiveResponse(response) {\n      var _this2 = this;\n\n      // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.\n      if (response.status_code === 408 || response.status_code === 481) {\n        this._eventHandlers.onDialogError(response);\n      } else if (response.method === SIP_C.INVITE && response.status_code === 491) {\n        if (this._reattempt) {\n          if (response.status_code >= 200 && response.status_code < 300) {\n            this._eventHandlers.onSuccessResponse(response);\n          } else if (response.status_code >= 300) {\n            this._eventHandlers.onErrorResponse(response);\n          }\n        } else {\n          this._request.cseq.value = this._dialog.local_seqnum += 1;\n          this._reattemptTimer = setTimeout(function () {\n            // TODO: look at dialog state instead.\n            if (_this2._dialog.owner.status !== RTCSession.C.STATUS_TERMINATED) {\n              _this2._reattempt = true;\n              _this2._request_sender.send();\n            }\n          }, 1000);\n        }\n      } else if (response.status_code >= 200 && response.status_code < 300) {\n        this._eventHandlers.onSuccessResponse(response);\n      } else if (response.status_code >= 300) {\n        this._eventHandlers.onErrorResponse(response);\n      }\n    }\n  }, {\n    key: 'request',\n    get: function get() {\n      return this._request;\n    }\n  }]);\n\n  return DialogRequestSender;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./lib/Dialog/RequestSender.js?");

/***/ }),

/***/ "./lib/DigestAuthentication.js":
/*!*************************************!*\
  !*** ./lib/DigestAuthentication.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:DigestAuthentication');\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:ERROR:DigestAuthentication');\n\ndebugerror.log = console.warn.bind(console);\n\nmodule.exports = function () {\n  function DigestAuthentication(credentials) {\n    _classCallCheck(this, DigestAuthentication);\n\n    this._credentials = credentials;\n    this._cnonce = null;\n    this._nc = 0;\n    this._ncHex = '00000000';\n    this._algorithm = null;\n    this._realm = null;\n    this._nonce = null;\n    this._opaque = null;\n    this._stale = null;\n    this._qop = null;\n    this._method = null;\n    this._uri = null;\n    this._ha1 = null;\n    this._response = null;\n  }\n\n  _createClass(DigestAuthentication, [{\n    key: 'get',\n    value: function get(parameter) {\n      switch (parameter) {\n        case 'realm':\n          return this._realm;\n\n        case 'ha1':\n          return this._ha1;\n\n        default:\n          debugerror('get() | cannot get \"%s\" parameter', parameter);\n\n          return undefined;\n      }\n    }\n\n    /**\n    * Performs Digest authentication given a SIP request and the challenge\n    * received in a response to that request.\n    * Returns true if auth was successfully generated, false otherwise.\n    */\n\n  }, {\n    key: 'authenticate',\n    value: function authenticate(_ref, challenge) /* test interface */{\n      var method = _ref.method,\n          ruri = _ref.ruri,\n          body = _ref.body;\n      var cnonce = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      this._algorithm = challenge.algorithm;\n      this._realm = challenge.realm;\n      this._nonce = challenge.nonce;\n      this._opaque = challenge.opaque;\n      this._stale = challenge.stale;\n\n      if (this._algorithm) {\n        if (this._algorithm !== 'MD5') {\n          debugerror('authenticate() | challenge with Digest algorithm different than \"MD5\", authentication aborted');\n\n          return false;\n        }\n      } else {\n        this._algorithm = 'MD5';\n      }\n\n      if (!this._nonce) {\n        debugerror('authenticate() | challenge without Digest nonce, authentication aborted');\n\n        return false;\n      }\n\n      if (!this._realm) {\n        debugerror('authenticate() | challenge without Digest realm, authentication aborted');\n\n        return false;\n      }\n\n      // If no plain SIP password is provided.\n      if (!this._credentials.password) {\n        // If ha1 is not provided we cannot authenticate.\n        if (!this._credentials.ha1) {\n          debugerror('authenticate() | no plain SIP password nor ha1 provided, authentication aborted');\n\n          return false;\n        }\n\n        // If the realm does not match the stored realm we cannot authenticate.\n        if (this._credentials.realm !== this._realm) {\n          debugerror('authenticate() | no plain SIP password, and stored `realm` does not match the given `realm`, cannot authenticate [stored:\"%s\", given:\"%s\"]', this._credentials.realm, this._realm);\n\n          return false;\n        }\n      }\n\n      // 'qop' can contain a list of values (Array). Let's choose just one.\n      if (challenge.qop) {\n        if (challenge.qop.indexOf('auth-int') > -1) {\n          this._qop = 'auth-int';\n        } else if (challenge.qop.indexOf('auth') > -1) {\n          this._qop = 'auth';\n        } else {\n          // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.\n          debugerror('authenticate() | challenge without Digest qop different than \"auth\" or \"auth-int\", authentication aborted');\n\n          return false;\n        }\n      } else {\n        this._qop = null;\n      }\n\n      // Fill other attributes.\n\n      this._method = method;\n      this._uri = ruri;\n      this._cnonce = cnonce || Utils.createRandomToken(12);\n      this._nc += 1;\n      var hex = Number(this._nc).toString(16);\n\n      this._ncHex = '00000000'.substr(0, 8 - hex.length) + hex;\n\n      // Nc-value = 8LHEX. Max value = 'FFFFFFFF'.\n      if (this._nc === 4294967296) {\n        this._nc = 1;\n        this._ncHex = '00000001';\n      }\n\n      // Calculate the Digest \"response\" value.\n\n      // If we have plain SIP password then regenerate ha1.\n      if (this._credentials.password) {\n        // HA1 = MD5(A1) = MD5(username:realm:password).\n        this._ha1 = Utils.calculateMD5(this._credentials.username + ':' + this._realm + ':' + this._credentials.password);\n      }\n      // Otherwise reuse the stored ha1.\n      else {\n          this._ha1 = this._credentials.ha1;\n        }\n\n      var ha2 = void 0;\n\n      if (this._qop === 'auth') {\n        // HA2 = MD5(A2) = MD5(method:digestURI).\n        ha2 = Utils.calculateMD5(this._method + ':' + this._uri);\n        // Response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2).\n        this._response = Utils.calculateMD5(this._ha1 + ':' + this._nonce + ':' + this._ncHex + ':' + this._cnonce + ':auth:' + ha2);\n      } else if (this._qop === 'auth-int') {\n        // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody)).\n        ha2 = Utils.calculateMD5(this._method + ':' + this._uri + ':' + Utils.calculateMD5(body ? body : ''));\n        // Response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2).\n        this._response = Utils.calculateMD5(this._ha1 + ':' + this._nonce + ':' + this._ncHex + ':' + this._cnonce + ':auth-int:' + ha2);\n      } else if (this._qop === null) {\n        // HA2 = MD5(A2) = MD5(method:digestURI).\n        ha2 = Utils.calculateMD5(this._method + ':' + this._uri);\n        // Response = MD5(HA1:nonce:HA2).\n        this._response = Utils.calculateMD5(this._ha1 + ':' + this._nonce + ':' + ha2);\n      }\n\n      debug('authenticate() | response generated');\n\n      return true;\n    }\n\n    /**\n    * Return the Proxy-Authorization or WWW-Authorization header value.\n    */\n\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var auth_params = [];\n\n      if (!this._response) {\n        throw new Error('response field does not exist, cannot generate Authorization header');\n      }\n\n      auth_params.push('algorithm=' + this._algorithm);\n      auth_params.push('username=\"' + this._credentials.username + '\"');\n      auth_params.push('realm=\"' + this._realm + '\"');\n      auth_params.push('nonce=\"' + this._nonce + '\"');\n      auth_params.push('uri=\"' + this._uri + '\"');\n      auth_params.push('response=\"' + this._response + '\"');\n      if (this._opaque) {\n        auth_params.push('opaque=\"' + this._opaque + '\"');\n      }\n      if (this._qop) {\n        auth_params.push('qop=' + this._qop);\n        auth_params.push('cnonce=\"' + this._cnonce + '\"');\n        auth_params.push('nc=' + this._ncHex);\n      }\n\n      return 'Digest ' + auth_params.join(', ');\n    }\n  }]);\n\n  return DigestAuthentication;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./lib/DigestAuthentication.js?");

/***/ }),

/***/ "./lib/Exceptions.js":
/*!***************************!*\
  !*** ./lib/Exceptions.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ConfigurationError = function (_Error) {\n  _inherits(ConfigurationError, _Error);\n\n  function ConfigurationError(parameter, value) {\n    _classCallCheck(this, ConfigurationError);\n\n    var _this = _possibleConstructorReturn(this, (ConfigurationError.__proto__ || Object.getPrototypeOf(ConfigurationError)).call(this));\n\n    _this.code = 1;\n    _this.name = 'CONFIGURATION_ERROR';\n    _this.parameter = parameter;\n    _this.value = value;\n    _this.message = !_this.value ? 'Missing parameter: ' + _this.parameter : 'Invalid value ' + JSON.stringify(_this.value) + ' for parameter \"' + _this.parameter + '\"';\n    return _this;\n  }\n\n  return ConfigurationError;\n}(Error);\n\nvar InvalidStateError = function (_Error2) {\n  _inherits(InvalidStateError, _Error2);\n\n  function InvalidStateError(status) {\n    _classCallCheck(this, InvalidStateError);\n\n    var _this2 = _possibleConstructorReturn(this, (InvalidStateError.__proto__ || Object.getPrototypeOf(InvalidStateError)).call(this));\n\n    _this2.code = 2;\n    _this2.name = 'INVALID_STATE_ERROR';\n    _this2.status = status;\n    _this2.message = 'Invalid status: ' + status;\n    return _this2;\n  }\n\n  return InvalidStateError;\n}(Error);\n\nvar NotSupportedError = function (_Error3) {\n  _inherits(NotSupportedError, _Error3);\n\n  function NotSupportedError(message) {\n    _classCallCheck(this, NotSupportedError);\n\n    var _this3 = _possibleConstructorReturn(this, (NotSupportedError.__proto__ || Object.getPrototypeOf(NotSupportedError)).call(this));\n\n    _this3.code = 3;\n    _this3.name = 'NOT_SUPPORTED_ERROR';\n    _this3.message = message;\n    return _this3;\n  }\n\n  return NotSupportedError;\n}(Error);\n\nvar NotReadyError = function (_Error4) {\n  _inherits(NotReadyError, _Error4);\n\n  function NotReadyError(message) {\n    _classCallCheck(this, NotReadyError);\n\n    var _this4 = _possibleConstructorReturn(this, (NotReadyError.__proto__ || Object.getPrototypeOf(NotReadyError)).call(this));\n\n    _this4.code = 4;\n    _this4.name = 'NOT_READY_ERROR';\n    _this4.message = message;\n    return _this4;\n  }\n\n  return NotReadyError;\n}(Error);\n\nmodule.exports = {\n  ConfigurationError: ConfigurationError,\n  InvalidStateError: InvalidStateError,\n  NotSupportedError: NotSupportedError,\n  NotReadyError: NotReadyError\n};\n\n//# sourceURL=webpack://ApolloSIP/./lib/Exceptions.js?");

/***/ }),

/***/ "./lib/Grammar.js":
/*!************************!*\
  !*** ./lib/Grammar.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function () {\n  /*\n   * Generated by PEG.js 0.7.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n  function quote(s) {\n    /*\n     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a\n     * string literal except for the closing quote character, backslash,\n     * carriage return, line separator, paragraph separator, and line feed.\n     * Any character may appear in the form of an escape sequence.\n     *\n     * For portability, we also escape escape all control and non-ASCII\n     * characters. Note that \"\\0\" and \"\\v\" escape sequences are not used\n     * because JSHint does not like the first and IE the second.\n     */\n    return '\"' + s.replace(/\\\\/g, '\\\\\\\\') // backslash\n    .replace(/\"/g, '\\\\\"') // closing quote character\n    .replace(/\\x08/g, '\\\\b') // backspace\n    .replace(/\\t/g, '\\\\t') // horizontal tab\n    .replace(/\\n/g, '\\\\n') // line feed\n    .replace(/\\f/g, '\\\\f') // form feed\n    .replace(/\\r/g, '\\\\r') // carriage return\n    .replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape) + '\"';\n  }\n  var result = {\n    /*\n     * Parses the input with a generated parser. If the parsing is successfull,\n     * returns a value explicitly or implicitly specified by the grammar from\n     * which the parser was generated (see |PEG.buildParser|). If the parsing is\n     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.\n     */\n    parse: function parse(input, startRule) {\n      var parseFunctions = {\n        \"CRLF\": parse_CRLF,\n        \"DIGIT\": parse_DIGIT,\n        \"ALPHA\": parse_ALPHA,\n        \"HEXDIG\": parse_HEXDIG,\n        \"WSP\": parse_WSP,\n        \"OCTET\": parse_OCTET,\n        \"DQUOTE\": parse_DQUOTE,\n        \"SP\": parse_SP,\n        \"HTAB\": parse_HTAB,\n        \"alphanum\": parse_alphanum,\n        \"reserved\": parse_reserved,\n        \"unreserved\": parse_unreserved,\n        \"mark\": parse_mark,\n        \"escaped\": parse_escaped,\n        \"LWS\": parse_LWS,\n        \"SWS\": parse_SWS,\n        \"HCOLON\": parse_HCOLON,\n        \"TEXT_UTF8_TRIM\": parse_TEXT_UTF8_TRIM,\n        \"TEXT_UTF8char\": parse_TEXT_UTF8char,\n        \"UTF8_NONASCII\": parse_UTF8_NONASCII,\n        \"UTF8_CONT\": parse_UTF8_CONT,\n        \"LHEX\": parse_LHEX,\n        \"token\": parse_token,\n        \"token_nodot\": parse_token_nodot,\n        \"separators\": parse_separators,\n        \"word\": parse_word,\n        \"STAR\": parse_STAR,\n        \"SLASH\": parse_SLASH,\n        \"EQUAL\": parse_EQUAL,\n        \"LPAREN\": parse_LPAREN,\n        \"RPAREN\": parse_RPAREN,\n        \"RAQUOT\": parse_RAQUOT,\n        \"LAQUOT\": parse_LAQUOT,\n        \"COMMA\": parse_COMMA,\n        \"SEMI\": parse_SEMI,\n        \"COLON\": parse_COLON,\n        \"LDQUOT\": parse_LDQUOT,\n        \"RDQUOT\": parse_RDQUOT,\n        \"comment\": parse_comment,\n        \"ctext\": parse_ctext,\n        \"quoted_string\": parse_quoted_string,\n        \"quoted_string_clean\": parse_quoted_string_clean,\n        \"qdtext\": parse_qdtext,\n        \"quoted_pair\": parse_quoted_pair,\n        \"SIP_URI_noparams\": parse_SIP_URI_noparams,\n        \"SIP_URI\": parse_SIP_URI,\n        \"uri_scheme\": parse_uri_scheme,\n        \"uri_scheme_sips\": parse_uri_scheme_sips,\n        \"uri_scheme_sip\": parse_uri_scheme_sip,\n        \"userinfo\": parse_userinfo,\n        \"user\": parse_user,\n        \"user_unreserved\": parse_user_unreserved,\n        \"password\": parse_password,\n        \"hostport\": parse_hostport,\n        \"host\": parse_host,\n        \"hostname\": parse_hostname,\n        \"domainlabel\": parse_domainlabel,\n        \"toplabel\": parse_toplabel,\n        \"IPv6reference\": parse_IPv6reference,\n        \"IPv6address\": parse_IPv6address,\n        \"h16\": parse_h16,\n        \"ls32\": parse_ls32,\n        \"IPv4address\": parse_IPv4address,\n        \"dec_octet\": parse_dec_octet,\n        \"port\": parse_port,\n        \"uri_parameters\": parse_uri_parameters,\n        \"uri_parameter\": parse_uri_parameter,\n        \"transport_param\": parse_transport_param,\n        \"user_param\": parse_user_param,\n        \"method_param\": parse_method_param,\n        \"ttl_param\": parse_ttl_param,\n        \"maddr_param\": parse_maddr_param,\n        \"lr_param\": parse_lr_param,\n        \"other_param\": parse_other_param,\n        \"pname\": parse_pname,\n        \"pvalue\": parse_pvalue,\n        \"paramchar\": parse_paramchar,\n        \"param_unreserved\": parse_param_unreserved,\n        \"headers\": parse_headers,\n        \"header\": parse_header,\n        \"hname\": parse_hname,\n        \"hvalue\": parse_hvalue,\n        \"hnv_unreserved\": parse_hnv_unreserved,\n        \"Request_Response\": parse_Request_Response,\n        \"Request_Line\": parse_Request_Line,\n        \"Request_URI\": parse_Request_URI,\n        \"absoluteURI\": parse_absoluteURI,\n        \"hier_part\": parse_hier_part,\n        \"net_path\": parse_net_path,\n        \"abs_path\": parse_abs_path,\n        \"opaque_part\": parse_opaque_part,\n        \"uric\": parse_uric,\n        \"uric_no_slash\": parse_uric_no_slash,\n        \"path_segments\": parse_path_segments,\n        \"segment\": parse_segment,\n        \"param\": parse_param,\n        \"pchar\": parse_pchar,\n        \"scheme\": parse_scheme,\n        \"authority\": parse_authority,\n        \"srvr\": parse_srvr,\n        \"reg_name\": parse_reg_name,\n        \"query\": parse_query,\n        \"SIP_Version\": parse_SIP_Version,\n        \"INVITEm\": parse_INVITEm,\n        \"ACKm\": parse_ACKm,\n        \"OPTIONSm\": parse_OPTIONSm,\n        \"BYEm\": parse_BYEm,\n        \"CANCELm\": parse_CANCELm,\n        \"REGISTERm\": parse_REGISTERm,\n        \"SUBSCRIBEm\": parse_SUBSCRIBEm,\n        \"NOTIFYm\": parse_NOTIFYm,\n        \"REFERm\": parse_REFERm,\n        \"Method\": parse_Method,\n        \"Status_Line\": parse_Status_Line,\n        \"Status_Code\": parse_Status_Code,\n        \"extension_code\": parse_extension_code,\n        \"Reason_Phrase\": parse_Reason_Phrase,\n        \"Allow_Events\": parse_Allow_Events,\n        \"Call_ID\": parse_Call_ID,\n        \"Contact\": parse_Contact,\n        \"contact_param\": parse_contact_param,\n        \"name_addr\": parse_name_addr,\n        \"display_name\": parse_display_name,\n        \"contact_params\": parse_contact_params,\n        \"c_p_q\": parse_c_p_q,\n        \"c_p_expires\": parse_c_p_expires,\n        \"delta_seconds\": parse_delta_seconds,\n        \"qvalue\": parse_qvalue,\n        \"generic_param\": parse_generic_param,\n        \"gen_value\": parse_gen_value,\n        \"Content_Disposition\": parse_Content_Disposition,\n        \"disp_type\": parse_disp_type,\n        \"disp_param\": parse_disp_param,\n        \"handling_param\": parse_handling_param,\n        \"Content_Encoding\": parse_Content_Encoding,\n        \"Content_Length\": parse_Content_Length,\n        \"Content_Type\": parse_Content_Type,\n        \"media_type\": parse_media_type,\n        \"m_type\": parse_m_type,\n        \"discrete_type\": parse_discrete_type,\n        \"composite_type\": parse_composite_type,\n        \"extension_token\": parse_extension_token,\n        \"x_token\": parse_x_token,\n        \"m_subtype\": parse_m_subtype,\n        \"m_parameter\": parse_m_parameter,\n        \"m_value\": parse_m_value,\n        \"CSeq\": parse_CSeq,\n        \"CSeq_value\": parse_CSeq_value,\n        \"Expires\": parse_Expires,\n        \"Event\": parse_Event,\n        \"event_type\": parse_event_type,\n        \"From\": parse_From,\n        \"from_param\": parse_from_param,\n        \"tag_param\": parse_tag_param,\n        \"Max_Forwards\": parse_Max_Forwards,\n        \"Min_Expires\": parse_Min_Expires,\n        \"Name_Addr_Header\": parse_Name_Addr_Header,\n        \"Proxy_Authenticate\": parse_Proxy_Authenticate,\n        \"challenge\": parse_challenge,\n        \"other_challenge\": parse_other_challenge,\n        \"auth_param\": parse_auth_param,\n        \"digest_cln\": parse_digest_cln,\n        \"realm\": parse_realm,\n        \"realm_value\": parse_realm_value,\n        \"domain\": parse_domain,\n        \"URI\": parse_URI,\n        \"nonce\": parse_nonce,\n        \"nonce_value\": parse_nonce_value,\n        \"opaque\": parse_opaque,\n        \"stale\": parse_stale,\n        \"algorithm\": parse_algorithm,\n        \"qop_options\": parse_qop_options,\n        \"qop_value\": parse_qop_value,\n        \"Proxy_Require\": parse_Proxy_Require,\n        \"Record_Route\": parse_Record_Route,\n        \"rec_route\": parse_rec_route,\n        \"Reason\": parse_Reason,\n        \"reason_param\": parse_reason_param,\n        \"reason_cause\": parse_reason_cause,\n        \"Require\": parse_Require,\n        \"Route\": parse_Route,\n        \"route_param\": parse_route_param,\n        \"Subscription_State\": parse_Subscription_State,\n        \"substate_value\": parse_substate_value,\n        \"subexp_params\": parse_subexp_params,\n        \"event_reason_value\": parse_event_reason_value,\n        \"Subject\": parse_Subject,\n        \"Supported\": parse_Supported,\n        \"To\": parse_To,\n        \"to_param\": parse_to_param,\n        \"Via\": parse_Via,\n        \"via_param\": parse_via_param,\n        \"via_params\": parse_via_params,\n        \"via_ttl\": parse_via_ttl,\n        \"via_maddr\": parse_via_maddr,\n        \"via_received\": parse_via_received,\n        \"via_branch\": parse_via_branch,\n        \"response_port\": parse_response_port,\n        \"sent_protocol\": parse_sent_protocol,\n        \"protocol_name\": parse_protocol_name,\n        \"transport\": parse_transport,\n        \"sent_by\": parse_sent_by,\n        \"via_host\": parse_via_host,\n        \"via_port\": parse_via_port,\n        \"ttl\": parse_ttl,\n        \"WWW_Authenticate\": parse_WWW_Authenticate,\n        \"Session_Expires\": parse_Session_Expires,\n        \"s_e_expires\": parse_s_e_expires,\n        \"s_e_params\": parse_s_e_params,\n        \"s_e_refresher\": parse_s_e_refresher,\n        \"extension_header\": parse_extension_header,\n        \"header_value\": parse_header_value,\n        \"message_body\": parse_message_body,\n        \"uuid_URI\": parse_uuid_URI,\n        \"uuid\": parse_uuid,\n        \"hex4\": parse_hex4,\n        \"hex8\": parse_hex8,\n        \"hex12\": parse_hex12,\n        \"Refer_To\": parse_Refer_To,\n        \"Replaces\": parse_Replaces,\n        \"call_id\": parse_call_id,\n        \"replaces_param\": parse_replaces_param,\n        \"to_tag\": parse_to_tag,\n        \"from_tag\": parse_from_tag,\n        \"early_flag\": parse_early_flag\n      };\n      if (startRule !== undefined) {\n        if (parseFunctions[startRule] === undefined) {\n          throw new Error(\"Invalid rule name: \" + quote(startRule) + \".\");\n        }\n      } else {\n        startRule = \"CRLF\";\n      }\n      var pos = 0;\n      var reportFailures = 0;\n      var rightmostFailuresPos = 0;\n      var rightmostFailuresExpected = [];\n      function padLeft(input, padding, length) {\n        var result = input;\n        var padLength = length - input.length;\n        for (var i = 0; i < padLength; i++) {\n          result = padding + result;\n        }\n        return result;\n      }\n      function escape(ch) {\n        var charCode = ch.charCodeAt(0);\n        var escapeChar;\n        var length;\n        if (charCode <= 0xFF) {\n          escapeChar = 'x';\n          length = 2;\n        } else {\n          escapeChar = 'u';\n          length = 4;\n        }\n        return '\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);\n      }\n      function matchFailed(failure) {\n        if (pos < rightmostFailuresPos) {\n          return;\n        }\n        if (pos > rightmostFailuresPos) {\n          rightmostFailuresPos = pos;\n          rightmostFailuresExpected = [];\n        }\n        rightmostFailuresExpected.push(failure);\n      }\n      function parse_CRLF() {\n        var result0;\n        if (input.substr(pos, 2) === \"\\r\\n\") {\n          result0 = \"\\r\\n\";\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"\\\\r\\\\n\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_DIGIT() {\n        var result0;\n        if (/^[0-9]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[0-9]\");\n          }\n        }\n        return result0;\n      }\n      function parse_ALPHA() {\n        var result0;\n        if (/^[a-zA-Z]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[a-zA-Z]\");\n          }\n        }\n        return result0;\n      }\n      function parse_HEXDIG() {\n        var result0;\n        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[0-9a-fA-F]\");\n          }\n        }\n        return result0;\n      }\n      function parse_WSP() {\n        var result0;\n        result0 = parse_SP();\n        if (result0 === null) {\n          result0 = parse_HTAB();\n        }\n        return result0;\n      }\n      function parse_OCTET() {\n        var result0;\n        if (/^[\\0-\\xFF]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[\\\\0-\\\\xFF]\");\n          }\n        }\n        return result0;\n      }\n      function parse_DQUOTE() {\n        var result0;\n        if (/^[\"]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[\\\"]\");\n          }\n        }\n        return result0;\n      }\n      function parse_SP() {\n        var result0;\n        if (input.charCodeAt(pos) === 32) {\n          result0 = \" \";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\" \\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_HTAB() {\n        var result0;\n        if (input.charCodeAt(pos) === 9) {\n          result0 = \"\\t\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"\\\\t\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_alphanum() {\n        var result0;\n        if (/^[a-zA-Z0-9]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[a-zA-Z0-9]\");\n          }\n        }\n        return result0;\n      }\n      function parse_reserved() {\n        var result0;\n        if (input.charCodeAt(pos) === 59) {\n          result0 = \";\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\";\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 47) {\n            result0 = \"/\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"/\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 63) {\n              result0 = \"?\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"?\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 58) {\n                result0 = \":\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\":\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 64) {\n                  result0 = \"@\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"@\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 38) {\n                    result0 = \"&\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"&\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 61) {\n                      result0 = \"=\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"=\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 43) {\n                        result0 = \"+\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"+\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 36) {\n                          result0 = \"$\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"$\\\"\");\n                          }\n                        }\n                        if (result0 === null) {\n                          if (input.charCodeAt(pos) === 44) {\n                            result0 = \",\";\n                            pos++;\n                          } else {\n                            result0 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\",\\\"\");\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_unreserved() {\n        var result0;\n        result0 = parse_alphanum();\n        if (result0 === null) {\n          result0 = parse_mark();\n        }\n        return result0;\n      }\n      function parse_mark() {\n        var result0;\n        if (input.charCodeAt(pos) === 45) {\n          result0 = \"-\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"-\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 95) {\n            result0 = \"_\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"_\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 46) {\n              result0 = \".\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 33) {\n                result0 = \"!\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"!\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 126) {\n                  result0 = \"~\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"~\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 42) {\n                    result0 = \"*\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"*\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 39) {\n                      result0 = \"'\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"'\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 40) {\n                        result0 = \"(\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"(\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 41) {\n                          result0 = \")\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\")\\\"\");\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_escaped() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 37) {\n          result0 = \"%\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"%\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_HEXDIG();\n          if (result1 !== null) {\n            result2 = parse_HEXDIG();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, escaped) {\n            return escaped.join('');\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_LWS() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        pos2 = pos;\n        result0 = [];\n        result1 = parse_WSP();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_WSP();\n        }\n        if (result0 !== null) {\n          result1 = parse_CRLF();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos2;\n          }\n        } else {\n          result0 = null;\n          pos = pos2;\n        }\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result2 = parse_WSP();\n          if (result2 !== null) {\n            result1 = [];\n            while (result2 !== null) {\n              result1.push(result2);\n              result2 = parse_WSP();\n            }\n          } else {\n            result1 = null;\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \" \";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SWS() {\n        var result0;\n        result0 = parse_LWS();\n        result0 = result0 !== null ? result0 : \"\";\n        return result0;\n      }\n      function parse_HCOLON() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = [];\n        result1 = parse_SP();\n        if (result1 === null) {\n          result1 = parse_HTAB();\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_SP();\n          if (result1 === null) {\n            result1 = parse_HTAB();\n          }\n        }\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return ':';\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_TEXT_UTF8_TRIM() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result1 = parse_TEXT_UTF8char();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_TEXT_UTF8char();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = [];\n          result3 = parse_LWS();\n          while (result3 !== null) {\n            result2.push(result3);\n            result3 = parse_LWS();\n          }\n          if (result2 !== null) {\n            result3 = parse_TEXT_UTF8char();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = [];\n            result3 = parse_LWS();\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_LWS();\n            }\n            if (result2 !== null) {\n              result3 = parse_TEXT_UTF8char();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_TEXT_UTF8char() {\n        var result0;\n        if (/^[!-~]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[!-~]\");\n          }\n        }\n        if (result0 === null) {\n          result0 = parse_UTF8_NONASCII();\n        }\n        return result0;\n      }\n      function parse_UTF8_NONASCII() {\n        var result0;\n        if (/^[\\x80-\\uFFFF]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed('[\\\\x80-\\\\uFFFF]');\n          }\n        }\n        return result0;\n      }\n      function parse_UTF8_CONT() {\n        var result0;\n        if (/^[\\x80-\\xBF]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[\\\\x80-\\\\xBF]\");\n          }\n        }\n        return result0;\n      }\n      function parse_LHEX() {\n        var result0;\n        result0 = parse_DIGIT();\n        if (result0 === null) {\n          if (/^[a-f]/.test(input.charAt(pos))) {\n            result0 = input.charAt(pos);\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[a-f]\");\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_token() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_alphanum();\n        if (result1 === null) {\n          if (input.charCodeAt(pos) === 45) {\n            result1 = \"-\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"-\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 46) {\n              result1 = \".\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 33) {\n                result1 = \"!\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"!\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 37) {\n                  result1 = \"%\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"%\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 42) {\n                    result1 = \"*\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"*\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 95) {\n                      result1 = \"_\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"_\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 43) {\n                        result1 = \"+\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"+\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 96) {\n                          result1 = \"`\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"`\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 39) {\n                            result1 = \"'\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"'\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 126) {\n                              result1 = \"~\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"~\\\"\");\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_alphanum();\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result1 = \"-\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 46) {\n                  result1 = \".\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\".\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 33) {\n                    result1 = \"!\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"!\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 37) {\n                      result1 = \"%\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"%\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 42) {\n                        result1 = \"*\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"*\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 95) {\n                          result1 = \"_\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"_\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 43) {\n                            result1 = \"+\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"+\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 96) {\n                              result1 = \"`\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"`\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 39) {\n                                result1 = \"'\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"'\\\"\");\n                                }\n                              }\n                              if (result1 === null) {\n                                if (input.charCodeAt(pos) === 126) {\n                                  result1 = \"~\";\n                                  pos++;\n                                } else {\n                                  result1 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\"~\\\"\");\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_token_nodot() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_alphanum();\n        if (result1 === null) {\n          if (input.charCodeAt(pos) === 45) {\n            result1 = \"-\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"-\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 33) {\n              result1 = \"!\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"!\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 37) {\n                result1 = \"%\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"%\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 42) {\n                  result1 = \"*\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"*\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 95) {\n                    result1 = \"_\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"_\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 43) {\n                      result1 = \"+\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"+\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 96) {\n                        result1 = \"`\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"`\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 39) {\n                          result1 = \"'\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"'\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 126) {\n                            result1 = \"~\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"~\\\"\");\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_alphanum();\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result1 = \"-\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 33) {\n                  result1 = \"!\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"!\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 37) {\n                    result1 = \"%\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"%\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 42) {\n                      result1 = \"*\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"*\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 95) {\n                        result1 = \"_\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"_\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 43) {\n                          result1 = \"+\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"+\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 96) {\n                            result1 = \"`\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"`\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 39) {\n                              result1 = \"'\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"'\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 126) {\n                                result1 = \"~\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"~\\\"\");\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_separators() {\n        var result0;\n        if (input.charCodeAt(pos) === 40) {\n          result0 = \"(\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"(\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 41) {\n            result0 = \")\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\")\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 60) {\n              result0 = \"<\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"<\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 62) {\n                result0 = \">\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\">\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 64) {\n                  result0 = \"@\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"@\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 44) {\n                    result0 = \",\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\",\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 59) {\n                      result0 = \";\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\";\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result0 = \":\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 92) {\n                          result0 = \"\\\\\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"\\\\\\\\\\\"\");\n                          }\n                        }\n                        if (result0 === null) {\n                          result0 = parse_DQUOTE();\n                          if (result0 === null) {\n                            if (input.charCodeAt(pos) === 47) {\n                              result0 = \"/\";\n                              pos++;\n                            } else {\n                              result0 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"/\\\"\");\n                              }\n                            }\n                            if (result0 === null) {\n                              if (input.charCodeAt(pos) === 91) {\n                                result0 = \"[\";\n                                pos++;\n                              } else {\n                                result0 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"[\\\"\");\n                                }\n                              }\n                              if (result0 === null) {\n                                if (input.charCodeAt(pos) === 93) {\n                                  result0 = \"]\";\n                                  pos++;\n                                } else {\n                                  result0 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\"]\\\"\");\n                                  }\n                                }\n                                if (result0 === null) {\n                                  if (input.charCodeAt(pos) === 63) {\n                                    result0 = \"?\";\n                                    pos++;\n                                  } else {\n                                    result0 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\"?\\\"\");\n                                    }\n                                  }\n                                  if (result0 === null) {\n                                    if (input.charCodeAt(pos) === 61) {\n                                      result0 = \"=\";\n                                      pos++;\n                                    } else {\n                                      result0 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\"=\\\"\");\n                                      }\n                                    }\n                                    if (result0 === null) {\n                                      if (input.charCodeAt(pos) === 123) {\n                                        result0 = \"{\";\n                                        pos++;\n                                      } else {\n                                        result0 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\"{\\\"\");\n                                        }\n                                      }\n                                      if (result0 === null) {\n                                        if (input.charCodeAt(pos) === 125) {\n                                          result0 = \"}\";\n                                          pos++;\n                                        } else {\n                                          result0 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\"}\\\"\");\n                                          }\n                                        }\n                                        if (result0 === null) {\n                                          result0 = parse_SP();\n                                          if (result0 === null) {\n                                            result0 = parse_HTAB();\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_word() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_alphanum();\n        if (result1 === null) {\n          if (input.charCodeAt(pos) === 45) {\n            result1 = \"-\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"-\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 46) {\n              result1 = \".\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 33) {\n                result1 = \"!\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"!\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 37) {\n                  result1 = \"%\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"%\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 42) {\n                    result1 = \"*\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"*\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 95) {\n                      result1 = \"_\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"_\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 43) {\n                        result1 = \"+\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"+\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 96) {\n                          result1 = \"`\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"`\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 39) {\n                            result1 = \"'\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"'\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 126) {\n                              result1 = \"~\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"~\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 40) {\n                                result1 = \"(\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"(\\\"\");\n                                }\n                              }\n                              if (result1 === null) {\n                                if (input.charCodeAt(pos) === 41) {\n                                  result1 = \")\";\n                                  pos++;\n                                } else {\n                                  result1 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\")\\\"\");\n                                  }\n                                }\n                                if (result1 === null) {\n                                  if (input.charCodeAt(pos) === 60) {\n                                    result1 = \"<\";\n                                    pos++;\n                                  } else {\n                                    result1 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\"<\\\"\");\n                                    }\n                                  }\n                                  if (result1 === null) {\n                                    if (input.charCodeAt(pos) === 62) {\n                                      result1 = \">\";\n                                      pos++;\n                                    } else {\n                                      result1 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\">\\\"\");\n                                      }\n                                    }\n                                    if (result1 === null) {\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result1 = \":\";\n                                        pos++;\n                                      } else {\n                                        result1 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result1 === null) {\n                                        if (input.charCodeAt(pos) === 92) {\n                                          result1 = \"\\\\\";\n                                          pos++;\n                                        } else {\n                                          result1 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\"\\\\\\\\\\\"\");\n                                          }\n                                        }\n                                        if (result1 === null) {\n                                          result1 = parse_DQUOTE();\n                                          if (result1 === null) {\n                                            if (input.charCodeAt(pos) === 47) {\n                                              result1 = \"/\";\n                                              pos++;\n                                            } else {\n                                              result1 = null;\n                                              if (reportFailures === 0) {\n                                                matchFailed(\"\\\"/\\\"\");\n                                              }\n                                            }\n                                            if (result1 === null) {\n                                              if (input.charCodeAt(pos) === 91) {\n                                                result1 = \"[\";\n                                                pos++;\n                                              } else {\n                                                result1 = null;\n                                                if (reportFailures === 0) {\n                                                  matchFailed(\"\\\"[\\\"\");\n                                                }\n                                              }\n                                              if (result1 === null) {\n                                                if (input.charCodeAt(pos) === 93) {\n                                                  result1 = \"]\";\n                                                  pos++;\n                                                } else {\n                                                  result1 = null;\n                                                  if (reportFailures === 0) {\n                                                    matchFailed(\"\\\"]\\\"\");\n                                                  }\n                                                }\n                                                if (result1 === null) {\n                                                  if (input.charCodeAt(pos) === 63) {\n                                                    result1 = \"?\";\n                                                    pos++;\n                                                  } else {\n                                                    result1 = null;\n                                                    if (reportFailures === 0) {\n                                                      matchFailed(\"\\\"?\\\"\");\n                                                    }\n                                                  }\n                                                  if (result1 === null) {\n                                                    if (input.charCodeAt(pos) === 123) {\n                                                      result1 = \"{\";\n                                                      pos++;\n                                                    } else {\n                                                      result1 = null;\n                                                      if (reportFailures === 0) {\n                                                        matchFailed(\"\\\"{\\\"\");\n                                                      }\n                                                    }\n                                                    if (result1 === null) {\n                                                      if (input.charCodeAt(pos) === 125) {\n                                                        result1 = \"}\";\n                                                        pos++;\n                                                      } else {\n                                                        result1 = null;\n                                                        if (reportFailures === 0) {\n                                                          matchFailed(\"\\\"}\\\"\");\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_alphanum();\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result1 = \"-\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 46) {\n                  result1 = \".\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\".\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 33) {\n                    result1 = \"!\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"!\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 37) {\n                      result1 = \"%\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"%\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 42) {\n                        result1 = \"*\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"*\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 95) {\n                          result1 = \"_\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"_\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 43) {\n                            result1 = \"+\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"+\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 96) {\n                              result1 = \"`\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"`\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 39) {\n                                result1 = \"'\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"'\\\"\");\n                                }\n                              }\n                              if (result1 === null) {\n                                if (input.charCodeAt(pos) === 126) {\n                                  result1 = \"~\";\n                                  pos++;\n                                } else {\n                                  result1 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\"~\\\"\");\n                                  }\n                                }\n                                if (result1 === null) {\n                                  if (input.charCodeAt(pos) === 40) {\n                                    result1 = \"(\";\n                                    pos++;\n                                  } else {\n                                    result1 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\"(\\\"\");\n                                    }\n                                  }\n                                  if (result1 === null) {\n                                    if (input.charCodeAt(pos) === 41) {\n                                      result1 = \")\";\n                                      pos++;\n                                    } else {\n                                      result1 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\")\\\"\");\n                                      }\n                                    }\n                                    if (result1 === null) {\n                                      if (input.charCodeAt(pos) === 60) {\n                                        result1 = \"<\";\n                                        pos++;\n                                      } else {\n                                        result1 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\"<\\\"\");\n                                        }\n                                      }\n                                      if (result1 === null) {\n                                        if (input.charCodeAt(pos) === 62) {\n                                          result1 = \">\";\n                                          pos++;\n                                        } else {\n                                          result1 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\">\\\"\");\n                                          }\n                                        }\n                                        if (result1 === null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result1 = \":\";\n                                            pos++;\n                                          } else {\n                                            result1 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result1 === null) {\n                                            if (input.charCodeAt(pos) === 92) {\n                                              result1 = \"\\\\\";\n                                              pos++;\n                                            } else {\n                                              result1 = null;\n                                              if (reportFailures === 0) {\n                                                matchFailed(\"\\\"\\\\\\\\\\\"\");\n                                              }\n                                            }\n                                            if (result1 === null) {\n                                              result1 = parse_DQUOTE();\n                                              if (result1 === null) {\n                                                if (input.charCodeAt(pos) === 47) {\n                                                  result1 = \"/\";\n                                                  pos++;\n                                                } else {\n                                                  result1 = null;\n                                                  if (reportFailures === 0) {\n                                                    matchFailed(\"\\\"/\\\"\");\n                                                  }\n                                                }\n                                                if (result1 === null) {\n                                                  if (input.charCodeAt(pos) === 91) {\n                                                    result1 = \"[\";\n                                                    pos++;\n                                                  } else {\n                                                    result1 = null;\n                                                    if (reportFailures === 0) {\n                                                      matchFailed(\"\\\"[\\\"\");\n                                                    }\n                                                  }\n                                                  if (result1 === null) {\n                                                    if (input.charCodeAt(pos) === 93) {\n                                                      result1 = \"]\";\n                                                      pos++;\n                                                    } else {\n                                                      result1 = null;\n                                                      if (reportFailures === 0) {\n                                                        matchFailed(\"\\\"]\\\"\");\n                                                      }\n                                                    }\n                                                    if (result1 === null) {\n                                                      if (input.charCodeAt(pos) === 63) {\n                                                        result1 = \"?\";\n                                                        pos++;\n                                                      } else {\n                                                        result1 = null;\n                                                        if (reportFailures === 0) {\n                                                          matchFailed(\"\\\"?\\\"\");\n                                                        }\n                                                      }\n                                                      if (result1 === null) {\n                                                        if (input.charCodeAt(pos) === 123) {\n                                                          result1 = \"{\";\n                                                          pos++;\n                                                        } else {\n                                                          result1 = null;\n                                                          if (reportFailures === 0) {\n                                                            matchFailed(\"\\\"{\\\"\");\n                                                          }\n                                                        }\n                                                        if (result1 === null) {\n                                                          if (input.charCodeAt(pos) === 125) {\n                                                            result1 = \"}\";\n                                                            pos++;\n                                                          } else {\n                                                            result1 = null;\n                                                            if (reportFailures === 0) {\n                                                              matchFailed(\"\\\"}\\\"\");\n                                                            }\n                                                          }\n                                                        }\n                                                      }\n                                                    }\n                                                  }\n                                                }\n                                              }\n                                            }\n                                          }\n                                        }\n                                      }\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_STAR() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 42) {\n            result1 = \"*\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"*\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"*\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SLASH() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 47) {\n            result1 = \"/\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"/\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"/\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_EQUAL() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 61) {\n            result1 = \"=\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"=\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_LPAREN() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 40) {\n            result1 = \"(\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"(\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"(\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_RPAREN() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 41) {\n            result1 = \")\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\")\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \")\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_RAQUOT() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 62) {\n          result0 = \">\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\">\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_SWS();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \">\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_LAQUOT() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 60) {\n            result1 = \"<\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"<\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"<\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_COMMA() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 44) {\n            result1 = \",\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\",\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \",\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SEMI() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 59) {\n            result1 = \";\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\";\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \";\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_COLON() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_SWS();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \":\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_LDQUOT() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          result1 = parse_DQUOTE();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"\\\"\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_RDQUOT() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_DQUOTE();\n        if (result0 !== null) {\n          result1 = parse_SWS();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return \"\\\"\";\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_comment() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_LPAREN();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_ctext();\n          if (result2 === null) {\n            result2 = parse_quoted_pair();\n            if (result2 === null) {\n              result2 = parse_comment();\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_ctext();\n            if (result2 === null) {\n              result2 = parse_quoted_pair();\n              if (result2 === null) {\n                result2 = parse_comment();\n              }\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_RPAREN();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_ctext() {\n        var result0;\n        if (/^[!-']/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[!-']\");\n          }\n        }\n        if (result0 === null) {\n          if (/^[*-[]/.test(input.charAt(pos))) {\n            result0 = input.charAt(pos);\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[*-[]\");\n            }\n          }\n          if (result0 === null) {\n            if (/^[\\]-~]/.test(input.charAt(pos))) {\n              result0 = input.charAt(pos);\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[\\\\]-~]\");\n              }\n            }\n            if (result0 === null) {\n              result0 = parse_UTF8_NONASCII();\n              if (result0 === null) {\n                result0 = parse_LWS();\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_quoted_string() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          result1 = parse_DQUOTE();\n          if (result1 !== null) {\n            result2 = [];\n            result3 = parse_qdtext();\n            if (result3 === null) {\n              result3 = parse_quoted_pair();\n            }\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_qdtext();\n              if (result3 === null) {\n                result3 = parse_quoted_pair();\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_DQUOTE();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_quoted_string_clean() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SWS();\n        if (result0 !== null) {\n          result1 = parse_DQUOTE();\n          if (result1 !== null) {\n            result2 = [];\n            result3 = parse_qdtext();\n            if (result3 === null) {\n              result3 = parse_quoted_pair();\n            }\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_qdtext();\n              if (result3 === null) {\n                result3 = parse_quoted_pair();\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_DQUOTE();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return input.substring(pos - 1, offset + 1);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_qdtext() {\n        var result0;\n        result0 = parse_LWS();\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 33) {\n            result0 = \"!\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"!\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (/^[#-[]/.test(input.charAt(pos))) {\n              result0 = input.charAt(pos);\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[#-[]\");\n              }\n            }\n            if (result0 === null) {\n              if (/^[\\]-~]/.test(input.charAt(pos))) {\n                result0 = input.charAt(pos);\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"[\\\\]-~]\");\n                }\n              }\n              if (result0 === null) {\n                result0 = parse_UTF8_NONASCII();\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_quoted_pair() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        if (input.charCodeAt(pos) === 92) {\n          result0 = \"\\\\\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"\\\\\\\\\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (/^[\\0-\\t]/.test(input.charAt(pos))) {\n            result1 = input.charAt(pos);\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[\\\\0-\\\\t]\");\n            }\n          }\n          if (result1 === null) {\n            if (/^[\\x0B-\\f]/.test(input.charAt(pos))) {\n              result1 = input.charAt(pos);\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[\\\\x0B-\\\\f]\");\n              }\n            }\n            if (result1 === null) {\n              if (/^[\\x0E-]/.test(input.charAt(pos))) {\n                result1 = input.charAt(pos);\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"[\\\\x0E-]\");\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SIP_URI_noparams() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_uri_scheme();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_userinfo();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_hostport();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            try {\n              data.uri = new URI(data.scheme, data.user, data.host, data.port);\n              delete data.scheme;\n              delete data.user;\n              delete data.host;\n              delete data.host_type;\n              delete data.port;\n            } catch (e) {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_SIP_URI() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_uri_scheme();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_userinfo();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_hostport();\n              if (result3 !== null) {\n                result4 = parse_uri_parameters();\n                if (result4 !== null) {\n                  result5 = parse_headers();\n                  result5 = result5 !== null ? result5 : \"\";\n                  if (result5 !== null) {\n                    result0 = [result0, result1, result2, result3, result4, result5];\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var header;\n            try {\n              data.uri = new URI(data.scheme, data.user, data.host, data.port, data.uri_params, data.uri_headers);\n              delete data.scheme;\n              delete data.user;\n              delete data.host;\n              delete data.host_type;\n              delete data.port;\n              delete data.uri_params;\n              if (startRule === 'SIP_URI') {\n                data = data.uri;\n              }\n            } catch (e) {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uri_scheme() {\n        var result0;\n        result0 = parse_uri_scheme_sips();\n        if (result0 === null) {\n          result0 = parse_uri_scheme_sip();\n        }\n        return result0;\n      }\n      function parse_uri_scheme_sips() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 4).toLowerCase() === \"sips\") {\n          result0 = input.substr(pos, 4);\n          pos += 4;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"sips\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset, scheme) {\n            data.scheme = scheme.toLowerCase();\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uri_scheme_sip() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"sip\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"sip\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset, scheme) {\n            data.scheme = scheme.toLowerCase();\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_userinfo() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_user();\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_password();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            if (input.charCodeAt(pos) === 64) {\n              result2 = \"@\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"@\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.user = decodeURIComponent(input.substring(pos - 1, offset));\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_user() {\n        var result0, result1;\n        result1 = parse_unreserved();\n        if (result1 === null) {\n          result1 = parse_escaped();\n          if (result1 === null) {\n            result1 = parse_user_unreserved();\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_unreserved();\n            if (result1 === null) {\n              result1 = parse_escaped();\n              if (result1 === null) {\n                result1 = parse_user_unreserved();\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        return result0;\n      }\n      function parse_user_unreserved() {\n        var result0;\n        if (input.charCodeAt(pos) === 38) {\n          result0 = \"&\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"&\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 61) {\n            result0 = \"=\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 43) {\n              result0 = \"+\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"+\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 36) {\n                result0 = \"$\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"$\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 44) {\n                  result0 = \",\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\",\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 59) {\n                    result0 = \";\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\";\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 63) {\n                      result0 = \"?\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"?\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 47) {\n                        result0 = \"/\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"/\\\"\");\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_password() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result0 = [];\n        result1 = parse_unreserved();\n        if (result1 === null) {\n          result1 = parse_escaped();\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 38) {\n              result1 = \"&\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"&\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 61) {\n                result1 = \"=\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"=\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 43) {\n                  result1 = \"+\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"+\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 36) {\n                    result1 = \"$\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"$\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 44) {\n                      result1 = \",\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\",\\\"\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_unreserved();\n          if (result1 === null) {\n            result1 = parse_escaped();\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 38) {\n                result1 = \"&\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"&\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 61) {\n                  result1 = \"=\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"=\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 43) {\n                    result1 = \"+\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"+\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 36) {\n                      result1 = \"$\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"$\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 44) {\n                        result1 = \",\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\",\\\"\");\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.password = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hostport() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_host();\n        if (result0 !== null) {\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_port();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos1;\n            }\n          } else {\n            result1 = null;\n            pos = pos1;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_host() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_hostname();\n        if (result0 === null) {\n          result0 = parse_IPv4address();\n          if (result0 === null) {\n            result0 = parse_IPv6reference();\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.host = input.substring(pos, offset).toLowerCase();\n            return data.host;\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hostname() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = [];\n        pos2 = pos;\n        result1 = parse_domainlabel();\n        if (result1 !== null) {\n          if (input.charCodeAt(pos) === 46) {\n            result2 = \".\";\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          if (result2 !== null) {\n            result1 = [result1, result2];\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n        } else {\n          result1 = null;\n          pos = pos2;\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          pos2 = pos;\n          result1 = parse_domainlabel();\n          if (result1 !== null) {\n            if (input.charCodeAt(pos) === 46) {\n              result2 = \".\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_toplabel();\n          if (result1 !== null) {\n            if (input.charCodeAt(pos) === 46) {\n              result2 = \".\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.host_type = 'domain';\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_domainlabel() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_alphanum();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_alphanum();\n          if (result2 === null) {\n            if (input.charCodeAt(pos) === 45) {\n              result2 = \"-\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"-\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 95) {\n                result2 = \"_\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"_\\\"\");\n                }\n              }\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_alphanum();\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result2 = \"-\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result2 === null) {\n                if (input.charCodeAt(pos) === 95) {\n                  result2 = \"_\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"_\\\"\");\n                  }\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_toplabel() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_ALPHA();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_alphanum();\n          if (result2 === null) {\n            if (input.charCodeAt(pos) === 45) {\n              result2 = \"-\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"-\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 95) {\n                result2 = \"_\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"_\\\"\");\n                }\n              }\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_alphanum();\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 45) {\n                result2 = \"-\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result2 === null) {\n                if (input.charCodeAt(pos) === 95) {\n                  result2 = \"_\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"_\\\"\");\n                  }\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_IPv6reference() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 91) {\n          result0 = \"[\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"[\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_IPv6address();\n          if (result1 !== null) {\n            if (input.charCodeAt(pos) === 93) {\n              result2 = \"]\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"]\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.host_type = 'IPv6';\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_IPv6address() {\n        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_h16();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_h16();\n            if (result2 !== null) {\n              if (input.charCodeAt(pos) === 58) {\n                result3 = \":\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\":\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result4 = parse_h16();\n                if (result4 !== null) {\n                  if (input.charCodeAt(pos) === 58) {\n                    result5 = \":\";\n                    pos++;\n                  } else {\n                    result5 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\":\\\"\");\n                    }\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_h16();\n                    if (result6 !== null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result7 = \":\";\n                        pos++;\n                      } else {\n                        result7 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result7 !== null) {\n                        result8 = parse_h16();\n                        if (result8 !== null) {\n                          if (input.charCodeAt(pos) === 58) {\n                            result9 = \":\";\n                            pos++;\n                          } else {\n                            result9 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\":\\\"\");\n                            }\n                          }\n                          if (result9 !== null) {\n                            result10 = parse_h16();\n                            if (result10 !== null) {\n                              if (input.charCodeAt(pos) === 58) {\n                                result11 = \":\";\n                                pos++;\n                              } else {\n                                result11 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\":\\\"\");\n                                }\n                              }\n                              if (result11 !== null) {\n                                result12 = parse_ls32();\n                                if (result12 !== null) {\n                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12];\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 === null) {\n          pos1 = pos;\n          if (input.substr(pos, 2) === \"::\") {\n            result0 = \"::\";\n            pos += 2;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"::\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            result1 = parse_h16();\n            if (result1 !== null) {\n              if (input.charCodeAt(pos) === 58) {\n                result2 = \":\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\":\\\"\");\n                }\n              }\n              if (result2 !== null) {\n                result3 = parse_h16();\n                if (result3 !== null) {\n                  if (input.charCodeAt(pos) === 58) {\n                    result4 = \":\";\n                    pos++;\n                  } else {\n                    result4 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\":\\\"\");\n                    }\n                  }\n                  if (result4 !== null) {\n                    result5 = parse_h16();\n                    if (result5 !== null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result6 = \":\";\n                        pos++;\n                      } else {\n                        result6 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result6 !== null) {\n                        result7 = parse_h16();\n                        if (result7 !== null) {\n                          if (input.charCodeAt(pos) === 58) {\n                            result8 = \":\";\n                            pos++;\n                          } else {\n                            result8 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\":\\\"\");\n                            }\n                          }\n                          if (result8 !== null) {\n                            result9 = parse_h16();\n                            if (result9 !== null) {\n                              if (input.charCodeAt(pos) === 58) {\n                                result10 = \":\";\n                                pos++;\n                              } else {\n                                result10 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\":\\\"\");\n                                }\n                              }\n                              if (result10 !== null) {\n                                result11 = parse_ls32();\n                                if (result11 !== null) {\n                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11];\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 === null) {\n            pos1 = pos;\n            if (input.substr(pos, 2) === \"::\") {\n              result0 = \"::\";\n              pos += 2;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"::\\\"\");\n              }\n            }\n            if (result0 !== null) {\n              result1 = parse_h16();\n              if (result1 !== null) {\n                if (input.charCodeAt(pos) === 58) {\n                  result2 = \":\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\":\\\"\");\n                  }\n                }\n                if (result2 !== null) {\n                  result3 = parse_h16();\n                  if (result3 !== null) {\n                    if (input.charCodeAt(pos) === 58) {\n                      result4 = \":\";\n                      pos++;\n                    } else {\n                      result4 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\":\\\"\");\n                      }\n                    }\n                    if (result4 !== null) {\n                      result5 = parse_h16();\n                      if (result5 !== null) {\n                        if (input.charCodeAt(pos) === 58) {\n                          result6 = \":\";\n                          pos++;\n                        } else {\n                          result6 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\":\\\"\");\n                          }\n                        }\n                        if (result6 !== null) {\n                          result7 = parse_h16();\n                          if (result7 !== null) {\n                            if (input.charCodeAt(pos) === 58) {\n                              result8 = \":\";\n                              pos++;\n                            } else {\n                              result8 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\":\\\"\");\n                              }\n                            }\n                            if (result8 !== null) {\n                              result9 = parse_ls32();\n                              if (result9 !== null) {\n                                result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n            if (result0 === null) {\n              pos1 = pos;\n              if (input.substr(pos, 2) === \"::\") {\n                result0 = \"::\";\n                pos += 2;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"::\\\"\");\n                }\n              }\n              if (result0 !== null) {\n                result1 = parse_h16();\n                if (result1 !== null) {\n                  if (input.charCodeAt(pos) === 58) {\n                    result2 = \":\";\n                    pos++;\n                  } else {\n                    result2 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\":\\\"\");\n                    }\n                  }\n                  if (result2 !== null) {\n                    result3 = parse_h16();\n                    if (result3 !== null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result4 = \":\";\n                        pos++;\n                      } else {\n                        result4 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result4 !== null) {\n                        result5 = parse_h16();\n                        if (result5 !== null) {\n                          if (input.charCodeAt(pos) === 58) {\n                            result6 = \":\";\n                            pos++;\n                          } else {\n                            result6 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\":\\\"\");\n                            }\n                          }\n                          if (result6 !== null) {\n                            result7 = parse_ls32();\n                            if (result7 !== null) {\n                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n              if (result0 === null) {\n                pos1 = pos;\n                if (input.substr(pos, 2) === \"::\") {\n                  result0 = \"::\";\n                  pos += 2;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"::\\\"\");\n                  }\n                }\n                if (result0 !== null) {\n                  result1 = parse_h16();\n                  if (result1 !== null) {\n                    if (input.charCodeAt(pos) === 58) {\n                      result2 = \":\";\n                      pos++;\n                    } else {\n                      result2 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\":\\\"\");\n                      }\n                    }\n                    if (result2 !== null) {\n                      result3 = parse_h16();\n                      if (result3 !== null) {\n                        if (input.charCodeAt(pos) === 58) {\n                          result4 = \":\";\n                          pos++;\n                        } else {\n                          result4 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\":\\\"\");\n                          }\n                        }\n                        if (result4 !== null) {\n                          result5 = parse_ls32();\n                          if (result5 !== null) {\n                            result0 = [result0, result1, result2, result3, result4, result5];\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n                if (result0 === null) {\n                  pos1 = pos;\n                  if (input.substr(pos, 2) === \"::\") {\n                    result0 = \"::\";\n                    pos += 2;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"::\\\"\");\n                    }\n                  }\n                  if (result0 !== null) {\n                    result1 = parse_h16();\n                    if (result1 !== null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result2 = \":\";\n                        pos++;\n                      } else {\n                        result2 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result2 !== null) {\n                        result3 = parse_ls32();\n                        if (result3 !== null) {\n                          result0 = [result0, result1, result2, result3];\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                  if (result0 === null) {\n                    pos1 = pos;\n                    if (input.substr(pos, 2) === \"::\") {\n                      result0 = \"::\";\n                      pos += 2;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"::\\\"\");\n                      }\n                    }\n                    if (result0 !== null) {\n                      result1 = parse_ls32();\n                      if (result1 !== null) {\n                        result0 = [result0, result1];\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                    if (result0 === null) {\n                      pos1 = pos;\n                      if (input.substr(pos, 2) === \"::\") {\n                        result0 = \"::\";\n                        pos += 2;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"::\\\"\");\n                        }\n                      }\n                      if (result0 !== null) {\n                        result1 = parse_h16();\n                        if (result1 !== null) {\n                          result0 = [result0, result1];\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                      if (result0 === null) {\n                        pos1 = pos;\n                        result0 = parse_h16();\n                        if (result0 !== null) {\n                          if (input.substr(pos, 2) === \"::\") {\n                            result1 = \"::\";\n                            pos += 2;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"::\\\"\");\n                            }\n                          }\n                          if (result1 !== null) {\n                            result2 = parse_h16();\n                            if (result2 !== null) {\n                              if (input.charCodeAt(pos) === 58) {\n                                result3 = \":\";\n                                pos++;\n                              } else {\n                                result3 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\":\\\"\");\n                                }\n                              }\n                              if (result3 !== null) {\n                                result4 = parse_h16();\n                                if (result4 !== null) {\n                                  if (input.charCodeAt(pos) === 58) {\n                                    result5 = \":\";\n                                    pos++;\n                                  } else {\n                                    result5 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\":\\\"\");\n                                    }\n                                  }\n                                  if (result5 !== null) {\n                                    result6 = parse_h16();\n                                    if (result6 !== null) {\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result7 = \":\";\n                                        pos++;\n                                      } else {\n                                        result7 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result7 !== null) {\n                                        result8 = parse_h16();\n                                        if (result8 !== null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result9 = \":\";\n                                            pos++;\n                                          } else {\n                                            result9 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result9 !== null) {\n                                            result10 = parse_ls32();\n                                            if (result10 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                        if (result0 === null) {\n                          pos1 = pos;\n                          result0 = parse_h16();\n                          if (result0 !== null) {\n                            pos2 = pos;\n                            if (input.charCodeAt(pos) === 58) {\n                              result1 = \":\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\":\\\"\");\n                              }\n                            }\n                            if (result1 !== null) {\n                              result2 = parse_h16();\n                              if (result2 !== null) {\n                                result1 = [result1, result2];\n                              } else {\n                                result1 = null;\n                                pos = pos2;\n                              }\n                            } else {\n                              result1 = null;\n                              pos = pos2;\n                            }\n                            result1 = result1 !== null ? result1 : \"\";\n                            if (result1 !== null) {\n                              if (input.substr(pos, 2) === \"::\") {\n                                result2 = \"::\";\n                                pos += 2;\n                              } else {\n                                result2 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"::\\\"\");\n                                }\n                              }\n                              if (result2 !== null) {\n                                result3 = parse_h16();\n                                if (result3 !== null) {\n                                  if (input.charCodeAt(pos) === 58) {\n                                    result4 = \":\";\n                                    pos++;\n                                  } else {\n                                    result4 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\":\\\"\");\n                                    }\n                                  }\n                                  if (result4 !== null) {\n                                    result5 = parse_h16();\n                                    if (result5 !== null) {\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result6 = \":\";\n                                        pos++;\n                                      } else {\n                                        result6 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result6 !== null) {\n                                        result7 = parse_h16();\n                                        if (result7 !== null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result8 = \":\";\n                                            pos++;\n                                          } else {\n                                            result8 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result8 !== null) {\n                                            result9 = parse_ls32();\n                                            if (result9 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                          if (result0 === null) {\n                            pos1 = pos;\n                            result0 = parse_h16();\n                            if (result0 !== null) {\n                              pos2 = pos;\n                              if (input.charCodeAt(pos) === 58) {\n                                result1 = \":\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\":\\\"\");\n                                }\n                              }\n                              if (result1 !== null) {\n                                result2 = parse_h16();\n                                if (result2 !== null) {\n                                  result1 = [result1, result2];\n                                } else {\n                                  result1 = null;\n                                  pos = pos2;\n                                }\n                              } else {\n                                result1 = null;\n                                pos = pos2;\n                              }\n                              result1 = result1 !== null ? result1 : \"\";\n                              if (result1 !== null) {\n                                pos2 = pos;\n                                if (input.charCodeAt(pos) === 58) {\n                                  result2 = \":\";\n                                  pos++;\n                                } else {\n                                  result2 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\":\\\"\");\n                                  }\n                                }\n                                if (result2 !== null) {\n                                  result3 = parse_h16();\n                                  if (result3 !== null) {\n                                    result2 = [result2, result3];\n                                  } else {\n                                    result2 = null;\n                                    pos = pos2;\n                                  }\n                                } else {\n                                  result2 = null;\n                                  pos = pos2;\n                                }\n                                result2 = result2 !== null ? result2 : \"\";\n                                if (result2 !== null) {\n                                  if (input.substr(pos, 2) === \"::\") {\n                                    result3 = \"::\";\n                                    pos += 2;\n                                  } else {\n                                    result3 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\"::\\\"\");\n                                    }\n                                  }\n                                  if (result3 !== null) {\n                                    result4 = parse_h16();\n                                    if (result4 !== null) {\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result5 = \":\";\n                                        pos++;\n                                      } else {\n                                        result5 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result5 !== null) {\n                                        result6 = parse_h16();\n                                        if (result6 !== null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result7 = \":\";\n                                            pos++;\n                                          } else {\n                                            result7 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result7 !== null) {\n                                            result8 = parse_ls32();\n                                            if (result8 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                            if (result0 === null) {\n                              pos1 = pos;\n                              result0 = parse_h16();\n                              if (result0 !== null) {\n                                pos2 = pos;\n                                if (input.charCodeAt(pos) === 58) {\n                                  result1 = \":\";\n                                  pos++;\n                                } else {\n                                  result1 = null;\n                                  if (reportFailures === 0) {\n                                    matchFailed(\"\\\":\\\"\");\n                                  }\n                                }\n                                if (result1 !== null) {\n                                  result2 = parse_h16();\n                                  if (result2 !== null) {\n                                    result1 = [result1, result2];\n                                  } else {\n                                    result1 = null;\n                                    pos = pos2;\n                                  }\n                                } else {\n                                  result1 = null;\n                                  pos = pos2;\n                                }\n                                result1 = result1 !== null ? result1 : \"\";\n                                if (result1 !== null) {\n                                  pos2 = pos;\n                                  if (input.charCodeAt(pos) === 58) {\n                                    result2 = \":\";\n                                    pos++;\n                                  } else {\n                                    result2 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\":\\\"\");\n                                    }\n                                  }\n                                  if (result2 !== null) {\n                                    result3 = parse_h16();\n                                    if (result3 !== null) {\n                                      result2 = [result2, result3];\n                                    } else {\n                                      result2 = null;\n                                      pos = pos2;\n                                    }\n                                  } else {\n                                    result2 = null;\n                                    pos = pos2;\n                                  }\n                                  result2 = result2 !== null ? result2 : \"\";\n                                  if (result2 !== null) {\n                                    pos2 = pos;\n                                    if (input.charCodeAt(pos) === 58) {\n                                      result3 = \":\";\n                                      pos++;\n                                    } else {\n                                      result3 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\":\\\"\");\n                                      }\n                                    }\n                                    if (result3 !== null) {\n                                      result4 = parse_h16();\n                                      if (result4 !== null) {\n                                        result3 = [result3, result4];\n                                      } else {\n                                        result3 = null;\n                                        pos = pos2;\n                                      }\n                                    } else {\n                                      result3 = null;\n                                      pos = pos2;\n                                    }\n                                    result3 = result3 !== null ? result3 : \"\";\n                                    if (result3 !== null) {\n                                      if (input.substr(pos, 2) === \"::\") {\n                                        result4 = \"::\";\n                                        pos += 2;\n                                      } else {\n                                        result4 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\"::\\\"\");\n                                        }\n                                      }\n                                      if (result4 !== null) {\n                                        result5 = parse_h16();\n                                        if (result5 !== null) {\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result6 = \":\";\n                                            pos++;\n                                          } else {\n                                            result6 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result6 !== null) {\n                                            result7 = parse_ls32();\n                                            if (result7 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                              if (result0 === null) {\n                                pos1 = pos;\n                                result0 = parse_h16();\n                                if (result0 !== null) {\n                                  pos2 = pos;\n                                  if (input.charCodeAt(pos) === 58) {\n                                    result1 = \":\";\n                                    pos++;\n                                  } else {\n                                    result1 = null;\n                                    if (reportFailures === 0) {\n                                      matchFailed(\"\\\":\\\"\");\n                                    }\n                                  }\n                                  if (result1 !== null) {\n                                    result2 = parse_h16();\n                                    if (result2 !== null) {\n                                      result1 = [result1, result2];\n                                    } else {\n                                      result1 = null;\n                                      pos = pos2;\n                                    }\n                                  } else {\n                                    result1 = null;\n                                    pos = pos2;\n                                  }\n                                  result1 = result1 !== null ? result1 : \"\";\n                                  if (result1 !== null) {\n                                    pos2 = pos;\n                                    if (input.charCodeAt(pos) === 58) {\n                                      result2 = \":\";\n                                      pos++;\n                                    } else {\n                                      result2 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\":\\\"\");\n                                      }\n                                    }\n                                    if (result2 !== null) {\n                                      result3 = parse_h16();\n                                      if (result3 !== null) {\n                                        result2 = [result2, result3];\n                                      } else {\n                                        result2 = null;\n                                        pos = pos2;\n                                      }\n                                    } else {\n                                      result2 = null;\n                                      pos = pos2;\n                                    }\n                                    result2 = result2 !== null ? result2 : \"\";\n                                    if (result2 !== null) {\n                                      pos2 = pos;\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result3 = \":\";\n                                        pos++;\n                                      } else {\n                                        result3 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result3 !== null) {\n                                        result4 = parse_h16();\n                                        if (result4 !== null) {\n                                          result3 = [result3, result4];\n                                        } else {\n                                          result3 = null;\n                                          pos = pos2;\n                                        }\n                                      } else {\n                                        result3 = null;\n                                        pos = pos2;\n                                      }\n                                      result3 = result3 !== null ? result3 : \"\";\n                                      if (result3 !== null) {\n                                        pos2 = pos;\n                                        if (input.charCodeAt(pos) === 58) {\n                                          result4 = \":\";\n                                          pos++;\n                                        } else {\n                                          result4 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\":\\\"\");\n                                          }\n                                        }\n                                        if (result4 !== null) {\n                                          result5 = parse_h16();\n                                          if (result5 !== null) {\n                                            result4 = [result4, result5];\n                                          } else {\n                                            result4 = null;\n                                            pos = pos2;\n                                          }\n                                        } else {\n                                          result4 = null;\n                                          pos = pos2;\n                                        }\n                                        result4 = result4 !== null ? result4 : \"\";\n                                        if (result4 !== null) {\n                                          if (input.substr(pos, 2) === \"::\") {\n                                            result5 = \"::\";\n                                            pos += 2;\n                                          } else {\n                                            result5 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\"::\\\"\");\n                                            }\n                                          }\n                                          if (result5 !== null) {\n                                            result6 = parse_ls32();\n                                            if (result6 !== null) {\n                                              result0 = [result0, result1, result2, result3, result4, result5, result6];\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                                if (result0 === null) {\n                                  pos1 = pos;\n                                  result0 = parse_h16();\n                                  if (result0 !== null) {\n                                    pos2 = pos;\n                                    if (input.charCodeAt(pos) === 58) {\n                                      result1 = \":\";\n                                      pos++;\n                                    } else {\n                                      result1 = null;\n                                      if (reportFailures === 0) {\n                                        matchFailed(\"\\\":\\\"\");\n                                      }\n                                    }\n                                    if (result1 !== null) {\n                                      result2 = parse_h16();\n                                      if (result2 !== null) {\n                                        result1 = [result1, result2];\n                                      } else {\n                                        result1 = null;\n                                        pos = pos2;\n                                      }\n                                    } else {\n                                      result1 = null;\n                                      pos = pos2;\n                                    }\n                                    result1 = result1 !== null ? result1 : \"\";\n                                    if (result1 !== null) {\n                                      pos2 = pos;\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result2 = \":\";\n                                        pos++;\n                                      } else {\n                                        result2 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result2 !== null) {\n                                        result3 = parse_h16();\n                                        if (result3 !== null) {\n                                          result2 = [result2, result3];\n                                        } else {\n                                          result2 = null;\n                                          pos = pos2;\n                                        }\n                                      } else {\n                                        result2 = null;\n                                        pos = pos2;\n                                      }\n                                      result2 = result2 !== null ? result2 : \"\";\n                                      if (result2 !== null) {\n                                        pos2 = pos;\n                                        if (input.charCodeAt(pos) === 58) {\n                                          result3 = \":\";\n                                          pos++;\n                                        } else {\n                                          result3 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\":\\\"\");\n                                          }\n                                        }\n                                        if (result3 !== null) {\n                                          result4 = parse_h16();\n                                          if (result4 !== null) {\n                                            result3 = [result3, result4];\n                                          } else {\n                                            result3 = null;\n                                            pos = pos2;\n                                          }\n                                        } else {\n                                          result3 = null;\n                                          pos = pos2;\n                                        }\n                                        result3 = result3 !== null ? result3 : \"\";\n                                        if (result3 !== null) {\n                                          pos2 = pos;\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result4 = \":\";\n                                            pos++;\n                                          } else {\n                                            result4 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result4 !== null) {\n                                            result5 = parse_h16();\n                                            if (result5 !== null) {\n                                              result4 = [result4, result5];\n                                            } else {\n                                              result4 = null;\n                                              pos = pos2;\n                                            }\n                                          } else {\n                                            result4 = null;\n                                            pos = pos2;\n                                          }\n                                          result4 = result4 !== null ? result4 : \"\";\n                                          if (result4 !== null) {\n                                            pos2 = pos;\n                                            if (input.charCodeAt(pos) === 58) {\n                                              result5 = \":\";\n                                              pos++;\n                                            } else {\n                                              result5 = null;\n                                              if (reportFailures === 0) {\n                                                matchFailed(\"\\\":\\\"\");\n                                              }\n                                            }\n                                            if (result5 !== null) {\n                                              result6 = parse_h16();\n                                              if (result6 !== null) {\n                                                result5 = [result5, result6];\n                                              } else {\n                                                result5 = null;\n                                                pos = pos2;\n                                              }\n                                            } else {\n                                              result5 = null;\n                                              pos = pos2;\n                                            }\n                                            result5 = result5 !== null ? result5 : \"\";\n                                            if (result5 !== null) {\n                                              if (input.substr(pos, 2) === \"::\") {\n                                                result6 = \"::\";\n                                                pos += 2;\n                                              } else {\n                                                result6 = null;\n                                                if (reportFailures === 0) {\n                                                  matchFailed(\"\\\"::\\\"\");\n                                                }\n                                              }\n                                              if (result6 !== null) {\n                                                result7 = parse_h16();\n                                                if (result7 !== null) {\n                                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7];\n                                                } else {\n                                                  result0 = null;\n                                                  pos = pos1;\n                                                }\n                                              } else {\n                                                result0 = null;\n                                                pos = pos1;\n                                              }\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                  if (result0 === null) {\n                                    pos1 = pos;\n                                    result0 = parse_h16();\n                                    if (result0 !== null) {\n                                      pos2 = pos;\n                                      if (input.charCodeAt(pos) === 58) {\n                                        result1 = \":\";\n                                        pos++;\n                                      } else {\n                                        result1 = null;\n                                        if (reportFailures === 0) {\n                                          matchFailed(\"\\\":\\\"\");\n                                        }\n                                      }\n                                      if (result1 !== null) {\n                                        result2 = parse_h16();\n                                        if (result2 !== null) {\n                                          result1 = [result1, result2];\n                                        } else {\n                                          result1 = null;\n                                          pos = pos2;\n                                        }\n                                      } else {\n                                        result1 = null;\n                                        pos = pos2;\n                                      }\n                                      result1 = result1 !== null ? result1 : \"\";\n                                      if (result1 !== null) {\n                                        pos2 = pos;\n                                        if (input.charCodeAt(pos) === 58) {\n                                          result2 = \":\";\n                                          pos++;\n                                        } else {\n                                          result2 = null;\n                                          if (reportFailures === 0) {\n                                            matchFailed(\"\\\":\\\"\");\n                                          }\n                                        }\n                                        if (result2 !== null) {\n                                          result3 = parse_h16();\n                                          if (result3 !== null) {\n                                            result2 = [result2, result3];\n                                          } else {\n                                            result2 = null;\n                                            pos = pos2;\n                                          }\n                                        } else {\n                                          result2 = null;\n                                          pos = pos2;\n                                        }\n                                        result2 = result2 !== null ? result2 : \"\";\n                                        if (result2 !== null) {\n                                          pos2 = pos;\n                                          if (input.charCodeAt(pos) === 58) {\n                                            result3 = \":\";\n                                            pos++;\n                                          } else {\n                                            result3 = null;\n                                            if (reportFailures === 0) {\n                                              matchFailed(\"\\\":\\\"\");\n                                            }\n                                          }\n                                          if (result3 !== null) {\n                                            result4 = parse_h16();\n                                            if (result4 !== null) {\n                                              result3 = [result3, result4];\n                                            } else {\n                                              result3 = null;\n                                              pos = pos2;\n                                            }\n                                          } else {\n                                            result3 = null;\n                                            pos = pos2;\n                                          }\n                                          result3 = result3 !== null ? result3 : \"\";\n                                          if (result3 !== null) {\n                                            pos2 = pos;\n                                            if (input.charCodeAt(pos) === 58) {\n                                              result4 = \":\";\n                                              pos++;\n                                            } else {\n                                              result4 = null;\n                                              if (reportFailures === 0) {\n                                                matchFailed(\"\\\":\\\"\");\n                                              }\n                                            }\n                                            if (result4 !== null) {\n                                              result5 = parse_h16();\n                                              if (result5 !== null) {\n                                                result4 = [result4, result5];\n                                              } else {\n                                                result4 = null;\n                                                pos = pos2;\n                                              }\n                                            } else {\n                                              result4 = null;\n                                              pos = pos2;\n                                            }\n                                            result4 = result4 !== null ? result4 : \"\";\n                                            if (result4 !== null) {\n                                              pos2 = pos;\n                                              if (input.charCodeAt(pos) === 58) {\n                                                result5 = \":\";\n                                                pos++;\n                                              } else {\n                                                result5 = null;\n                                                if (reportFailures === 0) {\n                                                  matchFailed(\"\\\":\\\"\");\n                                                }\n                                              }\n                                              if (result5 !== null) {\n                                                result6 = parse_h16();\n                                                if (result6 !== null) {\n                                                  result5 = [result5, result6];\n                                                } else {\n                                                  result5 = null;\n                                                  pos = pos2;\n                                                }\n                                              } else {\n                                                result5 = null;\n                                                pos = pos2;\n                                              }\n                                              result5 = result5 !== null ? result5 : \"\";\n                                              if (result5 !== null) {\n                                                pos2 = pos;\n                                                if (input.charCodeAt(pos) === 58) {\n                                                  result6 = \":\";\n                                                  pos++;\n                                                } else {\n                                                  result6 = null;\n                                                  if (reportFailures === 0) {\n                                                    matchFailed(\"\\\":\\\"\");\n                                                  }\n                                                }\n                                                if (result6 !== null) {\n                                                  result7 = parse_h16();\n                                                  if (result7 !== null) {\n                                                    result6 = [result6, result7];\n                                                  } else {\n                                                    result6 = null;\n                                                    pos = pos2;\n                                                  }\n                                                } else {\n                                                  result6 = null;\n                                                  pos = pos2;\n                                                }\n                                                result6 = result6 !== null ? result6 : \"\";\n                                                if (result6 !== null) {\n                                                  if (input.substr(pos, 2) === \"::\") {\n                                                    result7 = \"::\";\n                                                    pos += 2;\n                                                  } else {\n                                                    result7 = null;\n                                                    if (reportFailures === 0) {\n                                                      matchFailed(\"\\\"::\\\"\");\n                                                    }\n                                                  }\n                                                  if (result7 !== null) {\n                                                    result0 = [result0, result1, result2, result3, result4, result5, result6, result7];\n                                                  } else {\n                                                    result0 = null;\n                                                    pos = pos1;\n                                                  }\n                                                } else {\n                                                  result0 = null;\n                                                  pos = pos1;\n                                                }\n                                              } else {\n                                                result0 = null;\n                                                pos = pos1;\n                                              }\n                                            } else {\n                                              result0 = null;\n                                              pos = pos1;\n                                            }\n                                          } else {\n                                            result0 = null;\n                                            pos = pos1;\n                                          }\n                                        } else {\n                                          result0 = null;\n                                          pos = pos1;\n                                        }\n                                      } else {\n                                        result0 = null;\n                                        pos = pos1;\n                                      }\n                                    } else {\n                                      result0 = null;\n                                      pos = pos1;\n                                    }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.host_type = 'IPv6';\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_h16() {\n        var result0, result1, result2, result3;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_HEXDIG();\n        if (result0 !== null) {\n          result1 = parse_HEXDIG();\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result2 = parse_HEXDIG();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_HEXDIG();\n              result3 = result3 !== null ? result3 : \"\";\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_ls32() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_h16();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_h16();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        if (result0 === null) {\n          result0 = parse_IPv4address();\n        }\n        return result0;\n      }\n      function parse_IPv4address() {\n        var result0, result1, result2, result3, result4, result5, result6;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_dec_octet();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 46) {\n            result1 = \".\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_dec_octet();\n            if (result2 !== null) {\n              if (input.charCodeAt(pos) === 46) {\n                result3 = \".\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\".\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result4 = parse_dec_octet();\n                if (result4 !== null) {\n                  if (input.charCodeAt(pos) === 46) {\n                    result5 = \".\";\n                    pos++;\n                  } else {\n                    result5 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\".\\\"\");\n                    }\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_dec_octet();\n                    if (result6 !== null) {\n                      result0 = [result0, result1, result2, result3, result4, result5, result6];\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.host_type = 'IPv4';\n            return input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_dec_octet() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 2) === \"25\") {\n          result0 = \"25\";\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"25\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (/^[0-5]/.test(input.charAt(pos))) {\n            result1 = input.charAt(pos);\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[0-5]\");\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          if (input.charCodeAt(pos) === 50) {\n            result0 = \"2\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"2\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            if (/^[0-4]/.test(input.charAt(pos))) {\n              result1 = input.charAt(pos);\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[0-4]\");\n              }\n            }\n            if (result1 !== null) {\n              result2 = parse_DIGIT();\n              if (result2 !== null) {\n                result0 = [result0, result1, result2];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n          if (result0 === null) {\n            pos0 = pos;\n            if (input.charCodeAt(pos) === 49) {\n              result0 = \"1\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"1\\\"\");\n              }\n            }\n            if (result0 !== null) {\n              result1 = parse_DIGIT();\n              if (result1 !== null) {\n                result2 = parse_DIGIT();\n                if (result2 !== null) {\n                  result0 = [result0, result1, result2];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n            if (result0 === null) {\n              pos0 = pos;\n              if (/^[1-9]/.test(input.charAt(pos))) {\n                result0 = input.charAt(pos);\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"[1-9]\");\n                }\n              }\n              if (result0 !== null) {\n                result1 = parse_DIGIT();\n                if (result1 !== null) {\n                  result0 = [result0, result1];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n              if (result0 === null) {\n                result0 = parse_DIGIT();\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_port() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_DIGIT();\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result1 = parse_DIGIT();\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_DIGIT();\n              result3 = result3 !== null ? result3 : \"\";\n              if (result3 !== null) {\n                result4 = parse_DIGIT();\n                result4 = result4 !== null ? result4 : \"\";\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, port) {\n            port = parseInt(port.join(''));\n            data.port = port;\n            return port;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uri_parameters() {\n        var result0, result1, result2;\n        var pos0;\n        result0 = [];\n        pos0 = pos;\n        if (input.charCodeAt(pos) === 59) {\n          result1 = \";\";\n          pos++;\n        } else {\n          result1 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\";\\\"\");\n          }\n        }\n        if (result1 !== null) {\n          result2 = parse_uri_parameter();\n          if (result2 !== null) {\n            result1 = [result1, result2];\n          } else {\n            result1 = null;\n            pos = pos0;\n          }\n        } else {\n          result1 = null;\n          pos = pos0;\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          pos0 = pos;\n          if (input.charCodeAt(pos) === 59) {\n            result1 = \";\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\";\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_uri_parameter();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos0;\n            }\n          } else {\n            result1 = null;\n            pos = pos0;\n          }\n        }\n        return result0;\n      }\n      function parse_uri_parameter() {\n        var result0;\n        result0 = parse_transport_param();\n        if (result0 === null) {\n          result0 = parse_user_param();\n          if (result0 === null) {\n            result0 = parse_method_param();\n            if (result0 === null) {\n              result0 = parse_ttl_param();\n              if (result0 === null) {\n                result0 = parse_maddr_param();\n                if (result0 === null) {\n                  result0 = parse_lr_param();\n                  if (result0 === null) {\n                    result0 = parse_other_param();\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_transport_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 10).toLowerCase() === \"transport=\") {\n          result0 = input.substr(pos, 10);\n          pos += 10;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"transport=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (input.substr(pos, 3).toLowerCase() === \"udp\") {\n            result1 = input.substr(pos, 3);\n            pos += 3;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"udp\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.substr(pos, 3).toLowerCase() === \"tcp\") {\n              result1 = input.substr(pos, 3);\n              pos += 3;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"tcp\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.substr(pos, 4).toLowerCase() === \"sctp\") {\n                result1 = input.substr(pos, 4);\n                pos += 4;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"sctp\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.substr(pos, 3).toLowerCase() === \"tls\") {\n                  result1 = input.substr(pos, 3);\n                  pos += 3;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"tls\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  result1 = parse_token();\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, transport) {\n            if (!data.uri_params) data.uri_params = {};\n            data.uri_params['transport'] = transport.toLowerCase();\n          }(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_user_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"user=\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"user=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (input.substr(pos, 5).toLowerCase() === \"phone\") {\n            result1 = input.substr(pos, 5);\n            pos += 5;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"phone\\\"\");\n            }\n          }\n          if (result1 === null) {\n            if (input.substr(pos, 2).toLowerCase() === \"ip\") {\n              result1 = input.substr(pos, 2);\n              pos += 2;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"ip\\\"\");\n              }\n            }\n            if (result1 === null) {\n              result1 = parse_token();\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, user) {\n            if (!data.uri_params) data.uri_params = {};\n            data.uri_params['user'] = user.toLowerCase();\n          }(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_method_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 7).toLowerCase() === \"method=\") {\n          result0 = input.substr(pos, 7);\n          pos += 7;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"method=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_Method();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, method) {\n            if (!data.uri_params) data.uri_params = {};\n            data.uri_params['method'] = method;\n          }(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_ttl_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 4).toLowerCase() === \"ttl=\") {\n          result0 = input.substr(pos, 4);\n          pos += 4;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"ttl=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_ttl();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, ttl) {\n            if (!data.params) data.params = {};\n            data.params['ttl'] = ttl;\n          }(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_maddr_param() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"maddr=\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"maddr=\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_host();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, maddr) {\n            if (!data.uri_params) data.uri_params = {};\n            data.uri_params['maddr'] = maddr;\n          }(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_lr_param() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 2).toLowerCase() === \"lr\") {\n          result0 = input.substr(pos, 2);\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"lr\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 61) {\n            result1 = \"=\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            if (!data.uri_params) data.uri_params = {};\n            data.uri_params['lr'] = undefined;\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_other_param() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_pname();\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 61) {\n            result1 = \"=\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_pvalue();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, param, value) {\n            if (!data.uri_params) data.uri_params = {};\n            if (typeof value === 'undefined') {\n              value = undefined;\n            } else {\n              value = value[1];\n            }\n            data.uri_params[param.toLowerCase()] = value;\n          }(pos0, result0[0], result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_pname() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_paramchar();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_paramchar();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, pname) {\n            return pname.join('');\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_pvalue() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_paramchar();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_paramchar();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, pvalue) {\n            return pvalue.join('');\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_paramchar() {\n        var result0;\n        result0 = parse_param_unreserved();\n        if (result0 === null) {\n          result0 = parse_unreserved();\n          if (result0 === null) {\n            result0 = parse_escaped();\n          }\n        }\n        return result0;\n      }\n      function parse_param_unreserved() {\n        var result0;\n        if (input.charCodeAt(pos) === 91) {\n          result0 = \"[\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"[\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 93) {\n            result0 = \"]\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"]\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 47) {\n              result0 = \"/\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"/\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 58) {\n                result0 = \":\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\":\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 38) {\n                  result0 = \"&\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"&\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 43) {\n                    result0 = \"+\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"+\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 36) {\n                      result0 = \"$\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"$\\\"\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_headers() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1;\n        pos0 = pos;\n        if (input.charCodeAt(pos) === 63) {\n          result0 = \"?\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"?\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_header();\n          if (result1 !== null) {\n            result2 = [];\n            pos1 = pos;\n            if (input.charCodeAt(pos) === 38) {\n              result3 = \"&\";\n              pos++;\n            } else {\n              result3 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"&\\\"\");\n              }\n            }\n            if (result3 !== null) {\n              result4 = parse_header();\n              if (result4 !== null) {\n                result3 = [result3, result4];\n              } else {\n                result3 = null;\n                pos = pos1;\n              }\n            } else {\n              result3 = null;\n              pos = pos1;\n            }\n            while (result3 !== null) {\n              result2.push(result3);\n              pos1 = pos;\n              if (input.charCodeAt(pos) === 38) {\n                result3 = \"&\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"&\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result4 = parse_header();\n                if (result4 !== null) {\n                  result3 = [result3, result4];\n                } else {\n                  result3 = null;\n                  pos = pos1;\n                }\n              } else {\n                result3 = null;\n                pos = pos1;\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_header() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_hname();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 61) {\n            result1 = \"=\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"=\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_hvalue();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, hname, hvalue) {\n            hname = hname.join('').toLowerCase();\n            hvalue = hvalue.join('');\n            if (!data.uri_headers) data.uri_headers = {};\n            if (!data.uri_headers[hname]) {\n              data.uri_headers[hname] = [hvalue];\n            } else {\n              data.uri_headers[hname].push(hvalue);\n            }\n          }(pos0, result0[0], result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hname() {\n        var result0, result1;\n        result1 = parse_hnv_unreserved();\n        if (result1 === null) {\n          result1 = parse_unreserved();\n          if (result1 === null) {\n            result1 = parse_escaped();\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_hnv_unreserved();\n            if (result1 === null) {\n              result1 = parse_unreserved();\n              if (result1 === null) {\n                result1 = parse_escaped();\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        return result0;\n      }\n      function parse_hvalue() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_hnv_unreserved();\n        if (result1 === null) {\n          result1 = parse_unreserved();\n          if (result1 === null) {\n            result1 = parse_escaped();\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_hnv_unreserved();\n          if (result1 === null) {\n            result1 = parse_unreserved();\n            if (result1 === null) {\n              result1 = parse_escaped();\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_hnv_unreserved() {\n        var result0;\n        if (input.charCodeAt(pos) === 91) {\n          result0 = \"[\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"[\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.charCodeAt(pos) === 93) {\n            result0 = \"]\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"]\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 47) {\n              result0 = \"/\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"/\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 63) {\n                result0 = \"?\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"?\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 58) {\n                  result0 = \":\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\":\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 43) {\n                    result0 = \"+\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"+\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 36) {\n                      result0 = \"$\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"$\\\"\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_Request_Response() {\n        var result0;\n        result0 = parse_Status_Line();\n        if (result0 === null) {\n          result0 = parse_Request_Line();\n        }\n        return result0;\n      }\n      function parse_Request_Line() {\n        var result0, result1, result2, result3, result4;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_Method();\n        if (result0 !== null) {\n          result1 = parse_SP();\n          if (result1 !== null) {\n            result2 = parse_Request_URI();\n            if (result2 !== null) {\n              result3 = parse_SP();\n              if (result3 !== null) {\n                result4 = parse_SIP_Version();\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Request_URI() {\n        var result0;\n        result0 = parse_SIP_URI();\n        if (result0 === null) {\n          result0 = parse_absoluteURI();\n        }\n        return result0;\n      }\n      function parse_absoluteURI() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_scheme();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 58) {\n            result1 = \":\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_hier_part();\n            if (result2 === null) {\n              result2 = parse_opaque_part();\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hier_part() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_net_path();\n        if (result0 === null) {\n          result0 = parse_abs_path();\n        }\n        if (result0 !== null) {\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 63) {\n            result1 = \"?\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"?\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_query();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos1;\n            }\n          } else {\n            result1 = null;\n            pos = pos1;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_net_path() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 2) === \"//\") {\n          result0 = \"//\";\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"//\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_authority();\n          if (result1 !== null) {\n            result2 = parse_abs_path();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_abs_path() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        if (input.charCodeAt(pos) === 47) {\n          result0 = \"/\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"/\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_path_segments();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_opaque_part() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_uric_no_slash();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_uric();\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_uric();\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uric() {\n        var result0;\n        result0 = parse_reserved();\n        if (result0 === null) {\n          result0 = parse_unreserved();\n          if (result0 === null) {\n            result0 = parse_escaped();\n          }\n        }\n        return result0;\n      }\n      function parse_uric_no_slash() {\n        var result0;\n        result0 = parse_unreserved();\n        if (result0 === null) {\n          result0 = parse_escaped();\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 59) {\n              result0 = \";\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\";\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 63) {\n                result0 = \"?\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"?\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 58) {\n                  result0 = \":\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\":\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 64) {\n                    result0 = \"@\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"@\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 38) {\n                      result0 = \"&\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"&\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 61) {\n                        result0 = \"=\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"=\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 43) {\n                          result0 = \"+\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"+\\\"\");\n                          }\n                        }\n                        if (result0 === null) {\n                          if (input.charCodeAt(pos) === 36) {\n                            result0 = \"$\";\n                            pos++;\n                          } else {\n                            result0 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"$\\\"\");\n                            }\n                          }\n                          if (result0 === null) {\n                            if (input.charCodeAt(pos) === 44) {\n                              result0 = \",\";\n                              pos++;\n                            } else {\n                              result0 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\",\\\"\");\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_path_segments() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_segment();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 47) {\n            result2 = \"/\";\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"/\\\"\");\n            }\n          }\n          if (result2 !== null) {\n            result3 = parse_segment();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            if (input.charCodeAt(pos) === 47) {\n              result2 = \"/\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"/\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_segment();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_segment() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = [];\n        result1 = parse_pchar();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_pchar();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 59) {\n            result2 = \";\";\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\";\\\"\");\n            }\n          }\n          if (result2 !== null) {\n            result3 = parse_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            if (input.charCodeAt(pos) === 59) {\n              result2 = \";\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\";\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_param() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_pchar();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_pchar();\n        }\n        return result0;\n      }\n      function parse_pchar() {\n        var result0;\n        result0 = parse_unreserved();\n        if (result0 === null) {\n          result0 = parse_escaped();\n          if (result0 === null) {\n            if (input.charCodeAt(pos) === 58) {\n              result0 = \":\";\n              pos++;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\":\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.charCodeAt(pos) === 64) {\n                result0 = \"@\";\n                pos++;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"@\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.charCodeAt(pos) === 38) {\n                  result0 = \"&\";\n                  pos++;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"&\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.charCodeAt(pos) === 61) {\n                    result0 = \"=\";\n                    pos++;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"=\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.charCodeAt(pos) === 43) {\n                      result0 = \"+\";\n                      pos++;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"+\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      if (input.charCodeAt(pos) === 36) {\n                        result0 = \"$\";\n                        pos++;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"$\\\"\");\n                        }\n                      }\n                      if (result0 === null) {\n                        if (input.charCodeAt(pos) === 44) {\n                          result0 = \",\";\n                          pos++;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\",\\\"\");\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_scheme() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_ALPHA();\n        if (result0 !== null) {\n          result1 = [];\n          result2 = parse_ALPHA();\n          if (result2 === null) {\n            result2 = parse_DIGIT();\n            if (result2 === null) {\n              if (input.charCodeAt(pos) === 43) {\n                result2 = \"+\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"+\\\"\");\n                }\n              }\n              if (result2 === null) {\n                if (input.charCodeAt(pos) === 45) {\n                  result2 = \"-\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"-\\\"\");\n                  }\n                }\n                if (result2 === null) {\n                  if (input.charCodeAt(pos) === 46) {\n                    result2 = \".\";\n                    pos++;\n                  } else {\n                    result2 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\".\\\"\");\n                    }\n                  }\n                }\n              }\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            result2 = parse_ALPHA();\n            if (result2 === null) {\n              result2 = parse_DIGIT();\n              if (result2 === null) {\n                if (input.charCodeAt(pos) === 43) {\n                  result2 = \"+\";\n                  pos++;\n                } else {\n                  result2 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"+\\\"\");\n                  }\n                }\n                if (result2 === null) {\n                  if (input.charCodeAt(pos) === 45) {\n                    result2 = \"-\";\n                    pos++;\n                  } else {\n                    result2 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"-\\\"\");\n                    }\n                  }\n                  if (result2 === null) {\n                    if (input.charCodeAt(pos) === 46) {\n                      result2 = \".\";\n                      pos++;\n                    } else {\n                      result2 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\".\\\"\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.scheme = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_authority() {\n        var result0;\n        result0 = parse_srvr();\n        if (result0 === null) {\n          result0 = parse_reg_name();\n        }\n        return result0;\n      }\n      function parse_srvr() {\n        var result0, result1;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_userinfo();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 64) {\n            result1 = \"@\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"@\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result1 = parse_hostport();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        result0 = result0 !== null ? result0 : \"\";\n        return result0;\n      }\n      function parse_reg_name() {\n        var result0, result1;\n        result1 = parse_unreserved();\n        if (result1 === null) {\n          result1 = parse_escaped();\n          if (result1 === null) {\n            if (input.charCodeAt(pos) === 36) {\n              result1 = \"$\";\n              pos++;\n            } else {\n              result1 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"$\\\"\");\n              }\n            }\n            if (result1 === null) {\n              if (input.charCodeAt(pos) === 44) {\n                result1 = \",\";\n                pos++;\n              } else {\n                result1 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\",\\\"\");\n                }\n              }\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 59) {\n                  result1 = \";\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\";\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 58) {\n                    result1 = \":\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\":\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 64) {\n                      result1 = \"@\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"@\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 38) {\n                        result1 = \"&\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"&\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 61) {\n                          result1 = \"=\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"=\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 43) {\n                            result1 = \"+\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"+\\\"\");\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_unreserved();\n            if (result1 === null) {\n              result1 = parse_escaped();\n              if (result1 === null) {\n                if (input.charCodeAt(pos) === 36) {\n                  result1 = \"$\";\n                  pos++;\n                } else {\n                  result1 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"$\\\"\");\n                  }\n                }\n                if (result1 === null) {\n                  if (input.charCodeAt(pos) === 44) {\n                    result1 = \",\";\n                    pos++;\n                  } else {\n                    result1 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\",\\\"\");\n                    }\n                  }\n                  if (result1 === null) {\n                    if (input.charCodeAt(pos) === 59) {\n                      result1 = \";\";\n                      pos++;\n                    } else {\n                      result1 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\";\\\"\");\n                      }\n                    }\n                    if (result1 === null) {\n                      if (input.charCodeAt(pos) === 58) {\n                        result1 = \":\";\n                        pos++;\n                      } else {\n                        result1 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\":\\\"\");\n                        }\n                      }\n                      if (result1 === null) {\n                        if (input.charCodeAt(pos) === 64) {\n                          result1 = \"@\";\n                          pos++;\n                        } else {\n                          result1 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"@\\\"\");\n                          }\n                        }\n                        if (result1 === null) {\n                          if (input.charCodeAt(pos) === 38) {\n                            result1 = \"&\";\n                            pos++;\n                          } else {\n                            result1 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"&\\\"\");\n                            }\n                          }\n                          if (result1 === null) {\n                            if (input.charCodeAt(pos) === 61) {\n                              result1 = \"=\";\n                              pos++;\n                            } else {\n                              result1 = null;\n                              if (reportFailures === 0) {\n                                matchFailed(\"\\\"=\\\"\");\n                              }\n                            }\n                            if (result1 === null) {\n                              if (input.charCodeAt(pos) === 43) {\n                                result1 = \"+\";\n                                pos++;\n                              } else {\n                                result1 = null;\n                                if (reportFailures === 0) {\n                                  matchFailed(\"\\\"+\\\"\");\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          result0 = null;\n        }\n        return result0;\n      }\n      function parse_query() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_uric();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_uric();\n        }\n        return result0;\n      }\n      function parse_SIP_Version() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"sip\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"SIP\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 47) {\n            result1 = \"/\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"/\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result3 = parse_DIGIT();\n            if (result3 !== null) {\n              result2 = [];\n              while (result3 !== null) {\n                result2.push(result3);\n                result3 = parse_DIGIT();\n              }\n            } else {\n              result2 = null;\n            }\n            if (result2 !== null) {\n              if (input.charCodeAt(pos) === 46) {\n                result3 = \".\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\".\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result5 = parse_DIGIT();\n                if (result5 !== null) {\n                  result4 = [];\n                  while (result5 !== null) {\n                    result4.push(result5);\n                    result5 = parse_DIGIT();\n                  }\n                } else {\n                  result4 = null;\n                }\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.sip_version = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_INVITEm() {\n        var result0;\n        if (input.substr(pos, 6) === \"INVITE\") {\n          result0 = \"INVITE\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"INVITE\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_ACKm() {\n        var result0;\n        if (input.substr(pos, 3) === \"ACK\") {\n          result0 = \"ACK\";\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"ACK\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_OPTIONSm() {\n        var result0;\n        if (input.substr(pos, 7) === \"OPTIONS\") {\n          result0 = \"OPTIONS\";\n          pos += 7;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"OPTIONS\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_BYEm() {\n        var result0;\n        if (input.substr(pos, 3) === \"BYE\") {\n          result0 = \"BYE\";\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"BYE\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_CANCELm() {\n        var result0;\n        if (input.substr(pos, 6) === \"CANCEL\") {\n          result0 = \"CANCEL\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"CANCEL\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_REGISTERm() {\n        var result0;\n        if (input.substr(pos, 8) === \"REGISTER\") {\n          result0 = \"REGISTER\";\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"REGISTER\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_SUBSCRIBEm() {\n        var result0;\n        if (input.substr(pos, 9) === \"SUBSCRIBE\") {\n          result0 = \"SUBSCRIBE\";\n          pos += 9;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"SUBSCRIBE\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_NOTIFYm() {\n        var result0;\n        if (input.substr(pos, 6) === \"NOTIFY\") {\n          result0 = \"NOTIFY\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"NOTIFY\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_REFERm() {\n        var result0;\n        if (input.substr(pos, 5) === \"REFER\") {\n          result0 = \"REFER\";\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"REFER\\\"\");\n          }\n        }\n        return result0;\n      }\n      function parse_Method() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_INVITEm();\n        if (result0 === null) {\n          result0 = parse_ACKm();\n          if (result0 === null) {\n            result0 = parse_OPTIONSm();\n            if (result0 === null) {\n              result0 = parse_BYEm();\n              if (result0 === null) {\n                result0 = parse_CANCELm();\n                if (result0 === null) {\n                  result0 = parse_REGISTERm();\n                  if (result0 === null) {\n                    result0 = parse_SUBSCRIBEm();\n                    if (result0 === null) {\n                      result0 = parse_NOTIFYm();\n                      if (result0 === null) {\n                        result0 = parse_REFERm();\n                        if (result0 === null) {\n                          result0 = parse_token();\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.method = input.substring(pos, offset);\n            return data.method;\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Status_Line() {\n        var result0, result1, result2, result3, result4;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_SIP_Version();\n        if (result0 !== null) {\n          result1 = parse_SP();\n          if (result1 !== null) {\n            result2 = parse_Status_Code();\n            if (result2 !== null) {\n              result3 = parse_SP();\n              if (result3 !== null) {\n                result4 = parse_Reason_Phrase();\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Status_Code() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_extension_code();\n        if (result0 !== null) {\n          result0 = function (offset, status_code) {\n            data.status_code = parseInt(status_code.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_extension_code() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_DIGIT();\n        if (result0 !== null) {\n          result1 = parse_DIGIT();\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Reason_Phrase() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result0 = [];\n        result1 = parse_reserved();\n        if (result1 === null) {\n          result1 = parse_unreserved();\n          if (result1 === null) {\n            result1 = parse_escaped();\n            if (result1 === null) {\n              result1 = parse_UTF8_NONASCII();\n              if (result1 === null) {\n                result1 = parse_UTF8_CONT();\n                if (result1 === null) {\n                  result1 = parse_SP();\n                  if (result1 === null) {\n                    result1 = parse_HTAB();\n                  }\n                }\n              }\n            }\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_reserved();\n          if (result1 === null) {\n            result1 = parse_unreserved();\n            if (result1 === null) {\n              result1 = parse_escaped();\n              if (result1 === null) {\n                result1 = parse_UTF8_NONASCII();\n                if (result1 === null) {\n                  result1 = parse_UTF8_CONT();\n                  if (result1 === null) {\n                    result1 = parse_SP();\n                    if (result1 === null) {\n                      result1 = parse_HTAB();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.reason_phrase = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Allow_Events() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_event_type();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_event_type();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_event_type();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Call_ID() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_word();\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 64) {\n            result1 = \"@\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"@\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_word();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Contact() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        result0 = parse_STAR();\n        if (result0 === null) {\n          pos1 = pos;\n          result0 = parse_contact_param();\n          if (result0 !== null) {\n            result1 = [];\n            pos2 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_contact_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n            while (result2 !== null) {\n              result1.push(result2);\n              pos2 = pos;\n              result2 = parse_COMMA();\n              if (result2 !== null) {\n                result3 = parse_contact_param();\n                if (result3 !== null) {\n                  result2 = [result2, result3];\n                } else {\n                  result2 = null;\n                  pos = pos2;\n                }\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            }\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var idx, length;\n            length = data.multi_header.length;\n            for (idx = 0; idx < length; idx++) {\n              if (data.multi_header[idx].parsed === null) {\n                data = null;\n                break;\n              }\n            }\n            if (data !== null) {\n              data = data.multi_header;\n            } else {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_contact_param() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SIP_URI_noparams();\n        if (result0 === null) {\n          result0 = parse_name_addr();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_contact_params();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_contact_params();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var header;\n            if (!data.multi_header) data.multi_header = [];\n            try {\n              header = new NameAddrHeader(data.uri, data.display_name, data.params);\n              delete data.uri;\n              delete data.display_name;\n              delete data.params;\n            } catch (e) {\n              header = null;\n            }\n            data.multi_header.push({ 'possition': pos,\n              'offset': offset,\n              'parsed': header\n            });\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_name_addr() {\n        var result0, result1, result2, result3;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_display_name();\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result1 = parse_LAQUOT();\n          if (result1 !== null) {\n            result2 = parse_SIP_URI();\n            if (result2 !== null) {\n              result3 = parse_RAQUOT();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_display_name() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_LWS();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_LWS();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 === null) {\n          result0 = parse_quoted_string();\n        }\n        if (result0 !== null) {\n          result0 = function (offset, display_name) {\n            display_name = input.substring(pos, offset).trim();\n            if (display_name[0] === '\\\"') {\n              display_name = display_name.substring(1, display_name.length - 1);\n            }\n            data.display_name = display_name;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_contact_params() {\n        var result0;\n        result0 = parse_c_p_q();\n        if (result0 === null) {\n          result0 = parse_c_p_expires();\n          if (result0 === null) {\n            result0 = parse_generic_param();\n          }\n        }\n        return result0;\n      }\n      function parse_c_p_q() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 1).toLowerCase() === \"q\") {\n          result0 = input.substr(pos, 1);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"q\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_qvalue();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, q) {\n            if (!data.params) data.params = {};\n            data.params['q'] = q;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_c_p_expires() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 7).toLowerCase() === \"expires\") {\n          result0 = input.substr(pos, 7);\n          pos += 7;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"expires\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_delta_seconds();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, expires) {\n            if (!data.params) data.params = {};\n            data.params['expires'] = expires;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_delta_seconds() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_DIGIT();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_DIGIT();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, delta_seconds) {\n            return parseInt(delta_seconds.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_qvalue() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 48) {\n          result0 = \"0\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"0\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 46) {\n            result1 = \".\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_DIGIT();\n              result3 = result3 !== null ? result3 : \"\";\n              if (result3 !== null) {\n                result4 = parse_DIGIT();\n                result4 = result4 !== null ? result4 : \"\";\n                if (result4 !== null) {\n                  result1 = [result1, result2, result3, result4];\n                } else {\n                  result1 = null;\n                  pos = pos2;\n                }\n              } else {\n                result1 = null;\n                pos = pos2;\n              }\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            return parseFloat(input.substring(pos, offset));\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_generic_param() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          pos2 = pos;\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_gen_value();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, param, value) {\n            if (!data.params) data.params = {};\n            if (typeof value === 'undefined') {\n              value = undefined;\n            } else {\n              value = value[1];\n            }\n            data.params[param.toLowerCase()] = value;\n          }(pos0, result0[0], result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_gen_value() {\n        var result0;\n        result0 = parse_token();\n        if (result0 === null) {\n          result0 = parse_host();\n          if (result0 === null) {\n            result0 = parse_quoted_string();\n          }\n        }\n        return result0;\n      }\n      function parse_Content_Disposition() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_disp_type();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_disp_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_disp_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_disp_type() {\n        var result0;\n        if (input.substr(pos, 6).toLowerCase() === \"render\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"render\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 7).toLowerCase() === \"session\") {\n            result0 = input.substr(pos, 7);\n            pos += 7;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"session\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 4).toLowerCase() === \"icon\") {\n              result0 = input.substr(pos, 4);\n              pos += 4;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"icon\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 5).toLowerCase() === \"alert\") {\n                result0 = input.substr(pos, 5);\n                pos += 5;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"alert\\\"\");\n                }\n              }\n              if (result0 === null) {\n                result0 = parse_token();\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_disp_param() {\n        var result0;\n        result0 = parse_handling_param();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_handling_param() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 8).toLowerCase() === \"handling\") {\n          result0 = input.substr(pos, 8);\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"handling\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            if (input.substr(pos, 8).toLowerCase() === \"optional\") {\n              result2 = input.substr(pos, 8);\n              pos += 8;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"optional\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.substr(pos, 8).toLowerCase() === \"required\") {\n                result2 = input.substr(pos, 8);\n                pos += 8;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"required\\\"\");\n                }\n              }\n              if (result2 === null) {\n                result2 = parse_token();\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Content_Encoding() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Content_Length() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_DIGIT();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_DIGIT();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, length) {\n            data = parseInt(length.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Content_Type() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_media_type();\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_media_type() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_m_type();\n        if (result0 !== null) {\n          result1 = parse_SLASH();\n          if (result1 !== null) {\n            result2 = parse_m_subtype();\n            if (result2 !== null) {\n              result3 = [];\n              pos1 = pos;\n              result4 = parse_SEMI();\n              if (result4 !== null) {\n                result5 = parse_m_parameter();\n                if (result5 !== null) {\n                  result4 = [result4, result5];\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              } else {\n                result4 = null;\n                pos = pos1;\n              }\n              while (result4 !== null) {\n                result3.push(result4);\n                pos1 = pos;\n                result4 = parse_SEMI();\n                if (result4 !== null) {\n                  result5 = parse_m_parameter();\n                  if (result5 !== null) {\n                    result4 = [result4, result5];\n                  } else {\n                    result4 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              }\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_m_type() {\n        var result0;\n        result0 = parse_discrete_type();\n        if (result0 === null) {\n          result0 = parse_composite_type();\n        }\n        return result0;\n      }\n      function parse_discrete_type() {\n        var result0;\n        if (input.substr(pos, 4).toLowerCase() === \"text\") {\n          result0 = input.substr(pos, 4);\n          pos += 4;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"text\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 5).toLowerCase() === \"image\") {\n            result0 = input.substr(pos, 5);\n            pos += 5;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"image\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 5).toLowerCase() === \"audio\") {\n              result0 = input.substr(pos, 5);\n              pos += 5;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"audio\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 5).toLowerCase() === \"video\") {\n                result0 = input.substr(pos, 5);\n                pos += 5;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"video\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.substr(pos, 11).toLowerCase() === \"application\") {\n                  result0 = input.substr(pos, 11);\n                  pos += 11;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"application\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  result0 = parse_extension_token();\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_composite_type() {\n        var result0;\n        if (input.substr(pos, 7).toLowerCase() === \"message\") {\n          result0 = input.substr(pos, 7);\n          pos += 7;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"message\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 9).toLowerCase() === \"multipart\") {\n            result0 = input.substr(pos, 9);\n            pos += 9;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"multipart\\\"\");\n            }\n          }\n          if (result0 === null) {\n            result0 = parse_extension_token();\n          }\n        }\n        return result0;\n      }\n      function parse_extension_token() {\n        var result0;\n        result0 = parse_token();\n        if (result0 === null) {\n          result0 = parse_x_token();\n        }\n        return result0;\n      }\n      function parse_x_token() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 2).toLowerCase() === \"x-\") {\n          result0 = input.substr(pos, 2);\n          pos += 2;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"x-\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_token();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_m_subtype() {\n        var result0;\n        result0 = parse_extension_token();\n        if (result0 === null) {\n          result0 = parse_token();\n        }\n        return result0;\n      }\n      function parse_m_parameter() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_m_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_m_value() {\n        var result0;\n        result0 = parse_token();\n        if (result0 === null) {\n          result0 = parse_quoted_string();\n        }\n        return result0;\n      }\n      function parse_CSeq() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_CSeq_value();\n        if (result0 !== null) {\n          result1 = parse_LWS();\n          if (result1 !== null) {\n            result2 = parse_Method();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_CSeq_value() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_DIGIT();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_DIGIT();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, cseq_value) {\n            data.value = parseInt(cseq_value.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Expires() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_delta_seconds();\n        if (result0 !== null) {\n          result0 = function (offset, expires) {\n            data = expires;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Event() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_event_type();\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_generic_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_generic_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, event_type) {\n            data.event = event_type.join('').toLowerCase();\n          }(pos0, result0[0]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_event_type() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token_nodot();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 46) {\n            result2 = \".\";\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\".\\\"\");\n            }\n          }\n          if (result2 !== null) {\n            result3 = parse_token_nodot();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            if (input.charCodeAt(pos) === 46) {\n              result2 = \".\";\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\".\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result3 = parse_token_nodot();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_From() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SIP_URI_noparams();\n        if (result0 === null) {\n          result0 = parse_name_addr();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_from_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_from_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var tag = data.tag;\n            try {\n              data = new NameAddrHeader(data.uri, data.display_name, data.params);\n              if (tag) {\n                data.setParam('tag', tag);\n              }\n            } catch (e) {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_from_param() {\n        var result0;\n        result0 = parse_tag_param();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_tag_param() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"tag\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"tag\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, tag) {\n            data.tag = tag;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Max_Forwards() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result1 = parse_DIGIT();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_DIGIT();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, forwards) {\n            data = parseInt(forwards.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Min_Expires() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_delta_seconds();\n        if (result0 !== null) {\n          result0 = function (offset, min_expires) {\n            data = min_expires;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Name_Addr_Header() {\n        var result0, result1, result2, result3, result4, result5, result6;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = [];\n        result1 = parse_display_name();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_display_name();\n        }\n        if (result0 !== null) {\n          result1 = parse_LAQUOT();\n          if (result1 !== null) {\n            result2 = parse_SIP_URI();\n            if (result2 !== null) {\n              result3 = parse_RAQUOT();\n              if (result3 !== null) {\n                result4 = [];\n                pos2 = pos;\n                result5 = parse_SEMI();\n                if (result5 !== null) {\n                  result6 = parse_generic_param();\n                  if (result6 !== null) {\n                    result5 = [result5, result6];\n                  } else {\n                    result5 = null;\n                    pos = pos2;\n                  }\n                } else {\n                  result5 = null;\n                  pos = pos2;\n                }\n                while (result5 !== null) {\n                  result4.push(result5);\n                  pos2 = pos;\n                  result5 = parse_SEMI();\n                  if (result5 !== null) {\n                    result6 = parse_generic_param();\n                    if (result6 !== null) {\n                      result5 = [result5, result6];\n                    } else {\n                      result5 = null;\n                      pos = pos2;\n                    }\n                  } else {\n                    result5 = null;\n                    pos = pos2;\n                  }\n                }\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            try {\n              data = new NameAddrHeader(data.uri, data.display_name, data.params);\n            } catch (e) {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Proxy_Authenticate() {\n        var result0;\n        result0 = parse_challenge();\n        return result0;\n      }\n      function parse_challenge() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"digest\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"Digest\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_LWS();\n          if (result1 !== null) {\n            result2 = parse_digest_cln();\n            if (result2 !== null) {\n              result3 = [];\n              pos1 = pos;\n              result4 = parse_COMMA();\n              if (result4 !== null) {\n                result5 = parse_digest_cln();\n                if (result5 !== null) {\n                  result4 = [result4, result5];\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              } else {\n                result4 = null;\n                pos = pos1;\n              }\n              while (result4 !== null) {\n                result3.push(result4);\n                pos1 = pos;\n                result4 = parse_COMMA();\n                if (result4 !== null) {\n                  result5 = parse_digest_cln();\n                  if (result5 !== null) {\n                    result4 = [result4, result5];\n                  } else {\n                    result4 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              }\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        if (result0 === null) {\n          result0 = parse_other_challenge();\n        }\n        return result0;\n      }\n      function parse_other_challenge() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = parse_LWS();\n          if (result1 !== null) {\n            result2 = parse_auth_param();\n            if (result2 !== null) {\n              result3 = [];\n              pos1 = pos;\n              result4 = parse_COMMA();\n              if (result4 !== null) {\n                result5 = parse_auth_param();\n                if (result5 !== null) {\n                  result4 = [result4, result5];\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              } else {\n                result4 = null;\n                pos = pos1;\n              }\n              while (result4 !== null) {\n                result3.push(result4);\n                pos1 = pos;\n                result4 = parse_COMMA();\n                if (result4 !== null) {\n                  result5 = parse_auth_param();\n                  if (result5 !== null) {\n                    result4 = [result4, result5];\n                  } else {\n                    result4 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              }\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_auth_param() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 === null) {\n              result2 = parse_quoted_string();\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_digest_cln() {\n        var result0;\n        result0 = parse_realm();\n        if (result0 === null) {\n          result0 = parse_domain();\n          if (result0 === null) {\n            result0 = parse_nonce();\n            if (result0 === null) {\n              result0 = parse_opaque();\n              if (result0 === null) {\n                result0 = parse_stale();\n                if (result0 === null) {\n                  result0 = parse_algorithm();\n                  if (result0 === null) {\n                    result0 = parse_qop_options();\n                    if (result0 === null) {\n                      result0 = parse_auth_param();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_realm() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"realm\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"realm\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_realm_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_realm_value() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_quoted_string_clean();\n        if (result0 !== null) {\n          result0 = function (offset, realm) {\n            data.realm = realm;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_domain() {\n        var result0, result1, result2, result3, result4, result5, result6;\n        var pos0, pos1;\n        pos0 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"domain\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"domain\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_LDQUOT();\n            if (result2 !== null) {\n              result3 = parse_URI();\n              if (result3 !== null) {\n                result4 = [];\n                pos1 = pos;\n                result6 = parse_SP();\n                if (result6 !== null) {\n                  result5 = [];\n                  while (result6 !== null) {\n                    result5.push(result6);\n                    result6 = parse_SP();\n                  }\n                } else {\n                  result5 = null;\n                }\n                if (result5 !== null) {\n                  result6 = parse_URI();\n                  if (result6 !== null) {\n                    result5 = [result5, result6];\n                  } else {\n                    result5 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result5 = null;\n                  pos = pos1;\n                }\n                while (result5 !== null) {\n                  result4.push(result5);\n                  pos1 = pos;\n                  result6 = parse_SP();\n                  if (result6 !== null) {\n                    result5 = [];\n                    while (result6 !== null) {\n                      result5.push(result6);\n                      result6 = parse_SP();\n                    }\n                  } else {\n                    result5 = null;\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_URI();\n                    if (result6 !== null) {\n                      result5 = [result5, result6];\n                    } else {\n                      result5 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result5 = null;\n                    pos = pos1;\n                  }\n                }\n                if (result4 !== null) {\n                  result5 = parse_RDQUOT();\n                  if (result5 !== null) {\n                    result0 = [result0, result1, result2, result3, result4, result5];\n                  } else {\n                    result0 = null;\n                    pos = pos0;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_URI() {\n        var result0;\n        result0 = parse_absoluteURI();\n        if (result0 === null) {\n          result0 = parse_abs_path();\n        }\n        return result0;\n      }\n      function parse_nonce() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"nonce\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"nonce\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_nonce_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_nonce_value() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_quoted_string_clean();\n        if (result0 !== null) {\n          result0 = function (offset, nonce) {\n            data.nonce = nonce;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_opaque() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"opaque\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"opaque\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_quoted_string_clean();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, opaque) {\n            data.opaque = opaque;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_stale() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"stale\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"stale\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            pos1 = pos;\n            if (input.substr(pos, 4).toLowerCase() === \"true\") {\n              result2 = input.substr(pos, 4);\n              pos += 4;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"true\\\"\");\n              }\n            }\n            if (result2 !== null) {\n              result2 = function (offset) {\n                data.stale = true;\n              }(pos1);\n            }\n            if (result2 === null) {\n              pos = pos1;\n            }\n            if (result2 === null) {\n              pos1 = pos;\n              if (input.substr(pos, 5).toLowerCase() === \"false\") {\n                result2 = input.substr(pos, 5);\n                pos += 5;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"false\\\"\");\n                }\n              }\n              if (result2 !== null) {\n                result2 = function (offset) {\n                  data.stale = false;\n                }(pos1);\n              }\n              if (result2 === null) {\n                pos = pos1;\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_algorithm() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 9).toLowerCase() === \"algorithm\") {\n          result0 = input.substr(pos, 9);\n          pos += 9;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"algorithm\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            if (input.substr(pos, 3).toLowerCase() === \"md5\") {\n              result2 = input.substr(pos, 3);\n              pos += 3;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"MD5\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.substr(pos, 8).toLowerCase() === \"md5-sess\") {\n                result2 = input.substr(pos, 8);\n                pos += 8;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"MD5-sess\\\"\");\n                }\n              }\n              if (result2 === null) {\n                result2 = parse_token();\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, algorithm) {\n            data.algorithm = algorithm.toUpperCase();\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_qop_options() {\n        var result0, result1, result2, result3, result4, result5, result6;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"qop\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"qop\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_LDQUOT();\n            if (result2 !== null) {\n              pos1 = pos;\n              result3 = parse_qop_value();\n              if (result3 !== null) {\n                result4 = [];\n                pos2 = pos;\n                if (input.charCodeAt(pos) === 44) {\n                  result5 = \",\";\n                  pos++;\n                } else {\n                  result5 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\",\\\"\");\n                  }\n                }\n                if (result5 !== null) {\n                  result6 = parse_qop_value();\n                  if (result6 !== null) {\n                    result5 = [result5, result6];\n                  } else {\n                    result5 = null;\n                    pos = pos2;\n                  }\n                } else {\n                  result5 = null;\n                  pos = pos2;\n                }\n                while (result5 !== null) {\n                  result4.push(result5);\n                  pos2 = pos;\n                  if (input.charCodeAt(pos) === 44) {\n                    result5 = \",\";\n                    pos++;\n                  } else {\n                    result5 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\",\\\"\");\n                    }\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_qop_value();\n                    if (result6 !== null) {\n                      result5 = [result5, result6];\n                    } else {\n                      result5 = null;\n                      pos = pos2;\n                    }\n                  } else {\n                    result5 = null;\n                    pos = pos2;\n                  }\n                }\n                if (result4 !== null) {\n                  result3 = [result3, result4];\n                } else {\n                  result3 = null;\n                  pos = pos1;\n                }\n              } else {\n                result3 = null;\n                pos = pos1;\n              }\n              if (result3 !== null) {\n                result4 = parse_RDQUOT();\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_qop_value() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 8).toLowerCase() === \"auth-int\") {\n          result0 = input.substr(pos, 8);\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"auth-int\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 4).toLowerCase() === \"auth\") {\n            result0 = input.substr(pos, 4);\n            pos += 4;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"auth\\\"\");\n            }\n          }\n          if (result0 === null) {\n            result0 = parse_token();\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset, qop_value) {\n            data.qop || (data.qop = []);\n            data.qop.push(qop_value.toLowerCase());\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Proxy_Require() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Record_Route() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_rec_route();\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_rec_route();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_rec_route();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var idx, length;\n            length = data.multi_header.length;\n            for (idx = 0; idx < length; idx++) {\n              if (data.multi_header[idx].parsed === null) {\n                data = null;\n                break;\n              }\n            }\n            if (data !== null) {\n              data = data.multi_header;\n            } else {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_rec_route() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_name_addr();\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_generic_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_generic_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var header;\n            if (!data.multi_header) data.multi_header = [];\n            try {\n              header = new NameAddrHeader(data.uri, data.display_name, data.params);\n              delete data.uri;\n              delete data.display_name;\n              delete data.params;\n            } catch (e) {\n              header = null;\n            }\n            data.multi_header.push({ 'possition': pos,\n              'offset': offset,\n              'parsed': header\n            });\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Reason() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"sip\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"SIP\\\"\");\n          }\n        }\n        if (result0 === null) {\n          result0 = parse_token();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_reason_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_reason_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, protocol) {\n            data.protocol = protocol.toLowerCase();\n            if (!data.params) data.params = {};\n            if (data.params.text && data.params.text[0] === '\"') {\n              var text = data.params.text;\n              data.text = text.substring(1, text.length - 1);\n              delete data.params.text;\n            }\n          }(pos0, result0[0]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_reason_param() {\n        var result0;\n        result0 = parse_reason_cause();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_reason_cause() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"cause\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"cause\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result3 = parse_DIGIT();\n            if (result3 !== null) {\n              result2 = [];\n              while (result3 !== null) {\n                result2.push(result3);\n                result3 = parse_DIGIT();\n              }\n            } else {\n              result2 = null;\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, cause) {\n            data.cause = parseInt(cause.join(''));\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Require() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Route() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_route_param();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_route_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_route_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_route_param() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_name_addr();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_generic_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_generic_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Subscription_State() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_substate_value();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_subexp_params();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_subexp_params();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_substate_value() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"active\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"active\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 7).toLowerCase() === \"pending\") {\n            result0 = input.substr(pos, 7);\n            pos += 7;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"pending\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 10).toLowerCase() === \"terminated\") {\n              result0 = input.substr(pos, 10);\n              pos += 10;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"terminated\\\"\");\n              }\n            }\n            if (result0 === null) {\n              result0 = parse_token();\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.state = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_subexp_params() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"reason\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"reason\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_event_reason_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, reason) {\n            if (typeof reason !== 'undefined') data.reason = reason;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          pos1 = pos;\n          if (input.substr(pos, 7).toLowerCase() === \"expires\") {\n            result0 = input.substr(pos, 7);\n            pos += 7;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"expires\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            result1 = parse_EQUAL();\n            if (result1 !== null) {\n              result2 = parse_delta_seconds();\n              if (result2 !== null) {\n                result0 = [result0, result1, result2];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = function (offset, expires) {\n              if (typeof expires !== 'undefined') data.expires = expires;\n            }(pos0, result0[2]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          if (result0 === null) {\n            pos0 = pos;\n            pos1 = pos;\n            if (input.substr(pos, 11).toLowerCase() === \"retry_after\") {\n              result0 = input.substr(pos, 11);\n              pos += 11;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"retry_after\\\"\");\n              }\n            }\n            if (result0 !== null) {\n              result1 = parse_EQUAL();\n              if (result1 !== null) {\n                result2 = parse_delta_seconds();\n                if (result2 !== null) {\n                  result0 = [result0, result1, result2];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n            if (result0 !== null) {\n              result0 = function (offset, retry_after) {\n                if (typeof retry_after !== 'undefined') data.retry_after = retry_after;\n              }(pos0, result0[2]);\n            }\n            if (result0 === null) {\n              pos = pos0;\n            }\n            if (result0 === null) {\n              result0 = parse_generic_param();\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_event_reason_value() {\n        var result0;\n        if (input.substr(pos, 11).toLowerCase() === \"deactivated\") {\n          result0 = input.substr(pos, 11);\n          pos += 11;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"deactivated\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 9).toLowerCase() === \"probation\") {\n            result0 = input.substr(pos, 9);\n            pos += 9;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"probation\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 8).toLowerCase() === \"rejected\") {\n              result0 = input.substr(pos, 8);\n              pos += 8;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"rejected\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 7).toLowerCase() === \"timeout\") {\n                result0 = input.substr(pos, 7);\n                pos += 7;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"timeout\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.substr(pos, 6).toLowerCase() === \"giveup\") {\n                  result0 = input.substr(pos, 6);\n                  pos += 6;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"giveup\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.substr(pos, 10).toLowerCase() === \"noresource\") {\n                    result0 = input.substr(pos, 10);\n                    pos += 10;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"noresource\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.substr(pos, 9).toLowerCase() === \"invariant\") {\n                      result0 = input.substr(pos, 9);\n                      pos += 9;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"invariant\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      result0 = parse_token();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_Subject() {\n        var result0;\n        result0 = parse_TEXT_UTF8_TRIM();\n        result0 = result0 !== null ? result0 : \"\";\n        return result0;\n      }\n      function parse_Supported() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_token();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_token();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        result0 = result0 !== null ? result0 : \"\";\n        return result0;\n      }\n      function parse_To() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SIP_URI_noparams();\n        if (result0 === null) {\n          result0 = parse_name_addr();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_to_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_to_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            var tag = data.tag;\n            try {\n              data = new NameAddrHeader(data.uri, data.display_name, data.params);\n              if (tag) {\n                data.setParam('tag', tag);\n              }\n            } catch (e) {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_to_param() {\n        var result0;\n        result0 = parse_tag_param();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_Via() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_via_param();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_COMMA();\n          if (result2 !== null) {\n            result3 = parse_via_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_COMMA();\n            if (result2 !== null) {\n              result3 = parse_via_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_param() {\n        var result0, result1, result2, result3, result4, result5;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_sent_protocol();\n        if (result0 !== null) {\n          result1 = parse_LWS();\n          if (result1 !== null) {\n            result2 = parse_sent_by();\n            if (result2 !== null) {\n              result3 = [];\n              pos1 = pos;\n              result4 = parse_SEMI();\n              if (result4 !== null) {\n                result5 = parse_via_params();\n                if (result5 !== null) {\n                  result4 = [result4, result5];\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              } else {\n                result4 = null;\n                pos = pos1;\n              }\n              while (result4 !== null) {\n                result3.push(result4);\n                pos1 = pos;\n                result4 = parse_SEMI();\n                if (result4 !== null) {\n                  result5 = parse_via_params();\n                  if (result5 !== null) {\n                    result4 = [result4, result5];\n                  } else {\n                    result4 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result4 = null;\n                  pos = pos1;\n                }\n              }\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_params() {\n        var result0;\n        result0 = parse_via_ttl();\n        if (result0 === null) {\n          result0 = parse_via_maddr();\n          if (result0 === null) {\n            result0 = parse_via_received();\n            if (result0 === null) {\n              result0 = parse_via_branch();\n              if (result0 === null) {\n                result0 = parse_response_port();\n                if (result0 === null) {\n                  result0 = parse_generic_param();\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_via_ttl() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"ttl\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"ttl\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_ttl();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_ttl_value) {\n            data.ttl = via_ttl_value;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_maddr() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"maddr\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"maddr\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_host();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_maddr) {\n            data.maddr = via_maddr;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_received() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 8).toLowerCase() === \"received\") {\n          result0 = input.substr(pos, 8);\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"received\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_IPv4address();\n            if (result2 === null) {\n              result2 = parse_IPv6address();\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_received) {\n            data.received = via_received;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_branch() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6).toLowerCase() === \"branch\") {\n          result0 = input.substr(pos, 6);\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"branch\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_branch) {\n            data.branch = via_branch;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_response_port() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5).toLowerCase() === \"rport\") {\n          result0 = input.substr(pos, 5);\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"rport\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          pos2 = pos;\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = [];\n            result3 = parse_DIGIT();\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_DIGIT();\n            }\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            if (typeof response_port !== 'undefined') data.rport = response_port.join('');\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_sent_protocol() {\n        var result0, result1, result2, result3, result4;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_protocol_name();\n        if (result0 !== null) {\n          result1 = parse_SLASH();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result3 = parse_SLASH();\n              if (result3 !== null) {\n                result4 = parse_transport();\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos0;\n                }\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_protocol_name() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"sip\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"SIP\\\"\");\n          }\n        }\n        if (result0 === null) {\n          result0 = parse_token();\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_protocol) {\n            data.protocol = via_protocol;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_transport() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 3).toLowerCase() === \"udp\") {\n          result0 = input.substr(pos, 3);\n          pos += 3;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"UDP\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 3).toLowerCase() === \"tcp\") {\n            result0 = input.substr(pos, 3);\n            pos += 3;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"TCP\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 3).toLowerCase() === \"tls\") {\n              result0 = input.substr(pos, 3);\n              pos += 3;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"TLS\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 4).toLowerCase() === \"sctp\") {\n                result0 = input.substr(pos, 4);\n                pos += 4;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"SCTP\\\"\");\n                }\n              }\n              if (result0 === null) {\n                result0 = parse_token();\n              }\n            }\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_transport) {\n            data.transport = via_transport;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_sent_by() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_via_host();\n        if (result0 !== null) {\n          pos1 = pos;\n          result1 = parse_COLON();\n          if (result1 !== null) {\n            result2 = parse_via_port();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos1;\n            }\n          } else {\n            result1 = null;\n            pos = pos1;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_host() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_IPv4address();\n        if (result0 === null) {\n          result0 = parse_IPv6reference();\n          if (result0 === null) {\n            result0 = parse_hostname();\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.host = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_via_port() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_DIGIT();\n        result0 = result0 !== null ? result0 : \"\";\n        if (result0 !== null) {\n          result1 = parse_DIGIT();\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result3 = parse_DIGIT();\n              result3 = result3 !== null ? result3 : \"\";\n              if (result3 !== null) {\n                result4 = parse_DIGIT();\n                result4 = result4 !== null ? result4 : \"\";\n                if (result4 !== null) {\n                  result0 = [result0, result1, result2, result3, result4];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, via_sent_by_port) {\n            data.port = parseInt(via_sent_by_port.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_ttl() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_DIGIT();\n        if (result0 !== null) {\n          result1 = parse_DIGIT();\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result2 = parse_DIGIT();\n            result2 = result2 !== null ? result2 : \"\";\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, ttl) {\n            return parseInt(ttl.join(''));\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_WWW_Authenticate() {\n        var result0;\n        result0 = parse_challenge();\n        return result0;\n      }\n      function parse_Session_Expires() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_s_e_expires();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_s_e_params();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_s_e_params();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_s_e_expires() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_delta_seconds();\n        if (result0 !== null) {\n          result0 = function (offset, expires) {\n            data.expires = expires;\n          }(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_s_e_params() {\n        var result0;\n        result0 = parse_s_e_refresher();\n        if (result0 === null) {\n          result0 = parse_generic_param();\n        }\n        return result0;\n      }\n      function parse_s_e_refresher() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 9).toLowerCase() === \"refresher\") {\n          result0 = input.substr(pos, 9);\n          pos += 9;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"refresher\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            if (input.substr(pos, 3).toLowerCase() === \"uac\") {\n              result2 = input.substr(pos, 3);\n              pos += 3;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"uac\\\"\");\n              }\n            }\n            if (result2 === null) {\n              if (input.substr(pos, 3).toLowerCase() === \"uas\") {\n                result2 = input.substr(pos, 3);\n                pos += 3;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"uas\\\"\");\n                }\n              }\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, s_e_refresher_value) {\n            data.refresher = s_e_refresher_value.toLowerCase();\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_extension_header() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_token();\n        if (result0 !== null) {\n          result1 = parse_HCOLON();\n          if (result1 !== null) {\n            result2 = parse_header_value();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_header_value() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_TEXT_UTF8char();\n        if (result1 === null) {\n          result1 = parse_UTF8_CONT();\n          if (result1 === null) {\n            result1 = parse_LWS();\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_TEXT_UTF8char();\n          if (result1 === null) {\n            result1 = parse_UTF8_CONT();\n            if (result1 === null) {\n              result1 = parse_LWS();\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_message_body() {\n        var result0, result1;\n        result0 = [];\n        result1 = parse_OCTET();\n        while (result1 !== null) {\n          result0.push(result1);\n          result1 = parse_OCTET();\n        }\n        return result0;\n      }\n      function parse_uuid_URI() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 5) === \"uuid:\") {\n          result0 = \"uuid:\";\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"uuid:\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_uuid();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_uuid() {\n        var result0, result1, result2, result3, result4, result5, result6, result7, result8;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_hex8();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 45) {\n            result1 = \"-\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"-\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_hex4();\n            if (result2 !== null) {\n              if (input.charCodeAt(pos) === 45) {\n                result3 = \"-\";\n                pos++;\n              } else {\n                result3 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"-\\\"\");\n                }\n              }\n              if (result3 !== null) {\n                result4 = parse_hex4();\n                if (result4 !== null) {\n                  if (input.charCodeAt(pos) === 45) {\n                    result5 = \"-\";\n                    pos++;\n                  } else {\n                    result5 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"-\\\"\");\n                    }\n                  }\n                  if (result5 !== null) {\n                    result6 = parse_hex4();\n                    if (result6 !== null) {\n                      if (input.charCodeAt(pos) === 45) {\n                        result7 = \"-\";\n                        pos++;\n                      } else {\n                        result7 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"-\\\"\");\n                        }\n                      }\n                      if (result7 !== null) {\n                        result8 = parse_hex12();\n                        if (result8 !== null) {\n                          result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];\n                        } else {\n                          result0 = null;\n                          pos = pos1;\n                        }\n                      } else {\n                        result0 = null;\n                        pos = pos1;\n                      }\n                    } else {\n                      result0 = null;\n                      pos = pos1;\n                    }\n                  } else {\n                    result0 = null;\n                    pos = pos1;\n                  }\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, uuid) {\n            data = input.substring(pos + 5, offset);\n          }(pos0, result0[0]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hex4() {\n        var result0, result1, result2, result3;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_HEXDIG();\n        if (result0 !== null) {\n          result1 = parse_HEXDIG();\n          if (result1 !== null) {\n            result2 = parse_HEXDIG();\n            if (result2 !== null) {\n              result3 = parse_HEXDIG();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos0;\n              }\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hex8() {\n        var result0, result1;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_hex4();\n        if (result0 !== null) {\n          result1 = parse_hex4();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_hex12() {\n        var result0, result1, result2;\n        var pos0;\n        pos0 = pos;\n        result0 = parse_hex4();\n        if (result0 !== null) {\n          result1 = parse_hex4();\n          if (result1 !== null) {\n            result2 = parse_hex4();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos0;\n            }\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Refer_To() {\n        var result0, result1, result2, result3;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_SIP_URI_noparams();\n        if (result0 === null) {\n          result0 = parse_name_addr();\n        }\n        if (result0 !== null) {\n          result1 = [];\n          pos2 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_generic_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          } else {\n            result2 = null;\n            pos = pos2;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos2 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_generic_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos2;\n              }\n            } else {\n              result2 = null;\n              pos = pos2;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            try {\n              data = new NameAddrHeader(data.uri, data.display_name, data.params);\n            } catch (e) {\n              data = -1;\n            }\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_Replaces() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        pos0 = pos;\n        result0 = parse_call_id();\n        if (result0 !== null) {\n          result1 = [];\n          pos1 = pos;\n          result2 = parse_SEMI();\n          if (result2 !== null) {\n            result3 = parse_replaces_param();\n            if (result3 !== null) {\n              result2 = [result2, result3];\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          } else {\n            result2 = null;\n            pos = pos1;\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            pos1 = pos;\n            result2 = parse_SEMI();\n            if (result2 !== null) {\n              result3 = parse_replaces_param();\n              if (result3 !== null) {\n                result2 = [result2, result3];\n              } else {\n                result2 = null;\n                pos = pos1;\n              }\n            } else {\n              result2 = null;\n              pos = pos1;\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos0;\n          }\n        } else {\n          result0 = null;\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_call_id() {\n        var result0, result1, result2;\n        var pos0, pos1, pos2;\n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_word();\n        if (result0 !== null) {\n          pos2 = pos;\n          if (input.charCodeAt(pos) === 64) {\n            result1 = \"@\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"@\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_word();\n            if (result2 !== null) {\n              result1 = [result1, result2];\n            } else {\n              result1 = null;\n              pos = pos2;\n            }\n          } else {\n            result1 = null;\n            pos = pos2;\n          }\n          result1 = result1 !== null ? result1 : \"\";\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.call_id = input.substring(pos, offset);\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_replaces_param() {\n        var result0;\n        result0 = parse_to_tag();\n        if (result0 === null) {\n          result0 = parse_from_tag();\n          if (result0 === null) {\n            result0 = parse_early_flag();\n            if (result0 === null) {\n              result0 = parse_generic_param();\n            }\n          }\n        }\n        return result0;\n      }\n      function parse_to_tag() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 6) === \"to-tag\") {\n          result0 = \"to-tag\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"to-tag\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, to_tag) {\n            data.to_tag = to_tag;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_from_tag() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 8) === \"from-tag\") {\n          result0 = \"from-tag\";\n          pos += 8;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"from-tag\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_EQUAL();\n          if (result1 !== null) {\n            result2 = parse_token();\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = function (offset, from_tag) {\n            data.from_tag = from_tag;\n          }(pos0, result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function parse_early_flag() {\n        var result0;\n        var pos0;\n        pos0 = pos;\n        if (input.substr(pos, 10) === \"early-only\") {\n          result0 = \"early-only\";\n          pos += 10;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"early-only\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result0 = function (offset) {\n            data.early_only = true;\n          }(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      function cleanupExpected(expected) {\n        expected.sort();\n        var lastExpected = null;\n        var cleanExpected = [];\n        for (var i = 0; i < expected.length; i++) {\n          if (expected[i] !== lastExpected) {\n            cleanExpected.push(expected[i]);\n            lastExpected = expected[i];\n          }\n        }\n        return cleanExpected;\n      }\n      function computeErrorPosition() {\n        /*\n         * The first idea was to use |String.split| to break the input up to the\n         * error position along newlines and derive the line and column from\n         * there. However IE's |split| implementation is so broken that it was\n         * enough to prevent it.\n         */\n        var line = 1;\n        var column = 1;\n        var seenCR = false;\n        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {\n          var ch = input.charAt(i);\n          if (ch === \"\\n\") {\n            if (!seenCR) {\n              line++;\n            }\n            column = 1;\n            seenCR = false;\n          } else if (ch === \"\\r\" || ch === '\\u2028' || ch === '\\u2029') {\n            line++;\n            column = 1;\n            seenCR = true;\n          } else {\n            column++;\n            seenCR = false;\n          }\n        }\n        return { line: line, column: column };\n      }\n      var URI = __webpack_require__(/*! ./URI */ \"./lib/URI.js\");\n      var NameAddrHeader = __webpack_require__(/*! ./NameAddrHeader */ \"./lib/NameAddrHeader.js\");\n      var data = {};\n      var result = parseFunctions[startRule]();\n      /*\n       * The parser is now in one of the following three states:\n       *\n       * 1. The parser successfully parsed the whole input.\n       *\n       *    - |result !== null|\n       *    - |pos === input.length|\n       *    - |rightmostFailuresExpected| may or may not contain something\n       *\n       * 2. The parser successfully parsed only a part of the input.\n       *\n       *    - |result !== null|\n       *    - |pos < input.length|\n       *    - |rightmostFailuresExpected| may or may not contain something\n       *\n       * 3. The parser did not successfully parse any part of the input.\n       *\n       *   - |result === null|\n       *   - |pos === 0|\n       *   - |rightmostFailuresExpected| contains at least one failure\n       *\n       * All code following this comment (including called functions) must\n       * handle these states.\n       */\n      if (result === null || pos !== input.length) {\n        var offset = Math.max(pos, rightmostFailuresPos);\n        var found = offset < input.length ? input.charAt(offset) : null;\n        var errorPosition = computeErrorPosition();\n        new this.SyntaxError(cleanupExpected(rightmostFailuresExpected), found, offset, errorPosition.line, errorPosition.column);\n        return -1;\n      }\n      return data;\n    },\n    /* Returns the parser source code. */\n    toSource: function toSource() {\n      return this._source;\n    }\n  };\n  /* Thrown when a parser encounters a syntax error. */\n  result.SyntaxError = function (expected, found, offset, line, column) {\n    function buildMessage(expected, found) {\n      var expectedHumanized, foundHumanized;\n      switch (expected.length) {\n        case 0:\n          expectedHumanized = \"end of input\";\n          break;\n        case 1:\n          expectedHumanized = expected[0];\n          break;\n        default:\n          expectedHumanized = expected.slice(0, expected.length - 1).join(\", \") + \" or \" + expected[expected.length - 1];\n      }\n      foundHumanized = found ? quote(found) : \"end of input\";\n      return \"Expected \" + expectedHumanized + \" but \" + foundHumanized + \" found.\";\n    }\n    this.name = \"SyntaxError\";\n    this.expected = expected;\n    this.found = found;\n    this.message = buildMessage(expected, found);\n    this.offset = offset;\n    this.line = line;\n    this.column = column;\n  };\n  result.SyntaxError.prototype = Error.prototype;\n  return result;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./lib/Grammar.js?");

/***/ }),

/***/ "./lib/Message.js":
/*!************************!*\
  !*** ./lib/Message.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./lib/SIPMessage.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar RequestSender = __webpack_require__(/*! ./RequestSender */ \"./lib/RequestSender.js\");\nvar Exceptions = __webpack_require__(/*! ./Exceptions */ \"./lib/Exceptions.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:Message');\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(Message, _EventEmitter);\n\n  function Message(ua) {\n    _classCallCheck(this, Message);\n\n    var _this = _possibleConstructorReturn(this, (Message.__proto__ || Object.getPrototypeOf(Message)).call(this));\n\n    _this._ua = ua;\n    _this._request = null;\n    _this._closed = false;\n\n    _this._direction = null;\n    _this._local_identity = null;\n    _this._remote_identity = null;\n\n    // Whether an incoming message has been replied.\n    _this._is_replied = false;\n\n    // Custom message empty object for high level use.\n    _this._data = {};\n    return _this;\n  }\n\n  _createClass(Message, [{\n    key: 'send',\n    value: function send(target, body) {\n      var _this2 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var originalTarget = target;\n\n      if (target === undefined || body === undefined) {\n        throw new TypeError('Not enough arguments');\n      }\n\n      // Check target validity.\n      target = this._ua.normalizeTarget(target);\n      if (!target) {\n        throw new TypeError('Invalid target: ' + originalTarget);\n      }\n\n      // Get call options.\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var eventHandlers = options.eventHandlers || {};\n      var contentType = options.contentType || 'text/plain';\n\n      // Set event handlers.\n      for (var event in eventHandlers) {\n        if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {\n          this.on(event, eventHandlers[event]);\n        }\n      }\n\n      extraHeaders.push('Content-Type: ' + contentType);\n\n      this._request = new SIPMessage.OutgoingRequest(SIP_C.MESSAGE, target, this._ua, null, extraHeaders);\n\n      if (body) {\n        this._request.body = body;\n      }\n\n      var request_sender = new RequestSender(this._ua, this._request, {\n        onRequestTimeout: function onRequestTimeout() {\n          _this2._onRequestTimeout();\n        },\n        onTransportError: function onTransportError() {\n          _this2._onTransportError();\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          _this2._receiveResponse(response);\n        }\n      });\n\n      this._newMessage('local', this._request);\n\n      request_sender.send();\n    }\n  }, {\n    key: 'init_incoming',\n    value: function init_incoming(request) {\n      this._request = request;\n\n      this._newMessage('remote', request);\n\n      // Reply with a 200 OK if the user didn't reply.\n      if (!this._is_replied) {\n        this._is_replied = true;\n        request.reply(200);\n      }\n\n      this._close();\n    }\n\n    /**\n     * Accept the incoming Message\n     * Only valid for incoming Messages\n     */\n\n  }, {\n    key: 'accept',\n    value: function accept() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var body = options.body;\n\n      if (this._direction !== 'incoming') {\n        throw new Exceptions.NotSupportedError('\"accept\" not supported for outgoing Message');\n      }\n\n      if (this._is_replied) {\n        throw new Error('incoming Message already replied');\n      }\n\n      this._is_replied = true;\n      this._request.reply(200, null, extraHeaders, body);\n    }\n\n    /**\n     * Reject the incoming Message\n     * Only valid for incoming Messages\n     */\n\n  }, {\n    key: 'reject',\n    value: function reject() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var status_code = options.status_code || 480;\n      var reason_phrase = options.reason_phrase;\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var body = options.body;\n\n      if (this._direction !== 'incoming') {\n        throw new Exceptions.NotSupportedError('\"reject\" not supported for outgoing Message');\n      }\n\n      if (this._is_replied) {\n        throw new Error('incoming Message already replied');\n      }\n\n      if (status_code < 300 || status_code >= 700) {\n        throw new TypeError('Invalid status_code: ' + status_code);\n      }\n\n      this._is_replied = true;\n      this._request.reply(status_code, reason_phrase, extraHeaders, body);\n    }\n  }, {\n    key: '_receiveResponse',\n    value: function _receiveResponse(response) {\n      if (this._closed) {\n        return;\n      }\n      switch (true) {\n        case /^1[0-9]{2}$/.test(response.status_code):\n          // Ignore provisional responses.\n          break;\n\n        case /^2[0-9]{2}$/.test(response.status_code):\n          this._succeeded('remote', response);\n          break;\n\n        default:\n          {\n            var cause = Utils.sipErrorCause(response.status_code);\n\n            this._failed('remote', response, cause);\n            break;\n          }\n      }\n    }\n  }, {\n    key: '_onRequestTimeout',\n    value: function _onRequestTimeout() {\n      if (this._closed) {\n        return;\n      }\n      this._failed('system', null, SIP_C.causes.REQUEST_TIMEOUT);\n    }\n  }, {\n    key: '_onTransportError',\n    value: function _onTransportError() {\n      if (this._closed) {\n        return;\n      }\n      this._failed('system', null, SIP_C.causes.CONNECTION_ERROR);\n    }\n  }, {\n    key: '_close',\n    value: function _close() {\n      this._closed = true;\n      this._ua.destroyMessage(this);\n    }\n\n    /**\n     * Internal Callbacks\n     */\n\n  }, {\n    key: '_newMessage',\n    value: function _newMessage(originator, request) {\n      if (originator === 'remote') {\n        this._direction = 'incoming';\n        this._local_identity = request.to;\n        this._remote_identity = request.from;\n      } else if (originator === 'local') {\n        this._direction = 'outgoing';\n        this._local_identity = request.from;\n        this._remote_identity = request.to;\n      }\n\n      this._ua.newMessage(this, {\n        originator: originator,\n        message: this,\n        request: request\n      });\n    }\n  }, {\n    key: '_failed',\n    value: function _failed(originator, response, cause) {\n      debug('MESSAGE failed');\n\n      this._close();\n\n      debug('emit \"failed\"');\n\n      this.emit('failed', {\n        originator: originator,\n        response: response || null,\n        cause: cause\n      });\n    }\n  }, {\n    key: '_succeeded',\n    value: function _succeeded(originator, response) {\n      debug('MESSAGE succeeded');\n\n      this._close();\n\n      debug('emit \"succeeded\"');\n\n      this.emit('succeeded', {\n        originator: originator,\n        response: response\n      });\n    }\n  }, {\n    key: 'direction',\n    get: function get() {\n      return this._direction;\n    }\n  }, {\n    key: 'local_identity',\n    get: function get() {\n      return this._local_identity;\n    }\n  }, {\n    key: 'remote_identity',\n    get: function get() {\n      return this._remote_identity;\n    }\n  }]);\n\n  return Message;\n}(EventEmitter);\n\n//# sourceURL=webpack://ApolloSIP/./lib/Message.js?");

/***/ }),

/***/ "./lib/NameAddrHeader.js":
/*!*******************************!*\
  !*** ./lib/NameAddrHeader.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar URI = __webpack_require__(/*! ./URI */ \"./lib/URI.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./lib/Grammar.js\");\n\nmodule.exports = function () {\n  _createClass(NameAddrHeader, null, [{\n    key: 'parse',\n\n    /**\n     * Parse the given string and returns a NameAddrHeader instance or undefined if\n     * it is an invalid NameAddrHeader.\n     */\n    value: function parse(name_addr_header) {\n      name_addr_header = Grammar.parse(name_addr_header, 'Name_Addr_Header');\n\n      if (name_addr_header !== -1) {\n        return name_addr_header;\n      } else {\n        return undefined;\n      }\n    }\n  }]);\n\n  function NameAddrHeader(uri, display_name, parameters) {\n    _classCallCheck(this, NameAddrHeader);\n\n    // Checks.\n    if (!uri || !(uri instanceof URI)) {\n      throw new TypeError('missing or invalid \"uri\" parameter');\n    }\n\n    // Initialize parameters.\n    this._uri = uri;\n    this._parameters = {};\n    this._display_name = display_name;\n\n    for (var param in parameters) {\n      if (Object.prototype.hasOwnProperty.call(parameters, param)) {\n        this.setParam(param, parameters[param]);\n      }\n    }\n  }\n\n  _createClass(NameAddrHeader, [{\n    key: 'setParam',\n    value: function setParam(key, value) {\n      if (key) {\n        this._parameters[key.toLowerCase()] = typeof value === 'undefined' || value === null ? null : value.toString();\n      }\n    }\n  }, {\n    key: 'getParam',\n    value: function getParam(key) {\n      if (key) {\n        return this._parameters[key.toLowerCase()];\n      }\n    }\n  }, {\n    key: 'hasParam',\n    value: function hasParam(key) {\n      if (key) {\n        return this._parameters.hasOwnProperty(key.toLowerCase()) && true || false;\n      }\n    }\n  }, {\n    key: 'deleteParam',\n    value: function deleteParam(parameter) {\n      parameter = parameter.toLowerCase();\n      if (this._parameters.hasOwnProperty(parameter)) {\n        var value = this._parameters[parameter];\n\n        delete this._parameters[parameter];\n\n        return value;\n      }\n    }\n  }, {\n    key: 'clearParams',\n    value: function clearParams() {\n      this._parameters = {};\n    }\n  }, {\n    key: 'clone',\n    value: function clone() {\n      return new NameAddrHeader(this._uri.clone(), this._display_name, JSON.parse(JSON.stringify(this._parameters)));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var body = this._display_name || this._display_name === 0 ? '\"' + this._display_name + '\" ' : '';\n\n      body += '<' + this._uri.toString() + '>';\n\n      for (var parameter in this._parameters) {\n        if (Object.prototype.hasOwnProperty.call(this._parameters, parameter)) {\n          body += ';' + parameter;\n\n          if (this._parameters[parameter] !== null) {\n            body += '=' + this._parameters[parameter];\n          }\n        }\n      }\n\n      return body;\n    }\n  }, {\n    key: 'uri',\n    get: function get() {\n      return this._uri;\n    }\n  }, {\n    key: 'display_name',\n    get: function get() {\n      return this._display_name;\n    },\n    set: function set(value) {\n      this._display_name = value === 0 ? '0' : value;\n    }\n  }]);\n\n  return NameAddrHeader;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./lib/NameAddrHeader.js?");

/***/ }),

/***/ "./lib/Parser.js":
/*!***********************!*\
  !*** ./lib/Parser.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./lib/Grammar.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./lib/SIPMessage.js\");\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:ERROR:Parser');\n\ndebugerror.log = console.warn.bind(console);\n\n/**\n * Parse SIP Message\n */\nexports.parseMessage = function (data, ua) {\n  var message = void 0;\n  var bodyStart = void 0;\n  var headerEnd = data.indexOf('\\r\\n');\n\n  if (headerEnd === -1) {\n    debugerror('parseMessage() | no CRLF found, not a SIP message');\n\n    return;\n  }\n\n  // Parse first line. Check if it is a Request or a Reply.\n  var firstLine = data.substring(0, headerEnd);\n  var parsed = Grammar.parse(firstLine, 'Request_Response');\n\n  if (parsed === -1) {\n    debugerror('parseMessage() | error parsing first line of SIP message: \"' + firstLine + '\"');\n\n    return;\n  } else if (!parsed.status_code) {\n    message = new SIPMessage.IncomingRequest(ua);\n    message.method = parsed.method;\n    message.ruri = parsed.uri;\n  } else {\n    message = new SIPMessage.IncomingResponse();\n    message.status_code = parsed.status_code;\n    message.reason_phrase = parsed.reason_phrase;\n  }\n\n  message.data = data;\n  var headerStart = headerEnd + 2;\n\n  /* Loop over every line in data. Detect the end of each header and parse\n  * it or simply add to the headers collection.\n  */\n  while (true) {\n    headerEnd = getHeader(data, headerStart);\n\n    // The SIP message has normally finished.\n    if (headerEnd === -2) {\n      bodyStart = headerStart + 2;\n      break;\n    }\n    // Data.indexOf returned -1 due to a malformed message.\n    else if (headerEnd === -1) {\n        debugerror('parseMessage() | malformed message');\n\n        return;\n      }\n\n    parsed = parseHeader(message, data, headerStart, headerEnd);\n\n    if (parsed !== true) {\n      debugerror('parseMessage() |', parsed.error);\n\n      return;\n    }\n\n    headerStart = headerEnd + 2;\n  }\n\n  /* RFC3261 18.3.\n   * If there are additional bytes in the transport packet\n   * beyond the end of the body, they MUST be discarded.\n   */\n  if (message.hasHeader('content-length')) {\n    var contentLength = message.getHeader('content-length');\n\n    message.body = data.substr(bodyStart, contentLength);\n  } else {\n    message.body = data.substring(bodyStart);\n  }\n\n  return message;\n};\n\n/**\n * Extract and parse every header of a SIP message.\n */\nfunction getHeader(data, headerStart) {\n  // 'start' position of the header.\n  var start = headerStart;\n  // 'end' position of the header.\n  var end = 0;\n  // 'partial end' position of the header.\n  var partialEnd = 0;\n\n  // End of message.\n  if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n    return -2;\n  }\n\n  while (end === 0) {\n    // Partial End of Header.\n    partialEnd = data.indexOf('\\r\\n', start);\n\n    // 'indexOf' returns -1 if the value to be found never occurs.\n    if (partialEnd === -1) {\n      return partialEnd;\n    }\n\n    if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n      // Not the end of the message. Continue from the next position.\n      start = partialEnd + 2;\n    } else {\n      end = partialEnd;\n    }\n  }\n\n  return end;\n}\n\nfunction parseHeader(message, data, headerStart, headerEnd) {\n  var parsed = void 0;\n  var hcolonIndex = data.indexOf(':', headerStart);\n  var headerName = data.substring(headerStart, hcolonIndex).trim();\n  var headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();\n\n  // If header-field is well-known, parse it.\n  switch (headerName.toLowerCase()) {\n    case 'via':\n    case 'v':\n      message.addHeader('via', headerValue);\n      if (message.getHeaders('via').length === 1) {\n        parsed = message.parseHeader('Via');\n        if (parsed) {\n          message.via = parsed;\n          message.via_branch = parsed.branch;\n        }\n      } else {\n        parsed = 0;\n      }\n      break;\n    case 'from':\n    case 'f':\n      message.setHeader('from', headerValue);\n      parsed = message.parseHeader('from');\n      if (parsed) {\n        message.from = parsed;\n        message.from_tag = parsed.getParam('tag');\n      }\n      break;\n    case 'to':\n    case 't':\n      message.setHeader('to', headerValue);\n      parsed = message.parseHeader('to');\n      if (parsed) {\n        message.to = parsed;\n        message.to_tag = parsed.getParam('tag');\n      }\n      break;\n    case 'record-route':\n      parsed = Grammar.parse(headerValue, 'Record_Route');\n\n      if (parsed === -1) {\n        parsed = undefined;\n      } else {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = parsed[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var header = _step.value;\n\n            message.addHeader('record-route', headerValue.substring(header.possition, header.offset));\n            message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n      break;\n    case 'call-id':\n    case 'i':\n      message.setHeader('call-id', headerValue);\n      parsed = message.parseHeader('call-id');\n      if (parsed) {\n        message.call_id = headerValue;\n      }\n      break;\n    case 'contact':\n    case 'm':\n      parsed = Grammar.parse(headerValue, 'Contact');\n\n      if (parsed === -1) {\n        parsed = undefined;\n      } else {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = parsed[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _header = _step2.value;\n\n            message.addHeader('contact', headerValue.substring(_header.possition, _header.offset));\n            message.headers.Contact[message.getHeaders('contact').length - 1].parsed = _header.parsed;\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n      break;\n    case 'content-length':\n    case 'l':\n      message.setHeader('content-length', headerValue);\n      parsed = message.parseHeader('content-length');\n      break;\n    case 'content-type':\n    case 'c':\n      message.setHeader('content-type', headerValue);\n      parsed = message.parseHeader('content-type');\n      break;\n    case 'cseq':\n      message.setHeader('cseq', headerValue);\n      parsed = message.parseHeader('cseq');\n      if (parsed) {\n        message.cseq = parsed.value;\n      }\n      if (message instanceof SIPMessage.IncomingResponse) {\n        message.method = parsed.method;\n      }\n      break;\n    case 'max-forwards':\n      message.setHeader('max-forwards', headerValue);\n      parsed = message.parseHeader('max-forwards');\n      break;\n    case 'www-authenticate':\n      message.setHeader('www-authenticate', headerValue);\n      parsed = message.parseHeader('www-authenticate');\n      break;\n    case 'proxy-authenticate':\n      message.setHeader('proxy-authenticate', headerValue);\n      parsed = message.parseHeader('proxy-authenticate');\n      break;\n    case 'session-expires':\n    case 'x':\n      message.setHeader('session-expires', headerValue);\n      parsed = message.parseHeader('session-expires');\n      if (parsed) {\n        message.session_expires = parsed.expires;\n        message.session_expires_refresher = parsed.refresher;\n      }\n      break;\n    case 'refer-to':\n    case 'r':\n      message.setHeader('refer-to', headerValue);\n      parsed = message.parseHeader('refer-to');\n      if (parsed) {\n        message.refer_to = parsed;\n      }\n      break;\n    case 'replaces':\n      message.setHeader('replaces', headerValue);\n      parsed = message.parseHeader('replaces');\n      if (parsed) {\n        message.replaces = parsed;\n      }\n      break;\n    case 'event':\n    case 'o':\n      message.setHeader('event', headerValue);\n      parsed = message.parseHeader('event');\n      if (parsed) {\n        message.event = parsed;\n      }\n      break;\n    default:\n      // Do not parse this header.\n      message.setHeader(headerName, headerValue);\n      parsed = 0;\n  }\n\n  if (parsed === undefined) {\n    return {\n      error: 'error parsing header \"' + headerName + '\"'\n    };\n  } else {\n    return true;\n  }\n}\n\n//# sourceURL=webpack://ApolloSIP/./lib/Parser.js?");

/***/ }),

/***/ "./lib/RTCSession.js":
/*!***************************!*\
  !*** ./lib/RTCSession.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/* globals RTCPeerConnection: false, RTCSessionDescription: false */\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar sdp_transform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar Exceptions = __webpack_require__(/*! ./Exceptions */ \"./lib/Exceptions.js\");\nvar Transactions = __webpack_require__(/*! ./Transactions */ \"./lib/Transactions.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar Timers = __webpack_require__(/*! ./Timers */ \"./lib/Timers.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./lib/SIPMessage.js\");\nvar Dialog = __webpack_require__(/*! ./Dialog */ \"./lib/Dialog.js\");\nvar RequestSender = __webpack_require__(/*! ./RequestSender */ \"./lib/RequestSender.js\");\nvar RTCSession_DTMF = __webpack_require__(/*! ./RTCSession/DTMF */ \"./lib/RTCSession/DTMF.js\");\nvar RTCSession_Info = __webpack_require__(/*! ./RTCSession/Info */ \"./lib/RTCSession/Info.js\");\nvar RTCSession_ReferNotifier = __webpack_require__(/*! ./RTCSession/ReferNotifier */ \"./lib/RTCSession/ReferNotifier.js\");\nvar RTCSession_ReferSubscriber = __webpack_require__(/*! ./RTCSession/ReferSubscriber */ \"./lib/RTCSession/ReferSubscriber.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:RTCSession');\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:ERROR:RTCSession');\n\ndebugerror.log = console.warn.bind(console);\n\nvar C = {\n  // RTCSession states.\n  STATUS_NULL: 0,\n  STATUS_INVITE_SENT: 1,\n  STATUS_1XX_RECEIVED: 2,\n  STATUS_INVITE_RECEIVED: 3,\n  STATUS_WAITING_FOR_ANSWER: 4,\n  STATUS_ANSWERED: 5,\n  STATUS_WAITING_FOR_ACK: 6,\n  STATUS_CANCELED: 7,\n  STATUS_TERMINATED: 8,\n  STATUS_CONFIRMED: 9\n};\n\n/**\n * Local variables.\n */\nvar holdMediaTypes = ['audio', 'video'];\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(RTCSession, _EventEmitter);\n\n  _createClass(RTCSession, null, [{\n    key: 'C',\n\n    /**\n     * Expose C object.\n     */\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  function RTCSession(ua) {\n    _classCallCheck(this, RTCSession);\n\n    debug('new');\n\n    var _this = _possibleConstructorReturn(this, (RTCSession.__proto__ || Object.getPrototypeOf(RTCSession)).call(this));\n\n    _this._id = null;\n    _this._ua = ua;\n    _this._status = C.STATUS_NULL;\n    _this._dialog = null;\n    _this._earlyDialogs = {};\n    _this._contact = null;\n    _this._from_tag = null;\n    _this._to_tag = null;\n\n    // The RTCPeerConnection instance (public attribute).\n    _this._connection = null;\n\n    // Prevent races on serial PeerConnction operations.\n    _this._connectionPromiseQueue = Promise.resolve();\n\n    // Incoming/Outgoing request being currently processed.\n    _this._request = null;\n\n    // Cancel state for initial outgoing request.\n    _this._is_canceled = false;\n    _this._cancel_reason = '';\n\n    // RTCSession confirmation flag.\n    _this._is_confirmed = false;\n\n    // Is late SDP being negotiated.\n    _this._late_sdp = false;\n\n    // Default rtcOfferConstraints and rtcAnswerConstrainsts (passed in connect() or answer()).\n    _this._rtcOfferConstraints = null;\n    _this._rtcAnswerConstraints = null;\n\n    // Local MediaStream.\n    _this._localMediaStream = null;\n    _this._localMediaStreamLocallyGenerated = false;\n\n    // Flag to indicate PeerConnection ready for new actions.\n    _this._rtcReady = true;\n\n    // SIP Timers.\n    _this._timers = {\n      ackTimer: null,\n      expiresTimer: null,\n      invite2xxTimer: null,\n      userNoAnswerTimer: null\n    };\n\n    // Session info.\n    _this._direction = null;\n    _this._local_identity = null;\n    _this._remote_identity = null;\n    _this._start_time = null;\n    _this._end_time = null;\n    _this._tones = null;\n    _this._withoutSDP = false;\n\n    // Mute/Hold state.\n    _this._audioMuted = false;\n    _this._videoMuted = false;\n    _this._localHold = false;\n    _this._remoteHold = false;\n\n    // Session Timers (RFC 4028).\n    _this._sessionTimers = {\n      enabled: _this._ua.configuration.session_timers,\n      refreshMethod: _this._ua.configuration.session_timers_refresh_method,\n      defaultExpires: SIP_C.SESSION_EXPIRES,\n      currentExpires: null,\n      running: false,\n      refresher: false,\n      timer: null // A setTimeout.\n    };\n\n    // Map of ReferSubscriber instances indexed by the REFER's CSeq number.\n    _this._referSubscribers = {};\n\n    // Custom session empty object for high level use.\n    _this._data = {};\n    return _this;\n  }\n\n  /**\n   * User API\n   */\n\n  // Expose RTCSession constants as a property of the RTCSession instance.\n\n\n  _createClass(RTCSession, [{\n    key: 'isInProgress',\n    value: function isInProgress() {\n      switch (this._status) {\n        case C.STATUS_NULL:\n        case C.STATUS_INVITE_SENT:\n        case C.STATUS_1XX_RECEIVED:\n        case C.STATUS_INVITE_RECEIVED:\n        case C.STATUS_WAITING_FOR_ANSWER:\n          return true;\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: 'isEstablished',\n    value: function isEstablished() {\n      switch (this._status) {\n        case C.STATUS_ANSWERED:\n        case C.STATUS_WAITING_FOR_ACK:\n        case C.STATUS_CONFIRMED:\n          return true;\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: 'isEnded',\n    value: function isEnded() {\n      switch (this._status) {\n        case C.STATUS_CANCELED:\n        case C.STATUS_TERMINATED:\n          return true;\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: 'isMuted',\n    value: function isMuted() {\n      return {\n        audio: this._audioMuted,\n        video: this._videoMuted\n      };\n    }\n  }, {\n    key: 'isOnHold',\n    value: function isOnHold() {\n      return {\n        local: this._localHold,\n        remote: this._remoteHold\n      };\n    }\n  }, {\n    key: 'connect',\n    value: function connect(target) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var initCallback = arguments[2];\n\n      debug('connect()');\n\n      var originalTarget = target;\n      var eventHandlers = options.eventHandlers || {};\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var mediaConstraints = options.mediaConstraints || { audio: true, video: true };\n      var mediaStream = options.mediaStream || null;\n      var pcConfig = options.pcConfig || { iceServers: [] };\n      var rtcConstraints = options.rtcConstraints || null;\n      var rtcOfferConstraints = options.rtcOfferConstraints || null;\n      var contentType = options.contentType || 'application/sdp';\n      var body = options.body;\n\n      this._rtcOfferConstraints = rtcOfferConstraints;\n      this._rtcAnswerConstraints = options.rtcAnswerConstraints || null;\n\n      this._data = options.data || this._data;\n      this._withoutSDP = options.withoutSDP || this._withoutSDP;\n\n      // Check target.\n      if (target === undefined) {\n        throw new TypeError('Not enough arguments');\n      }\n\n      // Check Session Status.\n      if (this._status !== C.STATUS_NULL) {\n        throw new Exceptions.InvalidStateError(this._status);\n      }\n\n      // Check WebRTC support.\n      if (!window.RTCPeerConnection) {\n        throw new Exceptions.NotSupportedError('WebRTC not supported');\n      }\n\n      // Check target validity.\n      target = this._ua.normalizeTarget(target);\n      if (!target) {\n        throw new TypeError('Invalid target: ' + originalTarget);\n      }\n\n      // Session Timers.\n      if (this._sessionTimers.enabled) {\n        if (Utils.isDecimal(options.sessionTimersExpires)) {\n          if (options.sessionTimersExpires >= SIP_C.MIN_SESSION_EXPIRES) {\n            this._sessionTimers.defaultExpires = options.sessionTimersExpires;\n          } else {\n            this._sessionTimers.defaultExpires = SIP_C.SESSION_EXPIRES;\n          }\n        }\n      }\n\n      // Set event handlers.\n      for (var event in eventHandlers) {\n        if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {\n          this.on(event, eventHandlers[event]);\n        }\n      }\n\n      // Session parameter initialization.\n      this._from_tag = Utils.newTag();\n\n      // Set anonymous property.\n      var anonymous = options.anonymous || false;\n\n      var requestParams = { from_tag: this._from_tag };\n\n      this._contact = this._ua.contact.toString({\n        anonymous: anonymous,\n        outbound: true\n      });\n\n      if (anonymous) {\n        requestParams.from_display_name = 'Anonymous';\n        requestParams.from_uri = 'sip:anonymous@anonymous.invalid';\n\n        extraHeaders.push('P-Preferred-Identity: ' + this._ua.configuration.uri.toString());\n        extraHeaders.push('Privacy: id');\n      }\n\n      extraHeaders.push('Contact: ' + this._contact);\n      extraHeaders.push('Content-Type: ' + contentType);\n      if (this._sessionTimers.enabled) {\n        extraHeaders.push('Session-Expires: ' + this._sessionTimers.defaultExpires);\n      }\n\n      this._request = new SIPMessage.InitialOutgoingInviteRequest(target, this._ua, requestParams, extraHeaders);\n\n      this._id = this._request.call_id + this._from_tag;\n\n      if (!this._withoutSDP) {\n        // Create a new RTCPeerConnection instance.\n        this._createRTCConnection(pcConfig, rtcConstraints);\n      } else {\n        this._request.body = body;\n      }\n\n      // Set internal properties.\n      this._direction = 'outgoing';\n      this._local_identity = this._request.from;\n      this._remote_identity = this._request.to;\n\n      // User explicitly provided a newRTCSession callback for this session.\n      if (initCallback) {\n        initCallback(this);\n      }\n\n      this._newRTCSession('local', this._request);\n\n      this._sendInitialRequest(mediaConstraints, rtcOfferConstraints, mediaStream);\n    }\n  }, {\n    key: 'init_incoming',\n    value: function init_incoming(request, initCallback) {\n      var _this2 = this;\n\n      debug('init_incoming()');\n\n      var expires = void 0;\n      var contentType = request.getHeader('Content-Type');\n\n      // Check body and content type.\n      if (request.body && contentType !== 'application/sdp') {\n        request.reply(415);\n\n        return;\n      }\n\n      // Session parameter initialization.\n      this._status = C.STATUS_INVITE_RECEIVED;\n      this._from_tag = request.from_tag;\n      this._id = request.call_id + this._from_tag;\n      this._request = request;\n      this._contact = this._ua.contact.toString();\n\n      // Get the Expires header value if exists.\n      if (request.hasHeader('expires')) {\n        expires = request.getHeader('expires') * 1000;\n      }\n\n      /* Set the to_tag before\n       * replying a response code that will create a dialog.\n       */\n      request.to_tag = Utils.newTag();\n\n      // An error on dialog creation will fire 'failed' event.\n      if (!this._createDialog(request, 'UAS', true)) {\n        request.reply(500, 'Missing Contact header field');\n\n        return;\n      }\n\n      if (request.body) {\n        this._late_sdp = false;\n      } else {\n        this._late_sdp = true;\n      }\n\n      this._status = C.STATUS_WAITING_FOR_ANSWER;\n\n      // Set userNoAnswerTimer.\n      this._timers.userNoAnswerTimer = setTimeout(function () {\n        request.reply(408);\n        _this2._failed('local', null, SIP_C.causes.NO_ANSWER);\n      }, this._ua.configuration.no_answer_timeout);\n\n      /* Set expiresTimer\n       * RFC3261 13.3.1\n       */\n      if (expires) {\n        this._timers.expiresTimer = setTimeout(function () {\n          if (_this2._status === C.STATUS_WAITING_FOR_ANSWER) {\n            request.reply(487);\n            _this2._failed('system', null, SIP_C.causes.EXPIRES);\n          }\n        }, expires);\n      }\n\n      // Set internal properties.\n      this._direction = 'incoming';\n      this._local_identity = request.to;\n      this._remote_identity = request.from;\n\n      // A init callback was specifically defined.\n      if (initCallback) {\n        initCallback(this);\n      }\n\n      // Fire 'newRTCSession' event.\n      this._newRTCSession('remote', request);\n\n      // The user may have rejected the call in the 'newRTCSession' event.\n      if (this._status === C.STATUS_TERMINATED) {\n        return;\n      }\n\n      // Reply 180.\n      request.reply(180, null, ['Contact: ' + this._contact]);\n\n      // Fire 'progress' event.\n      // TODO: Document that 'response' field in 'progress' event is null for incoming calls.\n      this._progress('local', null);\n    }\n\n    /**\n     * Answer the call.\n     */\n\n  }, {\n    key: 'answer',\n    value: function answer() {\n      var _this3 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      debug('answer()');\n\n      var request = this._request;\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var mediaConstraints = options.mediaConstraints || {};\n      var mediaStream = options.mediaStream || null;\n      var pcConfig = options.pcConfig || { iceServers: [] };\n      var rtcConstraints = options.rtcConstraints || null;\n      var rtcAnswerConstraints = options.rtcAnswerConstraints || null;\n\n      var tracks = void 0;\n      var peerHasAudioLine = false;\n      var peerHasVideoLine = false;\n      var peerOffersFullAudio = false;\n      var peerOffersFullVideo = false;\n\n      this._rtcAnswerConstraints = rtcAnswerConstraints;\n      this._rtcOfferConstraints = options.rtcOfferConstraints || null;\n\n      this._data = options.data || this._data;\n\n      // Check Session Direction and Status.\n      if (this._direction !== 'incoming') {\n        throw new Exceptions.NotSupportedError('\"answer\" not supported for outgoing RTCSession');\n      }\n\n      // Check Session status.\n      if (this._status !== C.STATUS_WAITING_FOR_ANSWER) {\n        throw new Exceptions.InvalidStateError(this._status);\n      }\n\n      // Session Timers.\n      if (this._sessionTimers.enabled) {\n        if (Utils.isDecimal(options.sessionTimersExpires)) {\n          if (options.sessionTimersExpires >= SIP_C.MIN_SESSION_EXPIRES) {\n            this._sessionTimers.defaultExpires = options.sessionTimersExpires;\n          } else {\n            this._sessionTimers.defaultExpires = SIP_C.SESSION_EXPIRES;\n          }\n        }\n      }\n\n      this._status = C.STATUS_ANSWERED;\n\n      // An error on dialog creation will fire 'failed' event.\n      if (!this._createDialog(request, 'UAS')) {\n        request.reply(500, 'Error creating dialog');\n\n        return;\n      }\n\n      clearTimeout(this._timers.userNoAnswerTimer);\n\n      extraHeaders.unshift('Contact: ' + this._contact);\n\n      // Determine incoming media from incoming SDP offer (if any).\n      var sdp = request.parseSDP();\n\n      // Make sure sdp.media is an array, not the case if there is only one media.\n      if (!Array.isArray(sdp.media)) {\n        sdp.media = [sdp.media];\n      }\n\n      // Go through all medias in SDP to find offered capabilities to answer with.\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = sdp.media[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var m = _step.value;\n\n          if (m.type === 'audio') {\n            peerHasAudioLine = true;\n            if (!m.direction || m.direction === 'sendrecv') {\n              peerOffersFullAudio = true;\n            }\n          }\n          if (m.type === 'video') {\n            peerHasVideoLine = true;\n            if (!m.direction || m.direction === 'sendrecv') {\n              peerOffersFullVideo = true;\n            }\n          }\n        }\n\n        // Remove audio from mediaStream if suggested by mediaConstraints.\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (mediaStream && mediaConstraints.audio === false) {\n        tracks = mediaStream.getAudioTracks();\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = tracks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var track = _step2.value;\n\n            mediaStream.removeTrack(track);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n\n      // Remove video from mediaStream if suggested by mediaConstraints.\n      if (mediaStream && mediaConstraints.video === false) {\n        tracks = mediaStream.getVideoTracks();\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = tracks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var _track = _step3.value;\n\n            mediaStream.removeTrack(_track);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      // Set audio constraints based on incoming stream if not supplied.\n      if (!mediaStream && mediaConstraints.audio === undefined) {\n        mediaConstraints.audio = peerOffersFullAudio;\n      }\n\n      // Set video constraints based on incoming stream if not supplied.\n      if (!mediaStream && mediaConstraints.video === undefined) {\n        mediaConstraints.video = peerOffersFullVideo;\n      }\n\n      // Don't ask for audio if the incoming offer has no audio section.\n      if (!mediaStream && !peerHasAudioLine) {\n        mediaConstraints.audio = false;\n      }\n\n      // Don't ask for video if the incoming offer has no video section.\n      if (!mediaStream && !peerHasVideoLine) {\n        mediaConstraints.video = false;\n      }\n\n      // Create a new RTCPeerConnection instance.\n      // TODO: This may throw an error, should react.\n      this._createRTCConnection(pcConfig, rtcConstraints);\n\n      Promise.resolve()\n      // Handle local MediaStream.\n      .then(function () {\n        // A local MediaStream is given, use it.\n        if (mediaStream) {\n          return mediaStream;\n        }\n\n        // Audio and/or video requested, prompt getUserMedia.\n        else if (mediaConstraints.audio || mediaConstraints.video) {\n            _this3._localMediaStreamLocallyGenerated = true;\n\n            return navigator.mediaDevices.getUserMedia(mediaConstraints).catch(function (error) {\n              if (_this3._status === C.STATUS_TERMINATED) {\n                throw new Error('terminated');\n              }\n\n              request.reply(480);\n              _this3._failed('local', null, SIP_C.causes.USER_DENIED_MEDIA_ACCESS);\n\n              debugerror('emit \"getusermediafailed\" [error:%o]', error);\n\n              _this3.emit('getusermediafailed', error);\n\n              throw new Error('getUserMedia() failed');\n            });\n          }\n      })\n      // Attach MediaStream to RTCPeerconnection.\n      .then(function (stream) {\n        if (_this3._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        _this3._localMediaStream = stream;\n        if (stream) {\n          _this3._connection.addStream(stream);\n        }\n      })\n      // Set remote description.\n      .then(function () {\n        if (_this3._late_sdp) {\n          return;\n        }\n\n        var e = { originator: 'remote', type: 'offer', sdp: request.body };\n\n        debug('emit \"sdp\"');\n        _this3.emit('sdp', e);\n\n        var offer = new RTCSessionDescription({ type: 'offer', sdp: e.sdp });\n\n        _this3._connectionPromiseQueue = _this3._connectionPromiseQueue.then(function () {\n          return _this3._connection.setRemoteDescription(offer);\n        }).catch(function (error) {\n          request.reply(488);\n\n          _this3._failed('system', null, SIP_C.causes.WEBRTC_ERROR);\n\n          debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n          _this3.emit('peerconnection:setremotedescriptionfailed', error);\n\n          throw new Error('peerconnection.setRemoteDescription() failed');\n        });\n\n        return _this3._connectionPromiseQueue;\n      })\n      // Create local description.\n      .then(function () {\n        if (_this3._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        // TODO: Is this event already useful?\n        _this3._connecting(request);\n\n        if (!_this3._late_sdp) {\n          return _this3._createLocalDescription('answer', rtcAnswerConstraints).catch(function () {\n            request.reply(500);\n\n            throw new Error('_createLocalDescription() failed');\n          });\n        } else {\n          return _this3._createLocalDescription('offer', _this3._rtcOfferConstraints).catch(function () {\n            request.reply(500);\n\n            throw new Error('_createLocalDescription() failed');\n          });\n        }\n      })\n      // Send reply.\n      .then(function (desc) {\n        if (_this3._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        _this3._handleSessionTimersInIncomingRequest(request, extraHeaders);\n\n        request.reply(200, null, extraHeaders, desc, function () {\n          _this3._status = C.STATUS_WAITING_FOR_ACK;\n\n          _this3._setInvite2xxTimer(request, desc);\n          _this3._setACKTimer();\n          _this3._accepted('local');\n        }, function () {\n          _this3._failed('system', null, SIP_C.causes.CONNECTION_ERROR);\n        });\n      }).catch(function (error) {\n        if (_this3._status === C.STATUS_TERMINATED) {\n          return;\n        }\n\n        debugerror(error);\n      });\n    }\n\n    /**\n     * Terminate the call.\n     */\n\n  }, {\n    key: 'terminate',\n    value: function terminate() {\n      var _this4 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      debug('terminate()');\n\n      var cause = options.cause || SIP_C.causes.BYE;\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var body = options.body;\n\n      var cancel_reason = void 0;\n      var status_code = options.status_code;\n      var reason_phrase = options.reason_phrase;\n\n      // Check Session Status.\n      if (this._status === C.STATUS_TERMINATED) {\n        throw new Exceptions.InvalidStateError(this._status);\n      }\n\n      switch (this._status) {\n        // - UAC -\n        case C.STATUS_NULL:\n        case C.STATUS_INVITE_SENT:\n        case C.STATUS_1XX_RECEIVED:\n          debug('canceling session');\n\n          if (status_code && (status_code < 200 || status_code >= 700)) {\n            throw new TypeError('Invalid status_code: ' + status_code);\n          } else if (status_code) {\n            reason_phrase = reason_phrase || SIP_C.REASON_PHRASE[status_code] || '';\n            cancel_reason = 'SIP ;cause=' + status_code + ' ;text=\"' + reason_phrase + '\"';\n          }\n\n          // Check Session Status.\n          if (this._status === C.STATUS_NULL || this._status === C.STATUS_INVITE_SENT) {\n            this._is_canceled = true;\n            this._cancel_reason = cancel_reason;\n          } else if (this._status === C.STATUS_1XX_RECEIVED) {\n            this._request.cancel(cancel_reason);\n          }\n\n          this._status = C.STATUS_CANCELED;\n\n          this._failed('local', null, SIP_C.causes.CANCELED);\n          break;\n\n        // - UAS -\n        case C.STATUS_WAITING_FOR_ANSWER:\n        case C.STATUS_ANSWERED:\n          debug('rejecting session');\n\n          status_code = status_code || 480;\n\n          if (status_code < 300 || status_code >= 700) {\n            throw new TypeError('Invalid status_code: ' + status_code);\n          }\n\n          this._request.reply(status_code, reason_phrase, extraHeaders, body);\n          this._failed('local', null, SIP_C.causes.REJECTED);\n          break;\n\n        case C.STATUS_WAITING_FOR_ACK:\n        case C.STATUS_CONFIRMED:\n          debug('terminating session');\n\n          reason_phrase = options.reason_phrase || SIP_C.REASON_PHRASE[status_code] || '';\n\n          if (status_code && (status_code < 200 || status_code >= 700)) {\n            throw new TypeError('Invalid status_code: ' + status_code);\n          } else if (status_code) {\n            extraHeaders.push('Reason: SIP ;cause=' + status_code + '; text=\"' + reason_phrase + '\"');\n          }\n\n          /* RFC 3261 section 15 (Terminating a session):\n            *\n            * \"...the callee's UA MUST NOT send a BYE on a confirmed dialog\n            * until it has received an ACK for its 2xx response or until the server\n            * transaction times out.\"\n            */\n          if (this._status === C.STATUS_WAITING_FOR_ACK && this._direction === 'incoming' && this._request.server_transaction.state !== Transactions.C.STATUS_TERMINATED) {\n\n            // Save the dialog for later restoration.\n            var dialog = this._dialog;\n\n            // Send the BYE as soon as the ACK is received...\n            this.receiveRequest = function (_ref) {\n              var method = _ref.method;\n\n              if (method === SIP_C.ACK) {\n                _this4.sendRequest(SIP_C.BYE, {\n                  extraHeaders: extraHeaders,\n                  body: body\n                });\n                dialog.terminate();\n              }\n            };\n\n            // .., or when the INVITE transaction times out\n            this._request.server_transaction.on('stateChanged', function () {\n              if (_this4._request.server_transaction.state === Transactions.C.STATUS_TERMINATED) {\n                _this4.sendRequest(SIP_C.BYE, {\n                  extraHeaders: extraHeaders,\n                  body: body\n                });\n                dialog.terminate();\n              }\n            });\n\n            this._ended('local', null, cause);\n\n            // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-).\n            this._dialog = dialog;\n\n            // Restore the dialog into 'ua' so the ACK can reach 'this' session.\n            this._ua.newDialog(dialog);\n          } else {\n            this.sendRequest(SIP_C.BYE, {\n              extraHeaders: extraHeaders,\n              body: body\n            });\n\n            this._ended('local', null, cause);\n          }\n      }\n    }\n  }, {\n    key: 'sendDTMF',\n    value: function sendDTMF(tones) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      debug('sendDTMF() | tones: %s', tones);\n\n      var position = 0;\n      var duration = options.duration || null;\n      var interToneGap = options.interToneGap || null;\n\n      if (tones === undefined) {\n        throw new TypeError('Not enough arguments');\n      }\n\n      // Check Session Status.\n      if (this._status !== C.STATUS_CONFIRMED && this._status !== C.STATUS_WAITING_FOR_ACK) {\n        throw new Exceptions.InvalidStateError(this._status);\n      }\n\n      // Convert to string.\n      if (typeof tones === 'number') {\n        tones = tones.toString();\n      }\n\n      // Check tones.\n      if (!tones || typeof tones !== 'string' || !tones.match(/^[0-9A-DR#*,]+$/i)) {\n        throw new TypeError('Invalid tones: ' + tones);\n      }\n\n      // Check duration.\n      if (duration && !Utils.isDecimal(duration)) {\n        throw new TypeError('Invalid tone duration: ' + duration);\n      } else if (!duration) {\n        duration = RTCSession_DTMF.C.DEFAULT_DURATION;\n      } else if (duration < RTCSession_DTMF.C.MIN_DURATION) {\n        debug('\"duration\" value is lower than the minimum allowed, setting it to ' + RTCSession_DTMF.C.MIN_DURATION + ' milliseconds');\n        duration = RTCSession_DTMF.C.MIN_DURATION;\n      } else if (duration > RTCSession_DTMF.C.MAX_DURATION) {\n        debug('\"duration\" value is greater than the maximum allowed, setting it to ' + RTCSession_DTMF.C.MAX_DURATION + ' milliseconds');\n        duration = RTCSession_DTMF.C.MAX_DURATION;\n      } else {\n        duration = Math.abs(duration);\n      }\n      options.duration = duration;\n\n      // Check interToneGap.\n      if (interToneGap && !Utils.isDecimal(interToneGap)) {\n        throw new TypeError('Invalid interToneGap: ' + interToneGap);\n      } else if (!interToneGap) {\n        interToneGap = RTCSession_DTMF.C.DEFAULT_INTER_TONE_GAP;\n      } else if (interToneGap < RTCSession_DTMF.C.MIN_INTER_TONE_GAP) {\n        debug('\"interToneGap\" value is lower than the minimum allowed, setting it to ' + RTCSession_DTMF.C.MIN_INTER_TONE_GAP + ' milliseconds');\n        interToneGap = RTCSession_DTMF.C.MIN_INTER_TONE_GAP;\n      } else {\n        interToneGap = Math.abs(interToneGap);\n      }\n\n      if (this._tones) {\n        // Tones are already queued, just add to the queue.\n        this._tones += tones;\n\n        return;\n      }\n\n      this._tones = tones;\n\n      // Send the first tone.\n      _sendDTMF.call(this);\n\n      function _sendDTMF() {\n        var _this5 = this;\n\n        var timeout = void 0;\n\n        if (this._status === C.STATUS_TERMINATED || !this._tones || position >= this._tones.length) {\n          // Stop sending DTMF.\n          this._tones = null;\n\n          return;\n        }\n\n        var tone = this._tones[position];\n\n        position += 1;\n\n        if (tone === ',') {\n          timeout = 2000;\n        } else {\n          var dtmf = new RTCSession_DTMF(this);\n\n          options.eventHandlers = {\n            onFailed: function onFailed() {\n              _this5._tones = null;\n            }\n          };\n          dtmf.send(tone, options);\n          timeout = duration + interToneGap;\n        }\n\n        // Set timeout for the next tone.\n        setTimeout(_sendDTMF.bind(this), timeout);\n      }\n    }\n  }, {\n    key: 'sendInfo',\n    value: function sendInfo(contentType, body) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      debug('sendInfo()');\n\n      // Check Session Status.\n      if (this._status !== C.STATUS_CONFIRMED && this._status !== C.STATUS_WAITING_FOR_ACK) {\n        throw new Exceptions.InvalidStateError(this._status);\n      }\n\n      var info = new RTCSession_Info(this);\n\n      info.send(contentType, body, options);\n\n      return info;\n    }\n\n    /**\n     * Mute\n     */\n\n  }, {\n    key: 'mute',\n    value: function mute() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { audio: true, video: false };\n\n      debug('mute()');\n\n      var audioMuted = false,\n          videoMuted = false;\n\n      if (this._audioMuted === false && options.audio) {\n        audioMuted = true;\n        this._audioMuted = true;\n        this._toogleMuteAudio(true);\n      }\n\n      if (this._videoMuted === false && options.video) {\n        videoMuted = true;\n        this._videoMuted = true;\n        this._toogleMuteVideo(true);\n      }\n\n      if (audioMuted === true || videoMuted === true) {\n        this._onmute({\n          audio: audioMuted,\n          video: videoMuted\n        });\n      }\n    }\n\n    /**\n     * Unmute\n     */\n\n  }, {\n    key: 'unmute',\n    value: function unmute() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { audio: true, video: true };\n\n      debug('unmute()');\n\n      var audioUnMuted = false,\n          videoUnMuted = false;\n\n      if (this._audioMuted === true && options.audio) {\n        audioUnMuted = true;\n        this._audioMuted = false;\n\n        if (this._localHold === false) {\n          this._toogleMuteAudio(false);\n        }\n      }\n\n      if (this._videoMuted === true && options.video) {\n        videoUnMuted = true;\n        this._videoMuted = false;\n\n        if (this._localHold === false) {\n          this._toogleMuteVideo(false);\n        }\n      }\n\n      if (audioUnMuted === true || videoUnMuted === true) {\n        this._onunmute({\n          audio: audioUnMuted,\n          video: videoUnMuted\n        });\n      }\n    }\n\n    /**\n     * Hold\n     */\n\n  }, {\n    key: 'hold',\n    value: function hold() {\n      var _this6 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var done = arguments[1];\n\n      debug('hold()');\n\n      if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n        return false;\n      }\n\n      if (this._localHold === true) {\n        return false;\n      }\n\n      if (!this._isReadyToReOffer()) {\n        return false;\n      }\n\n      this._localHold = true;\n      this._onhold('local');\n\n      var eventHandlers = {\n        succeeded: function succeeded() {\n          if (done) {\n            done();\n          }\n        },\n        failed: function failed() {\n          _this6.terminate({\n            cause: SIP_C.causes.WEBRTC_ERROR,\n            status_code: 500,\n            reason_phrase: 'Hold Failed'\n          });\n        }\n      };\n\n      if (options.useUpdate) {\n        this._sendUpdate({\n          sdpOffer: true,\n          eventHandlers: eventHandlers,\n          extraHeaders: options.extraHeaders\n        });\n      } else {\n        this._sendReinvite({\n          eventHandlers: eventHandlers,\n          extraHeaders: options.extraHeaders\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: 'unhold',\n    value: function unhold() {\n      var _this7 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var done = arguments[1];\n\n      debug('unhold()');\n\n      if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n        return false;\n      }\n\n      if (this._localHold === false) {\n        return false;\n      }\n\n      if (!this._isReadyToReOffer()) {\n        return false;\n      }\n\n      this._localHold = false;\n      this._onunhold('local');\n\n      var eventHandlers = {\n        succeeded: function succeeded() {\n          if (done) {\n            done();\n          }\n        },\n        failed: function failed() {\n          _this7.terminate({\n            cause: SIP_C.causes.WEBRTC_ERROR,\n            status_code: 500,\n            reason_phrase: 'Unhold Failed'\n          });\n        }\n      };\n\n      if (options.useUpdate) {\n        this._sendUpdate({\n          sdpOffer: true,\n          eventHandlers: eventHandlers,\n          extraHeaders: options.extraHeaders\n        });\n      } else {\n        this._sendReinvite({\n          eventHandlers: eventHandlers,\n          extraHeaders: options.extraHeaders\n        });\n      }\n\n      return true;\n    }\n  }, {\n    key: 'renegotiate',\n    value: function renegotiate() {\n      var _this8 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var done = arguments[1];\n\n      debug('renegotiate()');\n\n      var rtcOfferConstraints = options.rtcOfferConstraints || null;\n\n      if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n        return false;\n      }\n\n      if (!this._isReadyToReOffer()) {\n        return false;\n      }\n\n      var eventHandlers = {\n        succeeded: function succeeded() {\n          if (done) {\n            done();\n          }\n        },\n        failed: function failed() {\n          _this8.terminate({\n            cause: SIP_C.causes.WEBRTC_ERROR,\n            status_code: 500,\n            reason_phrase: 'Media Renegotiation Failed'\n          });\n        }\n      };\n\n      this._setLocalMediaStatus();\n\n      if (options.useUpdate) {\n        this._sendUpdate({\n          sdpOffer: true,\n          eventHandlers: eventHandlers,\n          rtcOfferConstraints: rtcOfferConstraints,\n          extraHeaders: options.extraHeaders\n        });\n      } else {\n        this._sendReinvite({\n          eventHandlers: eventHandlers,\n          rtcOfferConstraints: rtcOfferConstraints,\n          extraHeaders: options.extraHeaders\n        });\n      }\n\n      return true;\n    }\n\n    /**\n     * Refer\n     */\n\n  }, {\n    key: 'refer',\n    value: function refer(target, options) {\n      var _this9 = this;\n\n      debug('refer()');\n\n      var originalTarget = target;\n\n      if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n        return false;\n      }\n\n      // Check target validity.\n      target = this._ua.normalizeTarget(target);\n      if (!target) {\n        throw new TypeError('Invalid target: ' + originalTarget);\n      }\n\n      var referSubscriber = new RTCSession_ReferSubscriber(this);\n\n      referSubscriber.sendRefer(target, options);\n\n      // Store in the map.\n      var id = referSubscriber.id;\n\n      this._referSubscribers[id] = referSubscriber;\n\n      // Listen for ending events so we can remove it from the map.\n      referSubscriber.on('requestFailed', function () {\n        delete _this9._referSubscribers[id];\n      });\n      referSubscriber.on('accepted', function () {\n        delete _this9._referSubscribers[id];\n      });\n      referSubscriber.on('failed', function () {\n        delete _this9._referSubscribers[id];\n      });\n\n      return referSubscriber;\n    }\n\n    /**\n     * Send a generic in-dialog Request\n     */\n\n  }, {\n    key: 'sendRequest',\n    value: function sendRequest(method, options) {\n      debug('sendRequest()');\n\n      return this._dialog.sendRequest(method, options);\n    }\n\n    /**\n     * In dialog Request Reception\n     */\n\n  }, {\n    key: 'receiveRequest',\n    value: function receiveRequest(request) {\n      var _this10 = this;\n\n      debug('receiveRequest()');\n\n      if (request.method === SIP_C.CANCEL) {\n        /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL\n        * was in progress and that the UAC MAY continue with the session established by\n        * any 2xx response, or MAY terminate with BYE. SIP does continue with the\n        * established session. So the CANCEL is processed only if the session is not yet\n        * established.\n        */\n\n        /*\n        * Terminate the whole session in case the user didn't accept (or yet send the answer)\n        * nor reject the request opening the session.\n        */\n        if (this._status === C.STATUS_WAITING_FOR_ANSWER || this._status === C.STATUS_ANSWERED) {\n          this._status = C.STATUS_CANCELED;\n          this._request.reply(487);\n          this._failed('remote', request, SIP_C.causes.CANCELED);\n        }\n      } else {\n        // Requests arriving here are in-dialog requests.\n        switch (request.method) {\n          case SIP_C.ACK:\n            if (this._status !== C.STATUS_WAITING_FOR_ACK) {\n              return;\n            }\n\n            // Update signaling status.\n            this._status = C.STATUS_CONFIRMED;\n\n            clearTimeout(this._timers.ackTimer);\n            clearTimeout(this._timers.invite2xxTimer);\n\n            if (this._late_sdp) {\n              if (!request.body) {\n                this.terminate({\n                  cause: SIP_C.causes.MISSING_SDP,\n                  status_code: 400\n                });\n                break;\n              }\n\n              var e = { originator: 'remote', type: 'answer', sdp: request.body };\n\n              debug('emit \"sdp\"');\n              this.emit('sdp', e);\n\n              var answer = new RTCSessionDescription({ type: 'answer', sdp: e.sdp });\n\n              this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n                return _this10._connection.setRemoteDescription(answer);\n              }).then(function () {\n                if (!_this10._is_confirmed) {\n                  _this10._confirmed('remote', request);\n                }\n              }).catch(function (error) {\n                _this10.terminate({\n                  cause: SIP_C.causes.BAD_MEDIA_DESCRIPTION,\n                  status_code: 488\n                });\n\n                debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n                _this10.emit('peerconnection:setremotedescriptionfailed', error);\n              });\n            } else if (!this._is_confirmed) {\n              this._confirmed('remote', request);\n            }\n\n            break;\n          case SIP_C.BYE:\n            if (this._status === C.STATUS_CONFIRMED) {\n              request.reply(200);\n              this._ended('remote', request, SIP_C.causes.BYE);\n            } else if (this._status === C.STATUS_INVITE_RECEIVED) {\n              request.reply(200);\n              this._request.reply(487, 'BYE Received');\n              this._ended('remote', request, SIP_C.causes.BYE);\n            } else {\n              request.reply(403, 'Wrong Status');\n            }\n            break;\n          case SIP_C.INVITE:\n            if (this._status === C.STATUS_CONFIRMED) {\n              if (request.hasHeader('replaces')) {\n                this._receiveReplaces(request);\n              } else {\n                this._receiveReinvite(request);\n              }\n            } else {\n              request.reply(403, 'Wrong Status');\n            }\n            break;\n          case SIP_C.INFO:\n            if (this._status === C.STATUS_1XX_RECEIVED || this._status === C.STATUS_WAITING_FOR_ANSWER || this._status === C.STATUS_ANSWERED || this._status === C.STATUS_WAITING_FOR_ACK || this._status === C.STATUS_CONFIRMED) {\n              var contentType = request.getHeader('content-type');\n\n              if (contentType && contentType.match(/^application\\/dtmf-relay/i)) {\n                new RTCSession_DTMF(this).init_incoming(request);\n              } else if (contentType !== undefined) {\n                new RTCSession_Info(this).init_incoming(request);\n              } else {\n                request.reply(415);\n              }\n            } else {\n              request.reply(403, 'Wrong Status');\n            }\n            break;\n          case SIP_C.UPDATE:\n            if (this._status === C.STATUS_CONFIRMED) {\n              this._receiveUpdate(request);\n            } else {\n              request.reply(403, 'Wrong Status');\n            }\n            break;\n          case SIP_C.REFER:\n            if (this._status === C.STATUS_CONFIRMED) {\n              this._receiveRefer(request);\n            } else {\n              request.reply(403, 'Wrong Status');\n            }\n            break;\n          case SIP_C.NOTIFY:\n            if (this._status === C.STATUS_CONFIRMED) {\n              this._receiveNotify(request);\n            } else {\n              request.reply(403, 'Wrong Status');\n            }\n            break;\n          default:\n            request.reply(501);\n        }\n      }\n    }\n\n    /**\n     * Session Callbacks\n     */\n\n  }, {\n    key: 'onTransportError',\n    value: function onTransportError() {\n      debugerror('onTransportError()');\n\n      if (this._status !== C.STATUS_TERMINATED) {\n        this.terminate({\n          status_code: 500,\n          reason_phrase: SIP_C.causes.CONNECTION_ERROR,\n          cause: SIP_C.causes.CONNECTION_ERROR\n        });\n      }\n    }\n  }, {\n    key: 'onRequestTimeout',\n    value: function onRequestTimeout() {\n      debugerror('onRequestTimeout()');\n\n      if (this._status !== C.STATUS_TERMINATED) {\n        this.terminate({\n          status_code: 408,\n          reason_phrase: SIP_C.causes.REQUEST_TIMEOUT,\n          cause: SIP_C.causes.REQUEST_TIMEOUT\n        });\n      }\n    }\n  }, {\n    key: 'onDialogError',\n    value: function onDialogError() {\n      debugerror('onDialogError()');\n\n      if (this._status !== C.STATUS_TERMINATED) {\n        this.terminate({\n          status_code: 500,\n          reason_phrase: SIP_C.causes.DIALOG_ERROR,\n          cause: SIP_C.causes.DIALOG_ERROR\n        });\n      }\n    }\n\n    // Called from DTMF handler.\n\n  }, {\n    key: 'newDTMF',\n    value: function newDTMF(data) {\n      debug('newDTMF()');\n\n      this.emit('newDTMF', data);\n    }\n\n    // Called from Info handler.\n\n  }, {\n    key: 'newInfo',\n    value: function newInfo(data) {\n      debug('newInfo()');\n\n      this.emit('newInfo', data);\n    }\n\n    /**\n     * Check if RTCSession is ready for an outgoing re-INVITE or UPDATE with SDP.\n     */\n\n  }, {\n    key: '_isReadyToReOffer',\n    value: function _isReadyToReOffer() {\n      if (!this._rtcReady) {\n        debug('_isReadyToReOffer() | internal WebRTC status not ready');\n\n        return false;\n      }\n\n      // No established yet.\n      if (!this._dialog) {\n        debug('_isReadyToReOffer() | session not established yet');\n\n        return false;\n      }\n\n      // Another INVITE transaction is in progress.\n      if (this._dialog.uac_pending_reply === true || this._dialog.uas_pending_reply === true) {\n        debug('_isReadyToReOffer() | there is another INVITE/UPDATE transaction in progress');\n\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: '_close',\n    value: function _close() {\n      debug('close()');\n\n      if (this._status === C.STATUS_TERMINATED) {\n        return;\n      }\n\n      this._status = C.STATUS_TERMINATED;\n\n      // Terminate RTC.\n      if (this._connection) {\n        try {\n          this._connection.close();\n        } catch (error) {\n          debugerror('close() | error closing the RTCPeerConnection: %o', error);\n        }\n      }\n\n      // Close local MediaStream if it was not given by the user.\n      if (this._localMediaStream && this._localMediaStreamLocallyGenerated) {\n        debug('close() | closing local MediaStream');\n\n        Utils.closeMediaStream(this._localMediaStream);\n      }\n\n      // Terminate signaling.\n\n      // Clear SIP timers.\n      for (var timer in this._timers) {\n        if (Object.prototype.hasOwnProperty.call(this._timers, timer)) {\n          clearTimeout(this._timers[timer]);\n        }\n      }\n\n      // Clear Session Timers.\n      clearTimeout(this._sessionTimers.timer);\n\n      // Terminate confirmed dialog.\n      if (this._dialog) {\n        this._dialog.terminate();\n        delete this._dialog;\n      }\n\n      // Terminate early dialogs.\n      for (var dialog in this._earlyDialogs) {\n        if (Object.prototype.hasOwnProperty.call(this._earlyDialogs, dialog)) {\n          this._earlyDialogs[dialog].terminate();\n          delete this._earlyDialogs[dialog];\n        }\n      }\n\n      // Terminate REFER subscribers.\n      for (var subscriber in this._referSubscribers) {\n        if (Object.prototype.hasOwnProperty.call(this._referSubscribers, subscriber)) {\n          delete this._referSubscribers[subscriber];\n        }\n      }\n\n      this._ua.destroyRTCSession(this);\n    }\n\n    /**\n     * Private API.\n     */\n\n    /**\n     * RFC3261 13.3.1.4\n     * Response retransmissions cannot be accomplished by transaction layer\n     *  since it is destroyed when receiving the first 2xx answer\n     */\n\n  }, {\n    key: '_setInvite2xxTimer',\n    value: function _setInvite2xxTimer(request, body) {\n      var timeout = Timers.T1;\n\n      function invite2xxRetransmission() {\n        if (this._status !== C.STATUS_WAITING_FOR_ACK) {\n          return;\n        }\n\n        request.reply(200, null, ['Contact: ' + this._contact], body);\n\n        if (timeout < Timers.T2) {\n          timeout = timeout * 2;\n          if (timeout > Timers.T2) {\n            timeout = Timers.T2;\n          }\n        }\n\n        this._timers.invite2xxTimer = setTimeout(invite2xxRetransmission.bind(this), timeout);\n      }\n\n      this._timers.invite2xxTimer = setTimeout(invite2xxRetransmission.bind(this), timeout);\n    }\n\n    /**\n     * RFC3261 14.2\n     * If a UAS generates a 2xx response and never receives an ACK,\n     *  it SHOULD generate a BYE to terminate the dialog.\n     */\n\n  }, {\n    key: '_setACKTimer',\n    value: function _setACKTimer() {\n      var _this11 = this;\n\n      this._timers.ackTimer = setTimeout(function () {\n        if (_this11._status === C.STATUS_WAITING_FOR_ACK) {\n          debug('no ACK received, terminating the session');\n\n          clearTimeout(_this11._timers.invite2xxTimer);\n          _this11.sendRequest(SIP_C.BYE);\n          _this11._ended('remote', null, SIP_C.causes.NO_ACK);\n        }\n      }, Timers.TIMER_H);\n    }\n  }, {\n    key: '_createRTCConnection',\n    value: function _createRTCConnection(pcConfig, rtcConstraints) {\n      var _this12 = this;\n\n      this._connection = new RTCPeerConnection(pcConfig, rtcConstraints);\n\n      this._connection.addEventListener('iceconnectionstatechange', function () {\n        var state = _this12._connection.iceConnectionState;\n\n        // TODO: Do more with different states.\n        if (state === 'failed') {\n          _this12.terminate({\n            cause: SIP_C.causes.RTP_TIMEOUT,\n            status_code: 408,\n            reason_phrase: SIP_C.causes.RTP_TIMEOUT\n          });\n        }\n      });\n\n      debug('emit \"peerconnection\"');\n\n      setTimeout(function () {\n        _this12.emit('peerconnection', {\n          peerconnection: _this12._connection\n        });\n      });\n    }\n  }, {\n    key: '_createLocalDescription',\n    value: function _createLocalDescription(type, constraints) {\n      var _this13 = this;\n\n      debug('createLocalDescription()');\n\n      if (type !== 'offer' && type !== 'answer') throw new Error('createLocalDescription() | invalid type \"' + type + '\"');\n\n      var connection = this._connection;\n\n      this._rtcReady = false;\n\n      return Promise.resolve()\n      // Create Offer or Answer.\n      .then(function () {\n        if (type === 'offer') {\n          return connection.createOffer(constraints).catch(function (error) {\n            debugerror('emit \"peerconnection:createofferfailed\" [error:%o]', error);\n\n            _this13.emit('peerconnection:createofferfailed', error);\n\n            return Promise.reject(error);\n          });\n        } else {\n          constraints.iceRestart = true;\n\n          return connection.createAnswer(constraints).catch(function (error) {\n            debugerror('emit \"peerconnection:createanswerfailed\" [error:%o]', error);\n\n            _this13.emit('peerconnection:createanswerfailed', error);\n\n            return Promise.reject(error);\n          });\n        }\n      })\n      // Set local description.\n      .then(function (desc) {\n        return connection.setLocalDescription(desc).catch(function (error) {\n          _this13._rtcReady = true;\n\n          debugerror('emit \"peerconnection:setlocaldescriptionfailed\" [error:%o]', error);\n\n          _this13.emit('peerconnection:setlocaldescriptionfailed', error);\n\n          return Promise.reject(error);\n        });\n      }).then(function () {\n        // setRemoteDescription will not restart ice immediately when renegotiation,\n        // and iceGatheringState stay complete for a while.\n        // We will get a local sdp without can ip candidates, if resolve right away.\n\n        // Resolve right away if 'pc.iceGatheringState' is 'complete'.\n        if (type === 'offer' && connection.iceGatheringState === 'complete') {\n          _this13._rtcReady = true;\n\n          var e = { originator: 'local', type: type, sdp: connection.localDescription.sdp };\n\n          debug('emit \"sdp\"');\n\n          _this13.emit('sdp', e);\n\n          return Promise.resolve(e.sdp);\n        }\n\n        // Add 'pc.onicencandidate' event handler to resolve on last candidate.\n        return new Promise(function (resolve) {\n          var finished = false;\n          var listener = void 0;\n\n          var ready = function ready() {\n            connection.removeEventListener('icecandidate', listener);\n\n            finished = true;\n            _this13._rtcReady = true;\n\n            var e = { originator: 'local', type: type, sdp: connection.localDescription.sdp };\n\n            debug('emit \"sdp\"');\n\n            _this13.emit('sdp', e);\n\n            resolve(e.sdp);\n          };\n\n          connection.addEventListener('icecandidate', listener = function listener(event) {\n            var candidate = event.candidate;\n\n            if (candidate) {\n              _this13.emit('icecandidate', {\n                candidate: candidate,\n                ready: ready\n              });\n            } else if (!finished) {\n              ready();\n            }\n          });\n        });\n      });\n    }\n\n    /**\n     * Dialog Management\n     */\n\n  }, {\n    key: '_createDialog',\n    value: function _createDialog(message, type, early) {\n      var local_tag = type === 'UAS' ? message.to_tag : message.from_tag;\n      var remote_tag = type === 'UAS' ? message.from_tag : message.to_tag;\n      var id = message.call_id + local_tag + remote_tag;\n\n      var early_dialog = this._earlyDialogs[id];\n\n      // Early Dialog.\n      if (early) {\n        if (early_dialog) {\n          return true;\n        } else {\n          early_dialog = new Dialog(this, message, type, Dialog.C.STATUS_EARLY);\n\n          // Dialog has been successfully created.\n          if (early_dialog.error) {\n            debug(early_dialog.error);\n            this._failed('remote', message, SIP_C.causes.INTERNAL_ERROR);\n\n            return false;\n          } else {\n            this._earlyDialogs[id] = early_dialog;\n\n            return true;\n          }\n        }\n      }\n\n      // Confirmed Dialog.\n      else {\n          this._from_tag = message.from_tag;\n          this._to_tag = message.to_tag;\n\n          // In case the dialog is in _early_ state, update it.\n          if (early_dialog) {\n            early_dialog.update(message, type);\n            this._dialog = early_dialog;\n            delete this._earlyDialogs[id];\n\n            return true;\n          }\n\n          // Otherwise, create a _confirmed_ dialog.\n          var dialog = new Dialog(this, message, type);\n\n          if (dialog.error) {\n            debug(dialog.error);\n            this._failed('remote', message, SIP_C.causes.INTERNAL_ERROR);\n\n            return false;\n          } else {\n            this._dialog = dialog;\n\n            return true;\n          }\n        }\n    }\n\n    /**\n     * In dialog INVITE Reception\n     */\n\n  }, {\n    key: '_receiveReinvite',\n    value: function _receiveReinvite(request) {\n      var _this14 = this;\n\n      debug('receiveReinvite()');\n\n      var contentType = request.getHeader('Content-Type');\n      var data = {\n        request: request,\n        callback: undefined,\n        reject: reject.bind(this)\n      };\n\n      var rejected = false;\n\n      function reject() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        rejected = true;\n\n        var status_code = options.status_code || 403;\n        var reason_phrase = options.reason_phrase || '';\n        var extraHeaders = Utils.cloneArray(options.extraHeaders);\n\n        if (this._status !== C.STATUS_CONFIRMED) {\n          return false;\n        }\n\n        if (status_code < 300 || status_code >= 700) {\n          throw new TypeError('Invalid status_code: ' + status_code);\n        }\n\n        request.reply(status_code, reason_phrase, extraHeaders);\n      }\n\n      // Emit 'reinvite'.\n      this.emit('reinvite', data);\n\n      if (rejected) {\n        return;\n      }\n\n      this._late_sdp = false;\n\n      // Request without SDP.\n      if (!request.body) {\n        this._late_sdp = true;\n\n        this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n          return _this14._createLocalDescription('offer', _this14._rtcOfferConstraints);\n        }).then(function (sdp) {\n          sendAnswer.call(_this14, sdp);\n        }).catch(function () {\n          request.reply(500);\n        });\n\n        return;\n      }\n\n      // Request with SDP.\n      if (contentType !== 'application/sdp') {\n        debug('invalid Content-Type');\n        request.reply(415);\n\n        return;\n      }\n\n      this._processInDialogSdpOffer(request)\n      // Send answer.\n      .then(function (desc) {\n        if (_this14._status === C.STATUS_TERMINATED) {\n          return;\n        }\n\n        sendAnswer.call(_this14, desc);\n      }).catch(function (error) {\n        debugerror(error);\n      });\n\n      function sendAnswer(desc) {\n        var _this15 = this;\n\n        var extraHeaders = ['Contact: ' + this._contact];\n\n        this._handleSessionTimersInIncomingRequest(request, extraHeaders);\n\n        if (this._late_sdp) {\n          desc = this._mangleOffer(desc);\n        }\n\n        request.reply(200, null, extraHeaders, desc, function () {\n          _this15._status = C.STATUS_WAITING_FOR_ACK;\n          _this15._setInvite2xxTimer(request, desc);\n          _this15._setACKTimer();\n        });\n\n        // If callback is given execute it.\n        if (typeof data.callback === 'function') {\n          data.callback();\n        }\n      }\n    }\n\n    /**\n     * In dialog UPDATE Reception\n     */\n\n  }, {\n    key: '_receiveUpdate',\n    value: function _receiveUpdate(request) {\n      var _this16 = this;\n\n      debug('receiveUpdate()');\n\n      var contentType = request.getHeader('Content-Type');\n      var data = {\n        request: request,\n        callback: undefined,\n        reject: reject.bind(this)\n      };\n\n      var rejected = false;\n\n      function reject() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        rejected = true;\n\n        var status_code = options.status_code || 403;\n        var reason_phrase = options.reason_phrase || '';\n        var extraHeaders = Utils.cloneArray(options.extraHeaders);\n\n        if (this._status !== C.STATUS_CONFIRMED) {\n          return false;\n        }\n\n        if (status_code < 300 || status_code >= 700) {\n          throw new TypeError('Invalid status_code: ' + status_code);\n        }\n\n        request.reply(status_code, reason_phrase, extraHeaders);\n      }\n\n      // Emit 'update'.\n      this.emit('update', data);\n\n      if (rejected) {\n        return;\n      }\n\n      if (!request.body) {\n        sendAnswer.call(this, null);\n\n        return;\n      }\n\n      if (contentType !== 'application/sdp') {\n        debug('invalid Content-Type');\n\n        request.reply(415);\n\n        return;\n      }\n\n      this._processInDialogSdpOffer(request)\n      // Send answer.\n      .then(function (desc) {\n        if (_this16._status === C.STATUS_TERMINATED) {\n          return;\n        }\n\n        sendAnswer.call(_this16, desc);\n      }).catch(function (error) {\n        debugerror(error);\n      });\n\n      function sendAnswer(desc) {\n        var extraHeaders = ['Contact: ' + this._contact];\n\n        this._handleSessionTimersInIncomingRequest(request, extraHeaders);\n\n        request.reply(200, null, extraHeaders, desc);\n\n        // If callback is given execute it.\n        if (typeof data.callback === 'function') {\n          data.callback();\n        }\n      }\n    }\n  }, {\n    key: '_processInDialogSdpOffer',\n    value: function _processInDialogSdpOffer(request) {\n      var _this17 = this;\n\n      debug('_processInDialogSdpOffer()');\n\n      var sdp = request.parseSDP();\n\n      var hold = false;\n\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = sdp.media[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var m = _step4.value;\n\n          if (holdMediaTypes.indexOf(m.type) === -1) {\n            continue;\n          }\n\n          var direction = m.direction || sdp.direction || 'sendrecv';\n\n          if (direction === 'sendonly' || direction === 'inactive') {\n            hold = true;\n          }\n          // If at least one of the streams is active don't emit 'hold'.\n          else {\n              hold = false;\n              break;\n            }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      var e = { originator: 'remote', type: 'offer', sdp: request.body };\n\n      debug('emit \"sdp\"');\n      this.emit('sdp', e);\n\n      var offer = new RTCSessionDescription({ type: 'offer', sdp: e.sdp });\n\n      this._connectionPromiseQueue = this._connectionPromiseQueue\n      // Set remote description.\n      .then(function () {\n        if (_this17._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        return _this17._connection.setRemoteDescription(offer).catch(function (error) {\n          request.reply(488);\n          debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n          _this17.emit('peerconnection:setremotedescriptionfailed', error);\n\n          throw new Error('peerconnection.setRemoteDescription() failed');\n        });\n      }).then(function () {\n        if (_this17._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        if (_this17._remoteHold === true && hold === false) {\n          _this17._remoteHold = false;\n          _this17._onunhold('remote');\n        } else if (_this17._remoteHold === false && hold === true) {\n          _this17._remoteHold = true;\n          _this17._onhold('remote');\n        }\n      })\n      // Create local description.\n      .then(function () {\n        if (_this17._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        return _this17._createLocalDescription('answer', _this17._rtcAnswerConstraints).catch(function () {\n          request.reply(500);\n\n          throw new Error('_createLocalDescription() failed');\n        });\n      });\n\n      return this._connectionPromiseQueue;\n    }\n\n    /**\n     * In dialog Refer Reception\n     */\n\n  }, {\n    key: '_receiveRefer',\n    value: function _receiveRefer(request) {\n      var _this18 = this;\n\n      debug('receiveRefer()');\n\n      if (_typeof(request.refer_to) === undefined) {\n        debug('no Refer-To header field present in REFER');\n        request.reply(400);\n\n        return;\n      }\n\n      if (request.refer_to.uri.scheme !== SIP_C.SIP) {\n        debug('Refer-To header field points to a non-SIP URI scheme');\n        request.reply(416);\n\n        return;\n      }\n\n      // Reply before the transaction timer expires.\n      request.reply(202);\n\n      var notifier = new RTCSession_ReferNotifier(this, request.cseq);\n\n      debug('emit \"refer\"');\n\n      // Emit 'refer'.\n      this.emit('refer', {\n        request: request,\n        accept: function accept(initCallback, options) {\n          _accept.call(_this18, initCallback, options);\n        },\n        reject: function reject() {\n          _reject.call(_this18);\n        }\n      });\n\n      function _accept(initCallback) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        initCallback = typeof initCallback === 'function' ? initCallback : null;\n\n        if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n          return false;\n        }\n\n        var session = new RTCSession(this._ua);\n\n        session.on('progress', function (_ref2) {\n          var response = _ref2.response;\n\n          notifier.notify(response.status_code, response.reason_phrase);\n        });\n\n        session.on('accepted', function (_ref3) {\n          var response = _ref3.response;\n\n          notifier.notify(response.status_code, response.reason_phrase);\n        });\n\n        session.on('failed', function (_ref4) {\n          var message = _ref4.message,\n              cause = _ref4.cause;\n\n          if (message) {\n            notifier.notify(message.status_code, message.reason_phrase);\n          } else {\n            notifier.notify(487, cause);\n          }\n        });\n\n        // Consider the Replaces header present in the Refer-To URI.\n        if (request.refer_to.uri.hasHeader('replaces')) {\n          var replaces = decodeURIComponent(request.refer_to.uri.getHeader('replaces'));\n\n          options.extraHeaders = Utils.cloneArray(options.extraHeaders);\n          options.extraHeaders.push('Replaces: ' + replaces);\n        }\n\n        session.connect(request.refer_to.uri.toAor(), options, initCallback);\n      }\n\n      function _reject() {\n        notifier.notify(603);\n      }\n    }\n\n    /**\n     * In dialog Notify Reception\n     */\n\n  }, {\n    key: '_receiveNotify',\n    value: function _receiveNotify(request) {\n      debug('receiveNotify()');\n\n      if (_typeof(request.event) === undefined) {\n        request.reply(400);\n      }\n\n      switch (request.event.event) {\n        case 'refer':\n          {\n            var id = void 0;\n            var referSubscriber = void 0;\n\n            if (request.event.params && request.event.params.id) {\n              id = request.event.params.id;\n              referSubscriber = this._referSubscribers[id];\n            } else if (Object.keys(this._referSubscribers).length === 1) {\n              referSubscriber = this._referSubscribers[Object.keys(this._referSubscribers)[0]];\n            } else {\n              request.reply(400, 'Missing event id parameter');\n\n              return;\n            }\n\n            if (!referSubscriber) {\n              request.reply(481, 'Subscription Does Not Exist');\n\n              return;\n            }\n\n            referSubscriber.receiveNotify(request);\n            request.reply(200);\n\n            break;\n          }\n\n        default:\n          {\n            request.reply(489);\n          }\n      }\n    }\n\n    /**\n     * INVITE with Replaces Reception\n     */\n\n  }, {\n    key: '_receiveReplaces',\n    value: function _receiveReplaces(request) {\n      var _this20 = this;\n\n      debug('receiveReplaces()');\n\n      function _accept2(initCallback) {\n        var _this19 = this;\n\n        if (this._status !== C.STATUS_WAITING_FOR_ACK && this._status !== C.STATUS_CONFIRMED) {\n          return false;\n        }\n\n        var session = new RTCSession(this._ua);\n\n        // Terminate the current session when the new one is confirmed.\n        session.on('confirmed', function () {\n          _this19.terminate();\n        });\n\n        session.init_incoming(request, initCallback);\n      }\n\n      function _reject2() {\n        debug('Replaced INVITE rejected by the user');\n        request.reply(486);\n      }\n\n      // Emit 'replace'.\n      this.emit('replaces', {\n        request: request,\n        accept: function accept(initCallback) {\n          _accept2.call(_this20, initCallback);\n        },\n        reject: function reject() {\n          _reject2.call(_this20);\n        }\n      });\n    }\n\n    /**\n     * Initial Request Sender\n     */\n\n  }, {\n    key: '_sendInitialRequest',\n    value: function _sendInitialRequest(mediaConstraints, rtcOfferConstraints, mediaStream) {\n      var _this21 = this;\n\n      var request_sender = new RequestSender(this._ua, this._request, {\n        onRequestTimeout: function onRequestTimeout() {\n          _this21.onRequestTimeout();\n        },\n        onTransportError: function onTransportError() {\n          _this21.onTransportError();\n        },\n        // Update the request on authentication.\n        onAuthenticated: function onAuthenticated(request) {\n          _this21._request = request;\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          _this21._receiveInviteResponse(response);\n        }\n      });\n\n      if (this._withoutSDP) {\n        this._status = C.STATUS_INVITE_SENT;\n\n        return request_sender.send();\n      }\n\n      Promise.resolve()\n      // Get a stream if required.\n      .then(function () {\n        // A local MediaStream is given, use it.\n        if (mediaStream) {\n          return mediaStream;\n        }\n\n        // Request for user media access.\n        else if (mediaConstraints.audio || mediaConstraints.video) {\n            _this21._localMediaStreamLocallyGenerated = true;\n\n            return navigator.mediaDevices.getUserMedia(mediaConstraints).catch(function (error) {\n              if (_this21._status === C.STATUS_TERMINATED) {\n                throw new Error('terminated');\n              }\n\n              _this21._failed('local', null, SIP_C.causes.USER_DENIED_MEDIA_ACCESS);\n\n              debugerror('emit \"getusermediafailed\" [error:%o]', error);\n\n              _this21.emit('getusermediafailed');\n\n              throw new Error('getUserMedia() failed');\n            });\n          }\n      }).then(function (stream) {\n        if (_this21._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        _this21._localMediaStream = stream;\n        if (stream) {\n          _this21._connection.addStream(stream);\n        }\n\n        // TODO: should this be triggered here?\n        _this21._connecting(_this21._request);\n\n        return _this21._createLocalDescription('offer', rtcOfferConstraints).catch(function () {\n          _this21._failed('local', null, SIP_C.causes.WEBRTC_ERROR);\n\n          throw new Error('_createLocalDescription() failed');\n        });\n      }).then(function (desc) {\n        if (_this21._is_canceled || _this21._status === C.STATUS_TERMINATED) {\n          throw new Error('terminated');\n        }\n\n        _this21._request.body = desc;\n        _this21._status = C.STATUS_INVITE_SENT;\n\n        debug('emit \"sending\" [request:%o]', _this21._request);\n\n        // Emit 'sending' so the app can mangle the body before the request is sent.\n        _this21.emit('sending', {\n          request: _this21._request\n        });\n\n        request_sender.send();\n      }).catch(function (error) {\n        if (_this21._status === C.STATUS_TERMINATED) {\n          return;\n        }\n\n        debugerror(error);\n      });\n    }\n\n    /**\n     * Reception of Response for Initial INVITE\n     */\n\n  }, {\n    key: '_receiveInviteResponse',\n    value: function _receiveInviteResponse(response) {\n      var _this22 = this;\n\n      debug('receiveInviteResponse()');\n\n      // Handle 2XX retransmissions and responses from forked requests.\n      if (this._dialog && response.status_code >= 200 && response.status_code <= 299) {\n\n        /*\n         * If it is a retransmission from the endpoint that established\n         * the dialog, send an ACK\n         */\n        if (this._dialog.id.call_id === response.call_id && this._dialog.id.local_tag === response.from_tag && this._dialog.id.remote_tag === response.to_tag) {\n          this.sendRequest(SIP_C.ACK);\n\n          return;\n        }\n\n        // If not, send an ACK  and terminate.\n        else {\n            var dialog = new Dialog(this, response, 'UAC');\n\n            if (dialog.error !== undefined) {\n              debug(dialog.error);\n\n              return;\n            }\n\n            this.sendRequest(SIP_C.ACK);\n            this.sendRequest(SIP_C.BYE);\n\n            return;\n          }\n      }\n\n      // Proceed to cancellation if the user requested.\n      if (this._is_canceled) {\n        if (response.status_code >= 100 && response.status_code < 200) {\n          this._request.cancel(this._cancel_reason);\n        } else if (response.status_code >= 200 && response.status_code < 299) {\n          this._acceptAndTerminate(response);\n        }\n\n        return;\n      }\n\n      if (this._status !== C.STATUS_INVITE_SENT && this._status !== C.STATUS_1XX_RECEIVED) {\n        return;\n      }\n\n      switch (true) {\n        case /^100$/.test(response.status_code):\n          this._status = C.STATUS_1XX_RECEIVED;\n          break;\n\n        case /^1[0-9]{2}$/.test(response.status_code):\n          {\n            // Do nothing with 1xx responses without To tag.\n            if (!response.to_tag) {\n              debug('1xx response received without to tag');\n              break;\n            }\n\n            // Create Early Dialog if 1XX comes with contact.\n            if (response.hasHeader('contact')) {\n              // An error on dialog creation will fire 'failed' event.\n              if (!this._createDialog(response, 'UAC', true)) {\n                break;\n              }\n            }\n\n            this._status = C.STATUS_1XX_RECEIVED;\n            this._progress('remote', response);\n\n            if (!response.body) {\n              break;\n            }\n\n            var e = { originator: 'remote', type: 'answer', sdp: response.body };\n\n            debug('emit \"sdp\"');\n            this.emit('sdp', e);\n\n            var answer = new RTCSessionDescription({ type: 'answer', sdp: e.sdp });\n\n            this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n              return _this22._connection.setRemoteDescription(answer);\n            }).catch(function (error) {\n              debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n              _this22.emit('peerconnection:setremotedescriptionfailed', error);\n            });\n            break;\n          }\n\n        case /^2[0-9]{2}$/.test(response.status_code):\n          {\n            this._status = C.STATUS_CONFIRMED;\n\n            if (!response.body && !this._withoutSDP) {\n              this._acceptAndTerminate(response, 400, SIP_C.causes.MISSING_SDP);\n              this._failed('remote', response, SIP_C.causes.BAD_MEDIA_DESCRIPTION);\n              break;\n            }\n\n            // An error on dialog creation will fire 'failed' event.\n            if (!this._createDialog(response, 'UAC')) {\n              break;\n            }\n\n            if (this._withoutSDP) {\n              // Handle Session Timers.\n              this._handleSessionTimersInIncomingResponse(response);\n\n              this._accepted('remote', response);\n              this.sendRequest(SIP_C.ACK);\n              this._confirmed('local', null);\n              break;\n            }\n\n            var _e = { originator: 'remote', type: 'answer', sdp: response.body };\n\n            debug('emit \"sdp\"');\n            this.emit('sdp', _e);\n\n            var _answer = new RTCSessionDescription({ type: 'answer', sdp: _e.sdp });\n\n            this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n              // Be ready for 200 with SDP after a 180/183 with SDP.\n              // We created a SDP 'answer' for it, so check the current signaling state.\n              if (_this22._connection.signalingState === 'stable') {\n                return _this22._connection.createOffer().then(function (offer) {\n                  return _this22._connection.setLocalDescription(offer);\n                }).catch(function (error) {\n                  _this22._acceptAndTerminate(response, 500, error.toString());\n                  _this22._failed('local', response, SIP_C.causes.WEBRTC_ERROR);\n                });\n              }\n            }).then(function () {\n              _this22._connection.setRemoteDescription(_answer).then(function () {\n                // Handle Session Timers.\n                _this22._handleSessionTimersInIncomingResponse(response);\n\n                _this22._accepted('remote', response);\n                _this22.sendRequest(SIP_C.ACK);\n                _this22._confirmed('local', null);\n              }).catch(function (error) {\n                _this22._acceptAndTerminate(response, 488, 'Not Acceptable Here');\n                _this22._failed('remote', response, SIP_C.causes.BAD_MEDIA_DESCRIPTION);\n\n                debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n                _this22.emit('peerconnection:setremotedescriptionfailed', error);\n              });\n            });\n            break;\n          }\n\n        default:\n          {\n            var cause = Utils.sipErrorCause(response.status_code);\n\n            this._failed('remote', response, cause);\n          }\n      }\n    }\n\n    /**\n     * Send Re-INVITE\n     */\n\n  }, {\n    key: '_sendReinvite',\n    value: function _sendReinvite() {\n      var _this23 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      debug('sendReinvite()');\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var eventHandlers = options.eventHandlers || {};\n      var rtcOfferConstraints = options.rtcOfferConstraints || this._rtcOfferConstraints || null;\n\n      var succeeded = false;\n\n      extraHeaders.push('Contact: ' + this._contact);\n      extraHeaders.push('Content-Type: application/sdp');\n\n      // Session Timers.\n      if (this._sessionTimers.running) {\n        extraHeaders.push('Session-Expires: ' + this._sessionTimers.currentExpires + ';refresher=' + (this._sessionTimers.refresher ? 'uac' : 'uas'));\n      }\n\n      this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n        return _this23._createLocalDescription('offer', rtcOfferConstraints);\n      }).then(function (sdp) {\n        sdp = _this23._mangleOffer(sdp);\n\n        _this23.sendRequest(SIP_C.INVITE, {\n          extraHeaders: extraHeaders,\n          body: sdp,\n          eventHandlers: {\n            onSuccessResponse: function onSuccessResponse(response) {\n              onSucceeded.call(_this23, response);\n              succeeded = true;\n            },\n            onErrorResponse: function onErrorResponse(response) {\n              onFailed.call(_this23, response);\n            },\n            onTransportError: function onTransportError() {\n              _this23.onTransportError(); // Do nothing because session ends.\n            },\n            onRequestTimeout: function onRequestTimeout() {\n              _this23.onRequestTimeout(); // Do nothing because session ends.\n            },\n            onDialogError: function onDialogError() {\n              _this23.onDialogError(); // Do nothing because session ends.\n            }\n          }\n        });\n      }).catch(function () {\n        onFailed();\n      });\n\n      function onSucceeded(response) {\n        var _this24 = this;\n\n        if (this._status === C.STATUS_TERMINATED) {\n          return;\n        }\n\n        this.sendRequest(SIP_C.ACK);\n\n        // If it is a 2XX retransmission exit now.\n        if (succeeded) {\n          return;\n        }\n\n        // Handle Session Timers.\n        this._handleSessionTimersInIncomingResponse(response);\n\n        // Must have SDP answer.\n        if (!response.body) {\n          onFailed.call(this);\n\n          return;\n        } else if (response.getHeader('Content-Type') !== 'application/sdp') {\n          onFailed.call(this);\n\n          return;\n        }\n\n        var e = { originator: 'remote', type: 'answer', sdp: response.body };\n\n        debug('emit \"sdp\"');\n        this.emit('sdp', e);\n\n        var answer = new RTCSessionDescription({ type: 'answer', sdp: e.sdp });\n\n        this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n          return _this24._connection.setRemoteDescription(answer);\n        }).then(function () {\n          if (eventHandlers.succeeded) {\n            eventHandlers.succeeded(response);\n          }\n        }).catch(function (error) {\n          onFailed.call(_this24);\n\n          debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n          _this24.emit('peerconnection:setremotedescriptionfailed', error);\n        });\n      }\n\n      function onFailed(response) {\n        if (eventHandlers.failed) {\n          eventHandlers.failed(response);\n        }\n      }\n    }\n\n    /**\n     * Send UPDATE\n     */\n\n  }, {\n    key: '_sendUpdate',\n    value: function _sendUpdate() {\n      var _this25 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      debug('sendUpdate()');\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var eventHandlers = options.eventHandlers || {};\n      var rtcOfferConstraints = options.rtcOfferConstraints || this._rtcOfferConstraints || null;\n      var sdpOffer = options.sdpOffer || false;\n\n      var succeeded = false;\n\n      extraHeaders.push('Contact: ' + this._contact);\n\n      // Session Timers.\n      if (this._sessionTimers.running) {\n        extraHeaders.push('Session-Expires: ' + this._sessionTimers.currentExpires + ';refresher=' + (this._sessionTimers.refresher ? 'uac' : 'uas'));\n      }\n\n      if (sdpOffer) {\n        extraHeaders.push('Content-Type: application/sdp');\n\n        this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n          return _this25._createLocalDescription('offer', rtcOfferConstraints);\n        }).then(function (sdp) {\n          sdp = _this25._mangleOffer(sdp);\n\n          _this25.sendRequest(SIP_C.UPDATE, {\n            extraHeaders: extraHeaders,\n            body: sdp,\n            eventHandlers: {\n              onSuccessResponse: function onSuccessResponse(response) {\n                onSucceeded.call(_this25, response);\n                succeeded = true;\n              },\n              onErrorResponse: function onErrorResponse(response) {\n                onFailed.call(_this25, response);\n              },\n              onTransportError: function onTransportError() {\n                _this25.onTransportError(); // Do nothing because session ends.\n              },\n              onRequestTimeout: function onRequestTimeout() {\n                _this25.onRequestTimeout(); // Do nothing because session ends.\n              },\n              onDialogError: function onDialogError() {\n                _this25.onDialogError(); // Do nothing because session ends.\n              }\n            }\n          });\n        }).catch(function () {\n          onFailed.call(_this25);\n        });\n      }\n\n      // No SDP.\n      else {\n          this.sendRequest(SIP_C.UPDATE, {\n            extraHeaders: extraHeaders,\n            eventHandlers: {\n              onSuccessResponse: function onSuccessResponse(response) {\n                onSucceeded.call(_this25, response);\n              },\n              onErrorResponse: function onErrorResponse(response) {\n                onFailed.call(_this25, response);\n              },\n              onTransportError: function onTransportError() {\n                _this25.onTransportError(); // Do nothing because session ends.\n              },\n              onRequestTimeout: function onRequestTimeout() {\n                _this25.onRequestTimeout(); // Do nothing because session ends.\n              },\n              onDialogError: function onDialogError() {\n                _this25.onDialogError(); // Do nothing because session ends.\n              }\n            }\n          });\n        }\n\n      function onSucceeded(response) {\n        var _this26 = this;\n\n        if (this._status === C.STATUS_TERMINATED) {\n          return;\n        }\n\n        // If it is a 2XX retransmission exit now.\n        if (succeeded) {\n          return;\n        }\n\n        // Handle Session Timers.\n        this._handleSessionTimersInIncomingResponse(response);\n\n        // Must have SDP answer.\n        if (sdpOffer) {\n          if (!response.body) {\n            onFailed.call(this);\n\n            return;\n          } else if (response.getHeader('Content-Type') !== 'application/sdp') {\n            onFailed.call(this);\n\n            return;\n          }\n\n          var e = { originator: 'remote', type: 'answer', sdp: response.body };\n\n          debug('emit \"sdp\"');\n          this.emit('sdp', e);\n\n          var answer = new RTCSessionDescription({ type: 'answer', sdp: e.sdp });\n\n          this._connectionPromiseQueue = this._connectionPromiseQueue.then(function () {\n            return _this26._connection.setRemoteDescription(answer);\n          }).then(function () {\n            if (eventHandlers.succeeded) {\n              eventHandlers.succeeded(response);\n            }\n          }).catch(function (error) {\n            onFailed.call(_this26);\n\n            debugerror('emit \"peerconnection:setremotedescriptionfailed\" [error:%o]', error);\n\n            _this26.emit('peerconnection:setremotedescriptionfailed', error);\n          });\n        }\n        // No SDP answer.\n        else if (eventHandlers.succeeded) {\n            eventHandlers.succeeded(response);\n          }\n      }\n\n      function onFailed(response) {\n        if (eventHandlers.failed) {\n          eventHandlers.failed(response);\n        }\n      }\n    }\n  }, {\n    key: '_acceptAndTerminate',\n    value: function _acceptAndTerminate(response, status_code, reason_phrase) {\n      debug('acceptAndTerminate()');\n\n      var extraHeaders = [];\n\n      if (status_code) {\n        reason_phrase = reason_phrase || SIP_C.REASON_PHRASE[status_code] || '';\n        extraHeaders.push('Reason: SIP ;cause=' + status_code + '; text=\"' + reason_phrase + '\"');\n      }\n\n      // An error on dialog creation will fire 'failed' event.\n      if (this._dialog || this._createDialog(response, 'UAC')) {\n        this.sendRequest(SIP_C.ACK);\n        this.sendRequest(SIP_C.BYE, {\n          extraHeaders: extraHeaders\n        });\n      }\n\n      // Update session status.\n      this._status = C.STATUS_TERMINATED;\n    }\n\n    /**\n     * Correctly set the SDP direction attributes if the call is on local hold\n     */\n\n  }, {\n    key: '_mangleOffer',\n    value: function _mangleOffer(sdp) {\n\n      if (!this._localHold && !this._remoteHold) {\n        return sdp;\n      }\n\n      sdp = sdp_transform.parse(sdp);\n\n      // Local hold.\n      if (this._localHold && !this._remoteHold) {\n        debug('mangleOffer() | me on hold, mangling offer');\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = sdp.media[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var m = _step5.value;\n\n            if (holdMediaTypes.indexOf(m.type) === -1) {\n              continue;\n            }\n            if (!m.direction) {\n              m.direction = 'sendonly';\n            } else if (m.direction === 'sendrecv') {\n              m.direction = 'sendonly';\n            } else if (m.direction === 'recvonly') {\n              m.direction = 'inactive';\n            }\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n      }\n      // Local and remote hold.\n      else if (this._localHold && this._remoteHold) {\n          debug('mangleOffer() | both on hold, mangling offer');\n          var _iteratorNormalCompletion6 = true;\n          var _didIteratorError6 = false;\n          var _iteratorError6 = undefined;\n\n          try {\n            for (var _iterator6 = sdp.media[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n              var _m = _step6.value;\n\n              if (holdMediaTypes.indexOf(_m.type) === -1) {\n                continue;\n              }\n              _m.direction = 'inactive';\n            }\n          } catch (err) {\n            _didIteratorError6 = true;\n            _iteratorError6 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                _iterator6.return();\n              }\n            } finally {\n              if (_didIteratorError6) {\n                throw _iteratorError6;\n              }\n            }\n          }\n        }\n        // Remote hold.\n        else if (this._remoteHold) {\n            debug('mangleOffer() | remote on hold, mangling offer');\n            var _iteratorNormalCompletion7 = true;\n            var _didIteratorError7 = false;\n            var _iteratorError7 = undefined;\n\n            try {\n              for (var _iterator7 = sdp.media[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                var _m2 = _step7.value;\n\n                if (holdMediaTypes.indexOf(_m2.type) === -1) {\n                  continue;\n                }\n                if (!_m2.direction) {\n                  _m2.direction = 'recvonly';\n                } else if (_m2.direction === 'sendrecv') {\n                  _m2.direction = 'recvonly';\n                } else if (_m2.direction === 'recvonly') {\n                  _m2.direction = 'inactive';\n                }\n              }\n            } catch (err) {\n              _didIteratorError7 = true;\n              _iteratorError7 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                  _iterator7.return();\n                }\n              } finally {\n                if (_didIteratorError7) {\n                  throw _iteratorError7;\n                }\n              }\n            }\n          }\n\n      return sdp_transform.write(sdp);\n    }\n  }, {\n    key: '_setLocalMediaStatus',\n    value: function _setLocalMediaStatus() {\n      var enableAudio = true,\n          enableVideo = true;\n\n      if (this._localHold || this._remoteHold) {\n        enableAudio = false;\n        enableVideo = false;\n      }\n\n      if (this._audioMuted) {\n        enableAudio = false;\n      }\n\n      if (this._videoMuted) {\n        enableVideo = false;\n      }\n\n      this._toogleMuteAudio(!enableAudio);\n      this._toogleMuteVideo(!enableVideo);\n    }\n\n    /**\n     * Handle SessionTimers for an incoming INVITE or UPDATE.\n     * @param  {IncomingRequest} request\n     * @param  {Array} responseExtraHeaders  Extra headers for the 200 response.\n     */\n\n  }, {\n    key: '_handleSessionTimersInIncomingRequest',\n    value: function _handleSessionTimersInIncomingRequest(request, responseExtraHeaders) {\n      if (!this._sessionTimers.enabled) {\n        return;\n      }\n\n      var session_expires_refresher = void 0;\n\n      if (request.session_expires && request.session_expires >= SIP_C.MIN_SESSION_EXPIRES) {\n        this._sessionTimers.currentExpires = request.session_expires;\n        session_expires_refresher = request.session_expires_refresher || 'uas';\n      } else {\n        this._sessionTimers.currentExpires = this._sessionTimers.defaultExpires;\n        session_expires_refresher = 'uas';\n      }\n\n      responseExtraHeaders.push('Session-Expires: ' + this._sessionTimers.currentExpires + ';refresher=' + session_expires_refresher);\n\n      this._sessionTimers.refresher = session_expires_refresher === 'uas';\n      this._runSessionTimer();\n    }\n\n    /**\n     * Handle SessionTimers for an incoming response to INVITE or UPDATE.\n     * @param  {IncomingResponse} response\n     */\n\n  }, {\n    key: '_handleSessionTimersInIncomingResponse',\n    value: function _handleSessionTimersInIncomingResponse(response) {\n      if (!this._sessionTimers.enabled) {\n        return;\n      }\n\n      var session_expires_refresher = void 0;\n\n      if (response.session_expires && response.session_expires >= SIP_C.MIN_SESSION_EXPIRES) {\n        this._sessionTimers.currentExpires = response.session_expires;\n        session_expires_refresher = response.session_expires_refresher || 'uac';\n      } else {\n        this._sessionTimers.currentExpires = this._sessionTimers.defaultExpires;\n        session_expires_refresher = 'uac';\n      }\n\n      this._sessionTimers.refresher = session_expires_refresher === 'uac';\n      this._runSessionTimer();\n    }\n  }, {\n    key: '_runSessionTimer',\n    value: function _runSessionTimer() {\n      var _this27 = this;\n\n      var expires = this._sessionTimers.currentExpires;\n\n      this._sessionTimers.running = true;\n\n      clearTimeout(this._sessionTimers.timer);\n\n      // I'm the refresher.\n      if (this._sessionTimers.refresher) {\n        this._sessionTimers.timer = setTimeout(function () {\n          if (_this27._status === C.STATUS_TERMINATED) {\n            return;\n          }\n\n          debug('runSessionTimer() | sending session refresh request');\n\n          if (_this27._sessionTimers.refreshMethod === SIP_C.UPDATE) {\n            _this27._sendUpdate();\n          } else {\n            _this27._sendReinvite();\n          }\n        }, expires * 500); // Half the given interval (as the RFC states).\n      }\n\n      // I'm not the refresher.\n      else {\n          this._sessionTimers.timer = setTimeout(function () {\n            if (_this27._status === C.STATUS_TERMINATED) {\n              return;\n            }\n\n            debugerror('runSessionTimer() | timer expired, terminating the session');\n\n            _this27.terminate({\n              cause: SIP_C.causes.REQUEST_TIMEOUT,\n              status_code: 408,\n              reason_phrase: 'Session Timer Expired'\n            });\n          }, expires * 1100);\n        }\n    }\n  }, {\n    key: '_toogleMuteAudio',\n    value: function _toogleMuteAudio(mute) {\n      var streams = this._connection.getLocalStreams();\n\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = streams[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var stream = _step8.value;\n\n          var tracks = stream.getAudioTracks();\n\n          var _iteratorNormalCompletion9 = true;\n          var _didIteratorError9 = false;\n          var _iteratorError9 = undefined;\n\n          try {\n            for (var _iterator9 = tracks[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n              var track = _step9.value;\n\n              track.enabled = !mute;\n            }\n          } catch (err) {\n            _didIteratorError9 = true;\n            _iteratorError9 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion9 && _iterator9.return) {\n                _iterator9.return();\n              }\n            } finally {\n              if (_didIteratorError9) {\n                throw _iteratorError9;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n  }, {\n    key: '_toogleMuteVideo',\n    value: function _toogleMuteVideo(mute) {\n      var streams = this._connection.getLocalStreams();\n\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = streams[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var stream = _step10.value;\n\n          var tracks = stream.getVideoTracks();\n\n          var _iteratorNormalCompletion11 = true;\n          var _didIteratorError11 = false;\n          var _iteratorError11 = undefined;\n\n          try {\n            for (var _iterator11 = tracks[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n              var track = _step11.value;\n\n              track.enabled = !mute;\n            }\n          } catch (err) {\n            _didIteratorError11 = true;\n            _iteratorError11 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion11 && _iterator11.return) {\n                _iterator11.return();\n              }\n            } finally {\n              if (_didIteratorError11) {\n                throw _iteratorError11;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n  }, {\n    key: '_newRTCSession',\n    value: function _newRTCSession(originator, request) {\n      debug('newRTCSession()');\n\n      this._ua.newRTCSession(this, {\n        originator: originator,\n        session: this,\n        request: request\n      });\n    }\n  }, {\n    key: '_connecting',\n    value: function _connecting(request) {\n      debug('session connecting');\n\n      debug('emit \"connecting\"');\n\n      this.emit('connecting', {\n        request: request\n      });\n    }\n  }, {\n    key: '_progress',\n    value: function _progress(originator, response) {\n      debug('session progress');\n\n      debug('emit \"progress\"');\n\n      this.emit('progress', {\n        originator: originator,\n        response: response || null\n      });\n    }\n  }, {\n    key: '_accepted',\n    value: function _accepted(originator, message) {\n      debug('session accepted');\n\n      this._start_time = new Date();\n\n      debug('emit \"accepted\"');\n\n      this.emit('accepted', {\n        originator: originator,\n        response: message || null\n      });\n    }\n  }, {\n    key: '_confirmed',\n    value: function _confirmed(originator, ack) {\n      debug('session confirmed');\n\n      this._is_confirmed = true;\n\n      debug('emit \"confirmed\"');\n\n      this.emit('confirmed', {\n        originator: originator,\n        ack: ack || null\n      });\n    }\n  }, {\n    key: '_ended',\n    value: function _ended(originator, message, cause) {\n      debug('session ended');\n\n      this._end_time = new Date();\n\n      this._close();\n\n      debug('emit \"ended\"');\n\n      this.emit('ended', {\n        originator: originator,\n        message: message || null,\n        cause: cause\n      });\n    }\n  }, {\n    key: '_failed',\n    value: function _failed(originator, message, cause) {\n      debug('session failed');\n\n      this._close();\n\n      debug('emit \"failed\"');\n\n      this.emit('failed', {\n        originator: originator,\n        message: message || null,\n        cause: cause\n      });\n    }\n  }, {\n    key: '_onhold',\n    value: function _onhold(originator) {\n      debug('session onhold');\n\n      this._setLocalMediaStatus();\n\n      debug('emit \"hold\"');\n\n      this.emit('hold', {\n        originator: originator\n      });\n    }\n  }, {\n    key: '_onunhold',\n    value: function _onunhold(originator) {\n      debug('session onunhold');\n\n      this._setLocalMediaStatus();\n\n      debug('emit \"unhold\"');\n\n      this.emit('unhold', {\n        originator: originator\n      });\n    }\n  }, {\n    key: '_onmute',\n    value: function _onmute(_ref5) {\n      var audio = _ref5.audio,\n          video = _ref5.video;\n\n      debug('session onmute');\n\n      this._setLocalMediaStatus();\n\n      debug('emit \"muted\"');\n\n      this.emit('muted', {\n        audio: audio,\n        video: video\n      });\n    }\n  }, {\n    key: '_onunmute',\n    value: function _onunmute(_ref6) {\n      var audio = _ref6.audio,\n          video = _ref6.video;\n\n      debug('session onunmute');\n\n      this._setLocalMediaStatus();\n\n      debug('emit \"unmuted\"');\n\n      this.emit('unmuted', {\n        audio: audio,\n        video: video\n      });\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n\n    // Expose session failed/ended causes as a property of the RTCSession instance.\n\n  }, {\n    key: 'causes',\n    get: function get() {\n      return SIP_C.causes;\n    }\n  }, {\n    key: 'id',\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: 'connection',\n    get: function get() {\n      return this._connection;\n    }\n  }, {\n    key: 'direction',\n    get: function get() {\n      return this._direction;\n    }\n  }, {\n    key: 'local_identity',\n    get: function get() {\n      return this._local_identity;\n    }\n  }, {\n    key: 'remote_identity',\n    get: function get() {\n      return this._remote_identity;\n    }\n  }, {\n    key: 'start_time',\n    get: function get() {\n      return this._start_time;\n    }\n  }, {\n    key: 'end_time',\n    get: function get() {\n      return this._end_time;\n    }\n  }, {\n    key: 'data',\n    get: function get() {\n      return this._data;\n    },\n    set: function set(_data) {\n      this._data = _data;\n    }\n  }, {\n    key: 'status',\n    get: function get() {\n      return this._status;\n    }\n  }]);\n\n  return RTCSession;\n}(EventEmitter);\n\n//# sourceURL=webpack://ApolloSIP/./lib/RTCSession.js?");

/***/ }),

/***/ "./lib/RTCSession/DTMF.js":
/*!********************************!*\
  !*** ./lib/RTCSession/DTMF.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar SIP_C = __webpack_require__(/*! ../Constants */ \"./lib/Constants.js\");\nvar Exceptions = __webpack_require__(/*! ../Exceptions */ \"./lib/Exceptions.js\");\nvar Utils = __webpack_require__(/*! ../Utils */ \"./lib/Utils.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:RTCSession:DTMF');\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:ERROR:RTCSession:DTMF');\n\ndebugerror.log = console.warn.bind(console);\n\nvar C = {\n  MIN_DURATION: 70,\n  MAX_DURATION: 6000,\n  DEFAULT_DURATION: 100,\n  MIN_INTER_TONE_GAP: 50,\n  DEFAULT_INTER_TONE_GAP: 500\n};\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(DTMF, _EventEmitter);\n\n  function DTMF(session) {\n    _classCallCheck(this, DTMF);\n\n    var _this = _possibleConstructorReturn(this, (DTMF.__proto__ || Object.getPrototypeOf(DTMF)).call(this));\n\n    _this._session = session;\n    _this._direction = null;\n    _this._tone = null;\n    _this._duration = null;\n    _this._request = null;\n    return _this;\n  }\n\n  _createClass(DTMF, [{\n    key: 'send',\n    value: function send(tone) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (tone === undefined) {\n        throw new TypeError('Not enough arguments');\n      }\n\n      this._direction = 'outgoing';\n\n      // Check RTCSession Status.\n      if (this._session.status !== this._session.C.STATUS_CONFIRMED && this._session.status !== this._session.C.STATUS_WAITING_FOR_ACK) {\n        throw new Exceptions.InvalidStateError(this._session.status);\n      }\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n\n      this.eventHandlers = options.eventHandlers || {};\n\n      // Check tone type.\n      if (typeof tone === 'string') {\n        tone = tone.toUpperCase();\n      } else if (typeof tone === 'number') {\n        tone = tone.toString();\n      } else {\n        throw new TypeError('Invalid tone: ' + tone);\n      }\n\n      // Check tone value.\n      if (!tone.match(/^[0-9A-DR#*]$/)) {\n        throw new TypeError('Invalid tone: ' + tone);\n      } else {\n        this._tone = tone;\n      }\n\n      // Duration is checked/corrected in RTCSession.\n      this._duration = options.duration;\n\n      extraHeaders.push('Content-Type: application/dtmf-relay');\n\n      var body = 'Signal=' + this._tone + '\\r\\n';\n\n      body += 'Duration=' + this._duration;\n\n      this._session.newDTMF({\n        originator: 'local',\n        dtmf: this,\n        request: this._request\n      });\n\n      this._session.sendRequest(SIP_C.INFO, {\n        extraHeaders: extraHeaders,\n        eventHandlers: {\n          onSuccessResponse: function onSuccessResponse(response) {\n            _this2.emit('succeeded', {\n              originator: 'remote',\n              response: response\n            });\n          },\n          onErrorResponse: function onErrorResponse(response) {\n            if (_this2.eventHandlers.onFailed) {\n              _this2.eventHandlers.onFailed();\n            }\n\n            _this2.emit('failed', {\n              originator: 'remote',\n              response: response\n            });\n          },\n          onRequestTimeout: function onRequestTimeout() {\n            _this2._session.onRequestTimeout();\n          },\n          onTransportError: function onTransportError() {\n            _this2._session.onTransportError();\n          },\n          onDialogError: function onDialogError() {\n            _this2._session.onDialogError();\n          }\n        },\n        body: body\n      });\n    }\n  }, {\n    key: 'init_incoming',\n    value: function init_incoming(request) {\n      var reg_tone = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/;\n      var reg_duration = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n\n      this._direction = 'incoming';\n      this._request = request;\n\n      request.reply(200);\n\n      if (request.body) {\n        var body = request.body.split('\\n');\n\n        if (body.length >= 1) {\n          if (reg_tone.test(body[0])) {\n            this._tone = body[0].replace(reg_tone, '$2');\n          }\n        }\n        if (body.length >= 2) {\n          if (reg_duration.test(body[1])) {\n            this._duration = parseInt(body[1].replace(reg_duration, '$2'), 10);\n          }\n        }\n      }\n\n      if (!this._duration) {\n        this._duration = C.DEFAULT_DURATION;\n      }\n\n      if (!this._tone) {\n        debug('invalid INFO DTMF received, discarded');\n      } else {\n        this._session.newDTMF({\n          originator: 'remote',\n          dtmf: this,\n          request: request\n        });\n      }\n    }\n  }, {\n    key: 'tone',\n    get: function get() {\n      return this._tone;\n    }\n  }, {\n    key: 'duration',\n    get: function get() {\n      return this._duration;\n    }\n  }]);\n\n  return DTMF;\n}(EventEmitter);\n\n/**\n * Expose C object.\n */\nmodule.exports.C = C;\n\n//# sourceURL=webpack://ApolloSIP/./lib/RTCSession/DTMF.js?");

/***/ }),

/***/ "./lib/RTCSession/Info.js":
/*!********************************!*\
  !*** ./lib/RTCSession/Info.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:ERROR:RTCSession:Info');\n\ndebugerror.log = console.warn.bind(console);\nvar SIP_C = __webpack_require__(/*! ../Constants */ \"./lib/Constants.js\");\nvar Exceptions = __webpack_require__(/*! ../Exceptions */ \"./lib/Exceptions.js\");\nvar Utils = __webpack_require__(/*! ../Utils */ \"./lib/Utils.js\");\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(Info, _EventEmitter);\n\n  function Info(session) {\n    _classCallCheck(this, Info);\n\n    var _this = _possibleConstructorReturn(this, (Info.__proto__ || Object.getPrototypeOf(Info)).call(this));\n\n    _this._session = session;\n    _this._direction = null;\n    _this._contentType = null;\n    _this._body = null;\n    return _this;\n  }\n\n  _createClass(Info, [{\n    key: 'send',\n    value: function send(contentType, body) {\n      var _this2 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      this._direction = 'outgoing';\n\n      if (contentType === undefined) {\n        throw new TypeError('Not enough arguments');\n      }\n\n      // Check RTCSession Status.\n      if (this._session.status !== this._session.C.STATUS_CONFIRMED && this._session.status !== this._session.C.STATUS_WAITING_FOR_ACK) {\n        throw new Exceptions.InvalidStateError(this._session.status);\n      }\n\n      this._contentType = contentType;\n      this._body = body;\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var eventHandlers = options.eventHandlers || {};\n\n      // Set event handlers.\n      for (var event in eventHandlers) {\n        if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {\n          this.on(event, eventHandlers[event]);\n        }\n      }\n\n      extraHeaders.push('Content-Type: ' + contentType);\n\n      this._session.newInfo({\n        originator: 'local',\n        info: this,\n        request: this.request\n      });\n\n      this._session.sendRequest(SIP_C.INFO, {\n        extraHeaders: extraHeaders,\n        eventHandlers: {\n          onSuccessResponse: function onSuccessResponse(response) {\n            _this2.emit('succeeded', {\n              originator: 'remote',\n              response: response\n            });\n          },\n          onErrorResponse: function onErrorResponse(response) {\n            _this2.emit('failed', {\n              originator: 'remote',\n              response: response\n            });\n          },\n          onTransportError: function onTransportError() {\n            _this2._session.onTransportError();\n          },\n          onRequestTimeout: function onRequestTimeout() {\n            _this2._session.onRequestTimeout();\n          },\n          onDialogError: function onDialogError() {\n            _this2._session.onDialogError();\n          }\n        },\n        body: body\n      });\n    }\n  }, {\n    key: 'init_incoming',\n    value: function init_incoming(request) {\n      this._direction = 'incoming';\n      this.request = request;\n\n      request.reply(200);\n\n      this._contentType = request.getHeader('content-type');\n      this._body = request.body;\n\n      this._session.newInfo({\n        originator: 'remote',\n        info: this,\n        request: request\n      });\n    }\n  }, {\n    key: 'contentType',\n    get: function get() {\n      return this._contentType;\n    }\n  }, {\n    key: 'body',\n    get: function get() {\n      return this._body;\n    }\n  }]);\n\n  return Info;\n}(EventEmitter);\n\n//# sourceURL=webpack://ApolloSIP/./lib/RTCSession/Info.js?");

/***/ }),

/***/ "./lib/RTCSession/ReferNotifier.js":
/*!*****************************************!*\
  !*** ./lib/RTCSession/ReferNotifier.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SIP_C = __webpack_require__(/*! ../Constants */ \"./lib/Constants.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:RTCSession:ReferNotifier');\n\nvar C = {\n  event_type: 'refer',\n  body_type: 'message/sipfrag;version=2.0',\n  expires: 300\n};\n\nmodule.exports = function () {\n  function ReferNotifier(session, id, expires) {\n    _classCallCheck(this, ReferNotifier);\n\n    this._session = session;\n    this._id = id;\n    this._expires = expires || C.expires;\n    this._active = true;\n\n    // The creation of a Notifier results in an immediate NOTIFY.\n    this.notify(100);\n  }\n\n  _createClass(ReferNotifier, [{\n    key: 'notify',\n    value: function notify(code, reason) {\n      debug('notify()');\n\n      if (this._active === false) {\n        return;\n      }\n\n      reason = reason || SIP_C.REASON_PHRASE[code] || '';\n\n      var state = void 0;\n\n      if (code >= 200) {\n        state = 'terminated;reason=noresource';\n      } else {\n        state = 'active;expires=' + this._expires;\n      }\n\n      // Put this in a try/catch block.\n      this._session.sendRequest(SIP_C.NOTIFY, {\n        extraHeaders: ['Event: ' + C.event_type + ';id=' + this._id, 'Subscription-State: ' + state, 'Content-Type: ' + C.body_type],\n        body: 'SIP/2.0 ' + code + ' ' + reason,\n        eventHandlers: {\n          // If a negative response is received, subscription is canceled.\n          onErrorResponse: function onErrorResponse() {\n            this._active = false;\n          }\n        }\n      });\n    }\n  }]);\n\n  return ReferNotifier;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./lib/RTCSession/ReferNotifier.js?");

/***/ }),

/***/ "./lib/RTCSession/ReferSubscriber.js":
/*!*******************************************!*\
  !*** ./lib/RTCSession/ReferSubscriber.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar SIP_C = __webpack_require__(/*! ../Constants */ \"./lib/Constants.js\");\nvar Grammar = __webpack_require__(/*! ../Grammar */ \"./lib/Grammar.js\");\nvar Utils = __webpack_require__(/*! ../Utils */ \"./lib/Utils.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:RTCSession:ReferSubscriber');\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(ReferSubscriber, _EventEmitter);\n\n  function ReferSubscriber(session) {\n    _classCallCheck(this, ReferSubscriber);\n\n    var _this = _possibleConstructorReturn(this, (ReferSubscriber.__proto__ || Object.getPrototypeOf(ReferSubscriber)).call(this));\n\n    _this._id = null;\n    _this._session = session;\n    return _this;\n  }\n\n  _createClass(ReferSubscriber, [{\n    key: 'sendRefer',\n    value: function sendRefer(target) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      debug('sendRefer()');\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var eventHandlers = options.eventHandlers || {};\n\n      // Set event handlers.\n      for (var event in eventHandlers) {\n        if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {\n          this.on(event, eventHandlers[event]);\n        }\n      }\n\n      // Replaces URI header field.\n      var replaces = null;\n\n      if (options.replaces) {\n        replaces = options.replaces._request.call_id;\n        replaces += ';to-tag=' + options.replaces._to_tag;\n        replaces += ';from-tag=' + options.replaces._from_tag;\n\n        replaces = encodeURIComponent(replaces);\n      }\n\n      // Refer-To header field.\n      var referTo = 'Refer-To: <' + target + (replaces ? '?Replaces=' + replaces : '') + '>';\n\n      extraHeaders.push(referTo);\n\n      var request = this._session.sendRequest(SIP_C.REFER, {\n        extraHeaders: extraHeaders,\n        eventHandlers: {\n          onSuccessResponse: function onSuccessResponse(response) {\n            _this2._requestSucceeded(response);\n          },\n          onErrorResponse: function onErrorResponse(response) {\n            _this2._requestFailed(response, SIP_C.causes.REJECTED);\n          },\n          onTransportError: function onTransportError() {\n            _this2._requestFailed(null, SIP_C.causes.CONNECTION_ERROR);\n          },\n          onRequestTimeout: function onRequestTimeout() {\n            _this2._requestFailed(null, SIP_C.causes.REQUEST_TIMEOUT);\n          },\n          onDialogError: function onDialogError() {\n            _this2._requestFailed(null, SIP_C.causes.DIALOG_ERROR);\n          }\n        }\n      });\n\n      this._id = request.cseq;\n    }\n  }, {\n    key: 'receiveNotify',\n    value: function receiveNotify(request) {\n      debug('receiveNotify()');\n\n      if (!request.body) {\n        return;\n      }\n\n      var status_line = Grammar.parse(request.body.trim(), 'Status_Line');\n\n      if (status_line === -1) {\n        debug('receiveNotify() | error parsing NOTIFY body: \"' + request.body + '\"');\n\n        return;\n      }\n\n      switch (true) {\n        case /^100$/.test(status_line.status_code):\n          this.emit('trying', {\n            request: request,\n            status_line: status_line\n          });\n          break;\n\n        case /^1[0-9]{2}$/.test(status_line.status_code):\n          this.emit('progress', {\n            request: request,\n            status_line: status_line\n          });\n          break;\n\n        case /^2[0-9]{2}$/.test(status_line.status_code):\n          this.emit('accepted', {\n            request: request,\n            status_line: status_line\n          });\n          break;\n\n        default:\n          this.emit('failed', {\n            request: request,\n            status_line: status_line\n          });\n          break;\n      }\n    }\n  }, {\n    key: '_requestSucceeded',\n    value: function _requestSucceeded(response) {\n      debug('REFER succeeded');\n\n      debug('emit \"requestSucceeded\"');\n\n      this.emit('requestSucceeded', {\n        response: response\n      });\n    }\n  }, {\n    key: '_requestFailed',\n    value: function _requestFailed(response, cause) {\n      debug('REFER failed');\n\n      debug('emit \"requestFailed\"');\n\n      this.emit('requestFailed', {\n        response: response || null,\n        cause: cause\n      });\n    }\n  }, {\n    key: 'id',\n    get: function get() {\n      return this._id;\n    }\n  }]);\n\n  return ReferSubscriber;\n}(EventEmitter);\n\n//# sourceURL=webpack://ApolloSIP/./lib/RTCSession/ReferSubscriber.js?");

/***/ }),

/***/ "./lib/Registrator.js":
/*!****************************!*\
  !*** ./lib/Registrator.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./lib/SIPMessage.js\");\nvar RequestSender = __webpack_require__(/*! ./RequestSender */ \"./lib/RequestSender.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:Registrator');\n\nvar MIN_REGISTER_EXPIRES = 10; // In seconds.\n\nmodule.exports = function () {\n  function Registrator(ua, transport) {\n    _classCallCheck(this, Registrator);\n\n    var reg_id = 1; // Force reg_id to 1.\n\n    this._ua = ua;\n    this._transport = transport;\n\n    this._registrar = ua.configuration.registrar_server;\n    this._expires = ua.configuration.register_expires;\n\n    // Call-ID and CSeq values RFC3261 10.2.\n    this._call_id = Utils.createRandomToken(22);\n    this._cseq = 0;\n\n    this._to_uri = ua.configuration.uri;\n\n    this._registrationTimer = null;\n\n    // Ongoing Register request.\n    this._registering = false;\n\n    // Set status.\n    this._registered = false;\n\n    // Contact header.\n    this._contact = this._ua.contact.toString();\n\n    // Sip.ice media feature tag (RFC 5768).\n    this._contact += ';+sip.ice';\n\n    // Custom headers for REGISTER and un-REGISTER.\n    this._extraHeaders = [];\n\n    // Custom Contact header params for REGISTER and un-REGISTER.\n    this._extraContactParams = '';\n\n    if (reg_id) {\n      this._contact += ';reg-id=' + reg_id;\n      this._contact += ';+sip.instance=\"<urn:uuid:' + this._ua.configuration.instance_id + '>\"';\n    }\n  }\n\n  _createClass(Registrator, [{\n    key: 'setExtraHeaders',\n    value: function setExtraHeaders(extraHeaders) {\n      if (!Array.isArray(extraHeaders)) {\n        extraHeaders = [];\n      }\n\n      this._extraHeaders = extraHeaders.slice();\n    }\n  }, {\n    key: 'setExtraContactParams',\n    value: function setExtraContactParams(extraContactParams) {\n      if (!(extraContactParams instanceof Object)) {\n        extraContactParams = {};\n      }\n\n      // Reset it.\n      this._extraContactParams = '';\n\n      for (var param_key in extraContactParams) {\n        if (Object.prototype.hasOwnProperty.call(extraContactParams, param_key)) {\n          var param_value = extraContactParams[param_key];\n\n          this._extraContactParams += ';' + param_key;\n          if (param_value) {\n            this._extraContactParams += '=' + param_value;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'register',\n    value: function register() {\n      var _this = this;\n\n      if (this._registering) {\n        debug('Register request in progress...');\n\n        return;\n      }\n\n      var extraHeaders = this._extraHeaders.slice();\n\n      extraHeaders.push('Contact: ' + this._contact + ';expires=' + this._expires + this._extraContactParams);\n      extraHeaders.push('Expires: ' + this._expires);\n\n      var request = new SIPMessage.OutgoingRequest(SIP_C.REGISTER, this._registrar, this._ua, {\n        'to_uri': this._to_uri,\n        'call_id': this._call_id,\n        'cseq': this._cseq += 1\n      }, extraHeaders);\n\n      var request_sender = new RequestSender(this._ua, request, {\n        onRequestTimeout: function onRequestTimeout() {\n          _this._registrationFailure(null, SIP_C.causes.REQUEST_TIMEOUT);\n        },\n        onTransportError: function onTransportError() {\n          _this._registrationFailure(null, SIP_C.causes.CONNECTION_ERROR);\n        },\n        // Increase the CSeq on authentication.\n        onAuthenticated: function onAuthenticated() {\n          _this._cseq += 1;\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          var contact = void 0;\n          var expires = void 0;\n          var numContacts = response.getHeaders('contact').length;\n\n          // Discard responses to older REGISTER/un-REGISTER requests.\n          if (response.cseq !== _this._cseq) {\n            return;\n          }\n\n          // Clear registration timer.\n          if (_this._registrationTimer !== null) {\n            clearTimeout(_this._registrationTimer);\n            _this._registrationTimer = null;\n          }\n\n          switch (true) {\n            case /^1[0-9]{2}$/.test(response.status_code):\n              // Ignore provisional responses.\n              break;\n            case /^2[0-9]{2}$/.test(response.status_code):\n              _this._registering = false;\n\n              // Search the Contact pointing to us and update the expires value accordingly.\n              if (!numContacts) {\n                debug('no Contact header in response to REGISTER, response ignored');\n                break;\n              }\n\n              while (numContacts--) {\n                contact = response.parseHeader('contact', numContacts);\n\n                if (contact.uri.user === _this._ua.contact.uri.user) {\n                  expires = contact.getParam('expires');\n                  break;\n                } else {\n                  contact = null;\n                }\n              }\n\n              if (!contact) {\n                debug('no Contact header pointing to us, response ignored');\n                break;\n              }\n\n              if (!expires && response.hasHeader('expires')) {\n                expires = response.getHeader('expires');\n              }\n\n              if (!expires) {\n                expires = _this._expires;\n              }\n\n              expires = Number(expires);\n\n              if (expires < MIN_REGISTER_EXPIRES) expires = MIN_REGISTER_EXPIRES;\n\n              // Re-Register or emit an event before the expiration interval has elapsed.\n              // For that, decrease the expires value. ie: 3 seconds.\n              _this._registrationTimer = setTimeout(function () {\n                _this._registrationTimer = null;\n                // If there are no listeners for registrationExpiring, renew registration.\n                // If there are listeners, let the function listening do the register call.\n                if (_this._ua.listeners('registrationExpiring').length === 0) {\n                  _this.register();\n                } else {\n                  _this._ua.emit('registrationExpiring');\n                }\n              }, expires * 1000 - 5000);\n\n              // Save gruu values.\n              if (contact.hasParam('temp-gruu')) {\n                _this._ua.contact.temp_gruu = contact.getParam('temp-gruu').replace(/\"/g, '');\n              }\n              if (contact.hasParam('pub-gruu')) {\n                _this._ua.contact.pub_gruu = contact.getParam('pub-gruu').replace(/\"/g, '');\n              }\n\n              if (!_this._registered) {\n                _this._registered = true;\n                _this._ua.registered({\n                  response: response\n                });\n              }\n              break;\n            // Interval too brief RFC3261 10.2.8.\n            case /^423$/.test(response.status_code):\n              if (response.hasHeader('min-expires')) {\n                // Increase our registration interval to the suggested minimum.\n                _this._expires = Number(response.getHeader('min-expires'));\n\n                if (_this._expires < MIN_REGISTER_EXPIRES) _this._expires = MIN_REGISTER_EXPIRES;\n\n                // Attempt the registration again immediately.\n                _this.register();\n              } else {\n                // This response MUST contain a Min-Expires header field\n                debug('423 response received for REGISTER without Min-Expires');\n                _this._registrationFailure(response, SIP_C.causes.SIP_FAILURE_CODE);\n              }\n              break;\n            default:\n              {\n                var cause = Utils.sipErrorCause(response.status_code);\n\n                _this._registrationFailure(response, cause);\n              }\n          }\n        }\n      });\n\n      this._registering = true;\n      request_sender.send();\n    }\n  }, {\n    key: 'unregister',\n    value: function unregister() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this._registered) {\n        debug('already unregistered');\n\n        return;\n      }\n\n      this._registered = false;\n\n      // Clear the registration timer.\n      if (this._registrationTimer !== null) {\n        clearTimeout(this._registrationTimer);\n        this._registrationTimer = null;\n      }\n\n      var extraHeaders = this._extraHeaders.slice();\n\n      if (options.all) {\n        extraHeaders.push('Contact: *' + this._extraContactParams);\n      } else {\n        extraHeaders.push('Contact: ' + this._contact + ';expires=0' + this._extraContactParams);\n      }\n\n      extraHeaders.push('Expires: 0');\n\n      var request = new SIPMessage.OutgoingRequest(SIP_C.REGISTER, this._registrar, this._ua, {\n        'to_uri': this._to_uri,\n        'call_id': this._call_id,\n        'cseq': this._cseq += 1\n      }, extraHeaders);\n\n      var request_sender = new RequestSender(this._ua, request, {\n        onRequestTimeout: function onRequestTimeout() {\n          _this2._unregistered(null, SIP_C.causes.REQUEST_TIMEOUT);\n        },\n        onTransportError: function onTransportError() {\n          _this2._unregistered(null, SIP_C.causes.CONNECTION_ERROR);\n        },\n        // Increase the CSeq on authentication.\n        onAuthenticated: function onAuthenticated() {\n          _this2._cseq += 1;\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          switch (true) {\n            case /^1[0-9]{2}$/.test(response.status_code):\n              // Ignore provisional responses.\n              break;\n            case /^2[0-9]{2}$/.test(response.status_code):\n              _this2._unregistered(response);\n              break;\n            default:\n              {\n                var cause = Utils.sipErrorCause(response.status_code);\n\n                _this2._unregistered(response, cause);\n              }\n          }\n        }\n      });\n\n      request_sender.send();\n    }\n  }, {\n    key: 'close',\n    value: function close() {\n      if (this._registered) {\n        this.unregister();\n      }\n    }\n  }, {\n    key: 'onTransportClosed',\n    value: function onTransportClosed() {\n      this._registering = false;\n      if (this._registrationTimer !== null) {\n        clearTimeout(this._registrationTimer);\n        this._registrationTimer = null;\n      }\n\n      if (this._registered) {\n        this._registered = false;\n        this._ua.unregistered({});\n      }\n    }\n  }, {\n    key: '_registrationFailure',\n    value: function _registrationFailure(response, cause) {\n      this._registering = false;\n      this._ua.registrationFailed({\n        response: response || null,\n        cause: cause\n      });\n\n      if (this._registered) {\n        this._registered = false;\n        this._ua.unregistered({\n          response: response || null,\n          cause: cause\n        });\n      }\n    }\n  }, {\n    key: '_unregistered',\n    value: function _unregistered(response, cause) {\n      this._registering = false;\n      this._registered = false;\n      this._ua.unregistered({\n        response: response || null,\n        cause: cause || null\n      });\n    }\n  }, {\n    key: 'registered',\n    get: function get() {\n      return this._registered;\n    }\n  }]);\n\n  return Registrator;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./lib/Registrator.js?");

/***/ }),

/***/ "./lib/RequestSender.js":
/*!******************************!*\
  !*** ./lib/RequestSender.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar DigestAuthentication = __webpack_require__(/*! ./DigestAuthentication */ \"./lib/DigestAuthentication.js\");\nvar Transactions = __webpack_require__(/*! ./Transactions */ \"./lib/Transactions.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:RequestSender');\n\n// Default event handlers.\nvar EventHandlers = {\n  onRequestTimeout: function onRequestTimeout() {},\n  onTransportError: function onTransportError() {},\n  onReceiveResponse: function onReceiveResponse() {},\n  onAuthenticated: function onAuthenticated() {}\n};\n\nmodule.exports = function () {\n  function RequestSender(ua, request, eventHandlers) {\n    _classCallCheck(this, RequestSender);\n\n    this._ua = ua;\n    this._eventHandlers = eventHandlers;\n    this._method = request.method;\n    this._request = request;\n    this._auth = null;\n    this._challenged = false;\n    this._staled = false;\n\n    // Define the undefined handlers.\n    for (var handler in EventHandlers) {\n      if (Object.prototype.hasOwnProperty.call(EventHandlers, handler)) {\n        if (!this._eventHandlers[handler]) {\n          this._eventHandlers[handler] = EventHandlers[handler];\n        }\n      }\n    }\n\n    // If ua is in closing process or even closed just allow sending Bye and ACK.\n    if (ua.status === ua.C.STATUS_USER_CLOSED && (this._method !== SIP_C.BYE || this._method !== SIP_C.ACK)) {\n      this._eventHandlers.onTransportError();\n    }\n\n    // If ua has challenge cache, authenticate the request.\n    var challenges = ua._cache.challenges;\n\n    if (Object.keys(challenges).length) {\n      if (!this._auth) {\n        this._auth = new DigestAuthentication({\n          username: this._ua.configuration.authorization_user,\n          password: this._ua.configuration.password,\n          realm: this._ua.configuration.realm,\n          ha1: this._ua.configuration.ha1\n        });\n      }\n\n      for (var type in challenges) {\n        if (challenges.hasOwnProperty(type)) {\n          var challenge = challenges[type];\n\n          this._auth.authenticate(this._request, challenge);\n          this._request.setHeader(type, this._auth.toString());\n        }\n      }\n    }\n  }\n\n  /**\n  * Create the client transaction and send the message.\n  */\n\n\n  _createClass(RequestSender, [{\n    key: 'send',\n    value: function send() {\n      var _this = this;\n\n      var eventHandlers = {\n        onRequestTimeout: function onRequestTimeout() {\n          _this._eventHandlers.onRequestTimeout();\n        },\n        onTransportError: function onTransportError() {\n          _this._eventHandlers.onTransportError();\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          _this._receiveResponse(response);\n        }\n      };\n\n      switch (this._method) {\n        case 'INVITE':\n          this.clientTransaction = new Transactions.InviteClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n          break;\n        case 'ACK':\n          this.clientTransaction = new Transactions.AckClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n          break;\n        default:\n          this.clientTransaction = new Transactions.NonInviteClientTransaction(this._ua, this._ua.transport, this._request, eventHandlers);\n      }\n\n      this.clientTransaction.send();\n    }\n\n    /**\n    * Called from client transaction when receiving a correct response to the request.\n    * Authenticate request if needed or pass the response back to the applicant.\n    */\n\n  }, {\n    key: '_receiveResponse',\n    value: function _receiveResponse(response) {\n      var challenge = void 0;\n      var authorization_header_name = void 0;\n      var status_code = response.status_code;\n\n      /*\n      * Authentication\n      * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n      */\n      if ((status_code === 401 || status_code === 407) && (this._ua.configuration.password !== null || this._ua.configuration.ha1 !== null)) {\n\n        // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n        if (response.status_code === 401) {\n          challenge = response.parseHeader('www-authenticate');\n          authorization_header_name = 'authorization';\n        } else {\n          challenge = response.parseHeader('proxy-authenticate');\n          authorization_header_name = 'proxy-authorization';\n        }\n\n        // Verify it seems a valid challenge.\n        if (!challenge) {\n          debug(response.status_code + ' with wrong or missing challenge, cannot authenticate');\n          this._eventHandlers.onReceiveResponse(response);\n\n          return;\n        }\n\n        if (!this._challenged || !this._staled && challenge.stale === true) {\n          if (!this._auth) {\n            this._auth = new DigestAuthentication({\n              username: this._ua.configuration.authorization_user,\n              password: this._ua.configuration.password,\n              realm: this._ua.configuration.realm,\n              ha1: this._ua.configuration.ha1\n            });\n          }\n\n          // Verify that the challenge is really valid.\n          if (!this._auth.authenticate(this._request, challenge)) {\n            this._eventHandlers.onReceiveResponse(response);\n\n            return;\n          }\n          this._challenged = true;\n\n          // Update ha1 and realm in the UA.\n          this._ua.set('realm', this._auth.get('realm'));\n          this._ua.set('ha1', this._auth.get('ha1'));\n\n          // Cache challenges in th UA.\n          this._ua._cache.challenges[authorization_header_name] = challenge;\n\n          if (challenge.stale) {\n            this._staled = true;\n          }\n\n          this._request = this._request.clone();\n          this._request.cseq += 1;\n          this._request.setHeader('cseq', this._request.cseq + ' ' + this._method);\n          this._request.setHeader(authorization_header_name, this._auth.toString());\n\n          this._eventHandlers.onAuthenticated(this._request);\n          this.send();\n        } else {\n          this._eventHandlers.onReceiveResponse(response);\n        }\n      } else {\n        this._eventHandlers.onReceiveResponse(response);\n      }\n    }\n  }]);\n\n  return RequestSender;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./lib/RequestSender.js?");

/***/ }),

/***/ "./lib/SIP.js":
/*!********************!*\
  !*** ./lib/SIP.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar adapter = __webpack_require__(/*! webrtc-adapter */ \"./node_modules/webrtc-adapter/src/js/adapter_core.js\");\nvar pkg = __webpack_require__(/*! ../package.json */ \"./package.json\");\nvar C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar Exceptions = __webpack_require__(/*! ./Exceptions */ \"./lib/Exceptions.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar UA = __webpack_require__(/*! ./UA */ \"./lib/UA.js\");\nvar URI = __webpack_require__(/*! ./URI */ \"./lib/URI.js\");\nvar NameAddrHeader = __webpack_require__(/*! ./NameAddrHeader */ \"./lib/NameAddrHeader.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./lib/Grammar.js\");\nvar SocketIOInterface = __webpack_require__(/*! ./SocketIOInterface */ \"./lib/SocketIOInterface.js\");\nvar WebSocketInterface = __webpack_require__(/*! ./WebSocketInterface */ \"./lib/WebSocketInterface.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP');\n\ndebug('version %s', pkg.version);\n\n/**\n * Expose the SIP module.\n */\nmodule.exports = {\n  C: C,\n  Exceptions: Exceptions,\n  Utils: Utils,\n  UA: UA,\n  URI: URI,\n  NameAddrHeader: NameAddrHeader,\n  SocketIOInterface: SocketIOInterface,\n  WebSocketInterface: WebSocketInterface,\n  Grammar: Grammar,\n  // Expose the debug module.\n  debug: __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\"),\n  // Expose the adapter module.\n  adapter: adapter,\n  get name() {\n    return pkg.title;\n  },\n  get version() {\n    return pkg.version;\n  }\n};\n\n//# sourceURL=webpack://ApolloSIP/./lib/SIP.js?");

/***/ }),

/***/ "./lib/SIPMessage.js":
/*!***************************!*\
  !*** ./lib/SIPMessage.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar sdp_transform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar NameAddrHeader = __webpack_require__(/*! ./NameAddrHeader */ \"./lib/NameAddrHeader.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./lib/Grammar.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:SIPMessage');\n\n/**\n * -param {String} method request method\n * -param {String} ruri request uri\n * -param {UA} ua\n * -param {Object} params parameters that will have priority over ua.configuration parameters:\n * <br>\n *  - cseq, call_id, from_tag, from_uri, from_display_name, to_uri, to_tag, route_set\n * -param {Object} [headers] extra headers\n * -param {String} [body]\n */\n\nvar OutgoingRequest = function () {\n  function OutgoingRequest(method, ruri, ua, params, extraHeaders, body) {\n    _classCallCheck(this, OutgoingRequest);\n\n    // Mandatory parameters check.\n    if (!method || !ruri || !ua) {\n      return null;\n    }\n\n    params = params || {};\n\n    this.ua = ua;\n    this.headers = {};\n    this.method = method;\n    this.ruri = ruri;\n    this.body = body;\n    this.extraHeaders = Utils.cloneArray(extraHeaders);\n\n    // Fill the Common SIP Request Headers.\n\n    // Route.\n    if (params.route_set) {\n      this.setHeader('route', params.route_set);\n    } else if (ua.configuration.use_preloaded_route) {\n      this.setHeader('route', '<' + ua.transport.sip_uri + ';lr>');\n    }\n\n    // Via.\n    // Empty Via header. Will be filled by the client transaction.\n    this.setHeader('via', '');\n\n    // Max-Forwards.\n    this.setHeader('max-forwards', SIP_C.MAX_FORWARDS);\n\n    // To\n    var to = params.to_display_name || params.to_display_name === 0 ? '\"' + params.to_display_name + '\" ' : '';\n\n    to += '<' + (params.to_uri || ruri) + '>';\n    to += params.to_tag ? ';tag=' + params.to_tag : '';\n    this.to = NameAddrHeader.parse(to);\n    this.setHeader('to', to);\n\n    // From.\n    var from = void 0;\n\n    if (params.from_display_name || params.from_display_name === 0) {\n      from = '\"' + params.from_display_name + '\" ';\n    } else if (ua.configuration.display_name) {\n      from = '\"' + ua.configuration.display_name + '\" ';\n    } else {\n      from = '';\n    }\n    from += '<' + (params.from_uri || ua.configuration.uri) + '>;tag=';\n    from += params.from_tag || Utils.newTag();\n    this.from = NameAddrHeader.parse(from);\n    this.setHeader('from', from);\n\n    // Call-ID.\n    var call_id = params.call_id || ua.configuration.jssip_id + Utils.createRandomToken(15);\n\n    this.call_id = call_id;\n    this.setHeader('call-id', call_id);\n\n    // CSeq.\n    var cseq = params.cseq || Math.floor(Math.random() * 10000);\n\n    this.cseq = cseq;\n    this.setHeader('cseq', cseq + ' ' + method);\n  }\n\n  /**\n   * Replace the the given header by the given value.\n   * -param {String} name header name\n   * -param {String | Array} value header value\n   */\n\n\n  _createClass(OutgoingRequest, [{\n    key: 'setHeader',\n    value: function setHeader(name, value) {\n      // Remove the header from extraHeaders if present.\n      var regexp = new RegExp('^\\\\s*' + name + '\\\\s*:', 'i');\n\n      for (var idx = 0; idx < this.extraHeaders.length; idx++) {\n        if (regexp.test(this.extraHeaders[idx])) {\n          this.extraHeaders.splice(idx, 1);\n        }\n      }\n\n      this.headers[Utils.headerize(name)] = Array.isArray(value) ? value : [value];\n    }\n\n    /**\n     * Get the value of the given header name at the given position.\n     * -param {String} name header name\n     * -returns {String|undefined} Returns the specified header, null if header doesn't exist.\n     */\n\n  }, {\n    key: 'getHeader',\n    value: function getHeader(name) {\n      var headers = this.headers[Utils.headerize(name)];\n\n      if (headers) {\n        if (headers[0]) {\n          return headers[0];\n        }\n      } else {\n        var regexp = new RegExp('^\\\\s*' + name + '\\\\s*:', 'i');\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.extraHeaders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var header = _step.value;\n\n            if (regexp.test(header)) {\n              return header.substring(header.indexOf(':') + 1).trim();\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      return;\n    }\n\n    /**\n     * Get the header/s of the given name.\n     * -param {String} name header name\n     * -returns {Array} Array with all the headers of the specified name.\n     */\n\n  }, {\n    key: 'getHeaders',\n    value: function getHeaders(name) {\n      var headers = this.headers[Utils.headerize(name)];\n      var result = [];\n\n      if (headers) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = headers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var header = _step2.value;\n\n            result.push(header);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        return result;\n      } else {\n        var regexp = new RegExp('^\\\\s*' + name + '\\\\s*:', 'i');\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = this.extraHeaders[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var _header = _step3.value;\n\n            if (regexp.test(_header)) {\n              result.push(_header.substring(_header.indexOf(':') + 1).trim());\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        return result;\n      }\n    }\n\n    /**\n     * Verify the existence of the given header.\n     * -param {String} name header name\n     * -returns {boolean} true if header with given name exists, false otherwise\n     */\n\n  }, {\n    key: 'hasHeader',\n    value: function hasHeader(name) {\n      if (this.headers[Utils.headerize(name)]) {\n        return true;\n      } else {\n        var regexp = new RegExp('^\\\\s*' + name + '\\\\s*:', 'i');\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = this.extraHeaders[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var header = _step4.value;\n\n            if (regexp.test(header)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Parse the current body as a SDP and store the resulting object\n     * into this.sdp.\n     * -param {Boolean} force: Parse even if this.sdp already exists.\n     *\n     * Returns this.sdp.\n     */\n\n  }, {\n    key: 'parseSDP',\n    value: function parseSDP(force) {\n      if (!force && this.sdp) {\n        return this.sdp;\n      } else {\n        this.sdp = sdp_transform.parse(this.body || '');\n\n        return this.sdp;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var msg = this.method + ' ' + this.ruri + ' SIP/2.0\\r\\n';\n\n      for (var headerName in this.headers) {\n        if (Object.prototype.hasOwnProperty.call(this.headers, headerName)) {\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = this.headers[headerName][Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var headerValue = _step5.value;\n\n              msg += headerName + ': ' + headerValue + '\\r\\n';\n            }\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.extraHeaders[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var header = _step6.value;\n\n          msg += header.trim() + '\\r\\n';\n        }\n\n        // Supported.\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var supported = [];\n\n      switch (this.method) {\n        case SIP_C.REGISTER:\n          supported.push('path', 'gruu');\n          break;\n        case SIP_C.INVITE:\n          if (this.ua.configuration.session_timers) {\n            supported.push('timer');\n          }\n          if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {\n            supported.push('gruu');\n          }\n          supported.push('ice', 'replaces');\n          break;\n        case SIP_C.UPDATE:\n          if (this.ua.configuration.session_timers) {\n            supported.push('timer');\n          }\n          supported.push('ice');\n          break;\n      }\n\n      supported.push('outbound');\n\n      var userAgent = this.ua.configuration.user_agent || SIP_C.USER_AGENT;\n\n      // Allow.\n      msg += 'Allow: ' + SIP_C.ALLOWED_METHODS + '\\r\\n';\n      msg += 'Supported: ' + supported + '\\r\\n';\n      msg += 'User-Agent: ' + userAgent + '\\r\\n';\n\n      if (this.body) {\n        var length = Utils.str_utf8_length(this.body);\n\n        msg += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n        msg += this.body;\n      } else {\n        msg += 'Content-Length: 0\\r\\n\\r\\n';\n      }\n\n      return msg;\n    }\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var request = new OutgoingRequest(this.method, this.ruri, this.ua);\n\n      Object.keys(this.headers).forEach(function (name) {\n        request.headers[name] = this.headers[name].slice();\n      }, this);\n\n      request.body = this.body;\n      request.extraHeaders = Utils.cloneArray(this.extraHeaders);\n      request.to = this.to;\n      request.from = this.from;\n      request.call_id = this.call_id;\n      request.cseq = this.cseq;\n\n      return request;\n    }\n  }]);\n\n  return OutgoingRequest;\n}();\n\nvar InitialOutgoingInviteRequest = function (_OutgoingRequest) {\n  _inherits(InitialOutgoingInviteRequest, _OutgoingRequest);\n\n  function InitialOutgoingInviteRequest(ruri, ua, params, extraHeaders, body) {\n    _classCallCheck(this, InitialOutgoingInviteRequest);\n\n    var _this = _possibleConstructorReturn(this, (InitialOutgoingInviteRequest.__proto__ || Object.getPrototypeOf(InitialOutgoingInviteRequest)).call(this, SIP_C.INVITE, ruri, ua, params, extraHeaders, body));\n\n    _this.transaction = null;\n    return _this;\n  }\n\n  _createClass(InitialOutgoingInviteRequest, [{\n    key: 'cancel',\n    value: function cancel(reason) {\n      this.transaction.cancel(reason);\n    }\n  }, {\n    key: 'clone',\n    value: function clone() {\n      var request = new InitialOutgoingInviteRequest(this.ruri, this.ua);\n\n      Object.keys(this.headers).forEach(function (name) {\n        request.headers[name] = this.headers[name].slice();\n      }, this);\n\n      request.body = this.body;\n      request.extraHeaders = Utils.cloneArray(this.extraHeaders);\n      request.to = this.to;\n      request.from = this.from;\n      request.call_id = this.call_id;\n      request.cseq = this.cseq;\n\n      request.transaction = this.transaction;\n\n      return request;\n    }\n  }]);\n\n  return InitialOutgoingInviteRequest;\n}(OutgoingRequest);\n\nvar IncomingMessage = function () {\n  function IncomingMessage() {\n    _classCallCheck(this, IncomingMessage);\n\n    this.data = null;\n    this.headers = null;\n    this.method = null;\n    this.via = null;\n    this.via_branch = null;\n    this.call_id = null;\n    this.cseq = null;\n    this.from = null;\n    this.from_tag = null;\n    this.to = null;\n    this.to_tag = null;\n    this.body = null;\n    this.sdp = null;\n  }\n\n  /**\n  * Insert a header of the given name and value into the last position of the\n  * header array.\n  */\n\n\n  _createClass(IncomingMessage, [{\n    key: 'addHeader',\n    value: function addHeader(name, value) {\n      var header = { raw: value };\n\n      name = Utils.headerize(name);\n\n      if (this.headers[name]) {\n        this.headers[name].push(header);\n      } else {\n        this.headers[name] = [header];\n      }\n    }\n\n    /**\n     * Get the value of the given header name at the given position.\n     */\n\n  }, {\n    key: 'getHeader',\n    value: function getHeader(name) {\n      var header = this.headers[Utils.headerize(name)];\n\n      if (header) {\n        if (header[0]) {\n          return header[0].raw;\n        }\n      } else {\n        return;\n      }\n    }\n\n    /**\n     * Get the header/s of the given name.\n     */\n\n  }, {\n    key: 'getHeaders',\n    value: function getHeaders(name) {\n      var headers = this.headers[Utils.headerize(name)];\n      var result = [];\n\n      if (!headers) {\n        return [];\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = headers[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var header = _step7.value;\n\n          result.push(header.raw);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      return result;\n    }\n\n    /**\n     * Verify the existence of the given header.\n     */\n\n  }, {\n    key: 'hasHeader',\n    value: function hasHeader(name) {\n      return this.headers[Utils.headerize(name)] ? true : false;\n    }\n\n    /**\n    * Parse the given header on the given index.\n    * -param {String} name header name\n    * -param {Number} [idx=0] header index\n    * -returns {Object|undefined} Parsed header object, undefined if the header\n    *  is not present or in case of a parsing error.\n    */\n\n  }, {\n    key: 'parseHeader',\n    value: function parseHeader(name) {\n      var idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      name = Utils.headerize(name);\n\n      if (!this.headers[name]) {\n        debug('header \"' + name + '\" not present');\n\n        return;\n      } else if (idx >= this.headers[name].length) {\n        debug('not so many \"' + name + '\" headers present');\n\n        return;\n      }\n\n      var header = this.headers[name][idx];\n      var value = header.raw;\n\n      if (header.parsed) {\n        return header.parsed;\n      }\n\n      // Substitute '-' by '_' for grammar rule matching.\n      var parsed = Grammar.parse(value, name.replace(/-/g, '_'));\n\n      if (parsed === -1) {\n        this.headers[name].splice(idx, 1); // delete from headers\n        debug('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n\n        return;\n      } else {\n        header.parsed = parsed;\n\n        return parsed;\n      }\n    }\n\n    /**\n     * Message Header attribute selector. Alias of parseHeader.\n     * -param {String} name header name\n     * -param {Number} [idx=0] header index\n     * -returns {Object|undefined} Parsed header object, undefined if the header\n     *  is not present or in case of a parsing error.\n     *\n     * -example\n     * message.s('via',3).port\n     */\n\n  }, {\n    key: 's',\n    value: function s(name, idx) {\n      return this.parseHeader(name, idx);\n    }\n\n    /**\n    * Replace the value of the given header by the value.\n    * -param {String} name header name\n    * -param {String} value header value\n    */\n\n  }, {\n    key: 'setHeader',\n    value: function setHeader(name, value) {\n      var header = { raw: value };\n\n      this.headers[Utils.headerize(name)] = [header];\n    }\n\n    /**\n     * Parse the current body as a SDP and store the resulting object\n     * into this.sdp.\n     * -param {Boolean} force: Parse even if this.sdp already exists.\n     *\n     * Returns this.sdp.\n     */\n\n  }, {\n    key: 'parseSDP',\n    value: function parseSDP(force) {\n      if (!force && this.sdp) {\n        return this.sdp;\n      } else {\n        this.sdp = sdp_transform.parse(this.body || '');\n\n        return this.sdp;\n      }\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return this.data;\n    }\n  }]);\n\n  return IncomingMessage;\n}();\n\nvar IncomingRequest = function (_IncomingMessage) {\n  _inherits(IncomingRequest, _IncomingMessage);\n\n  function IncomingRequest(ua) {\n    _classCallCheck(this, IncomingRequest);\n\n    var _this2 = _possibleConstructorReturn(this, (IncomingRequest.__proto__ || Object.getPrototypeOf(IncomingRequest)).call(this));\n\n    _this2.ua = ua;\n    _this2.headers = {};\n    _this2.ruri = null;\n    _this2.transport = null;\n    _this2.server_transaction = null;\n    return _this2;\n  }\n\n  /**\n  * Stateful reply.\n  * -param {Number} code status code\n  * -param {String} reason reason phrase\n  * -param {Object} headers extra headers\n  * -param {String} body body\n  * -param {Function} [onSuccess] onSuccess callback\n  * -param {Function} [onFailure] onFailure callback\n  */\n\n\n  _createClass(IncomingRequest, [{\n    key: 'reply',\n    value: function reply(code, reason, extraHeaders, body, onSuccess, onFailure) {\n      var supported = [];\n      var to = this.getHeader('To');\n\n      code = code || null;\n      reason = reason || null;\n\n      // Validate code and reason values.\n      if (!code || code < 100 || code > 699) {\n        throw new TypeError('Invalid status_code: ' + code);\n      } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n        throw new TypeError('Invalid reason_phrase: ' + reason);\n      }\n\n      reason = reason || SIP_C.REASON_PHRASE[code] || '';\n      extraHeaders = Utils.cloneArray(extraHeaders);\n\n      var response = 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n\n      if (this.method === SIP_C.INVITE && code > 100 && code <= 200) {\n        var headers = this.getHeaders('record-route');\n\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = headers[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var header = _step8.value;\n\n            response += 'Record-Route: ' + header + '\\r\\n';\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n      }\n\n      var vias = this.getHeaders('via');\n\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = vias[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var via = _step9.value;\n\n          response += 'Via: ' + via + '\\r\\n';\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      if (!this.to_tag && code > 100) {\n        to += ';tag=' + Utils.newTag();\n      } else if (this.to_tag && !this.s('to').hasParam('tag')) {\n        to += ';tag=' + this.to_tag;\n      }\n\n      response += 'To: ' + to + '\\r\\n';\n      response += 'From: ' + this.getHeader('From') + '\\r\\n';\n      response += 'Call-ID: ' + this.call_id + '\\r\\n';\n      response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = extraHeaders[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var _header2 = _step10.value;\n\n          response += _header2.trim() + '\\r\\n';\n        }\n\n        // Supported.\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      switch (this.method) {\n        case SIP_C.INVITE:\n          if (this.ua.configuration.session_timers) {\n            supported.push('timer');\n          }\n          if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {\n            supported.push('gruu');\n          }\n          supported.push('ice', 'replaces');\n          break;\n        case SIP_C.UPDATE:\n          if (this.ua.configuration.session_timers) {\n            supported.push('timer');\n          }\n          if (body) {\n            supported.push('ice');\n          }\n          supported.push('replaces');\n      }\n\n      supported.push('outbound');\n\n      // Allow and Accept.\n      if (this.method === SIP_C.OPTIONS) {\n        response += 'Allow: ' + SIP_C.ALLOWED_METHODS + '\\r\\n';\n        response += 'Accept: ' + SIP_C.ACCEPTED_BODY_TYPES + '\\r\\n';\n      } else if (code === 405) {\n        response += 'Allow: ' + SIP_C.ALLOWED_METHODS + '\\r\\n';\n      } else if (code === 415) {\n        response += 'Accept: ' + SIP_C.ACCEPTED_BODY_TYPES + '\\r\\n';\n      }\n\n      response += 'Supported: ' + supported + '\\r\\n';\n\n      if (body) {\n        var length = Utils.str_utf8_length(body);\n\n        response += 'Content-Type: application/sdp\\r\\n';\n        response += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n        response += body;\n      } else {\n        response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n      }\n\n      this.server_transaction.receiveResponse(code, response, onSuccess, onFailure);\n    }\n\n    /**\n    * Stateless reply.\n    * -param {Number} code status code\n    * -param {String} reason reason phrase\n    */\n\n  }, {\n    key: 'reply_sl',\n    value: function reply_sl() {\n      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var vias = this.getHeaders('via');\n\n      // Validate code and reason values.\n      if (!code || code < 100 || code > 699) {\n        throw new TypeError('Invalid status_code: ' + code);\n      } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n        throw new TypeError('Invalid reason_phrase: ' + reason);\n      }\n\n      reason = reason || SIP_C.REASON_PHRASE[code] || '';\n\n      var response = 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n\n      var _iteratorNormalCompletion11 = true;\n      var _didIteratorError11 = false;\n      var _iteratorError11 = undefined;\n\n      try {\n        for (var _iterator11 = vias[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n          var via = _step11.value;\n\n          response += 'Via: ' + via + '\\r\\n';\n        }\n      } catch (err) {\n        _didIteratorError11 = true;\n        _iteratorError11 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion11 && _iterator11.return) {\n            _iterator11.return();\n          }\n        } finally {\n          if (_didIteratorError11) {\n            throw _iteratorError11;\n          }\n        }\n      }\n\n      var to = this.getHeader('To');\n\n      if (!this.to_tag && code > 100) {\n        to += ';tag=' + Utils.newTag();\n      } else if (this.to_tag && !this.s('to').hasParam('tag')) {\n        to += ';tag=' + this.to_tag;\n      }\n\n      response += 'To: ' + to + '\\r\\n';\n      response += 'From: ' + this.getHeader('From') + '\\r\\n';\n      response += 'Call-ID: ' + this.call_id + '\\r\\n';\n      response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n      response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n\n      this.transport.send(response);\n    }\n  }]);\n\n  return IncomingRequest;\n}(IncomingMessage);\n\nvar IncomingResponse = function (_IncomingMessage2) {\n  _inherits(IncomingResponse, _IncomingMessage2);\n\n  function IncomingResponse() {\n    _classCallCheck(this, IncomingResponse);\n\n    var _this3 = _possibleConstructorReturn(this, (IncomingResponse.__proto__ || Object.getPrototypeOf(IncomingResponse)).call(this));\n\n    _this3.headers = {};\n    _this3.status_code = null;\n    _this3.reason_phrase = null;\n    return _this3;\n  }\n\n  return IncomingResponse;\n}(IncomingMessage);\n\nmodule.exports = {\n  OutgoingRequest: OutgoingRequest,\n  InitialOutgoingInviteRequest: InitialOutgoingInviteRequest,\n  IncomingRequest: IncomingRequest,\n  IncomingResponse: IncomingResponse\n};\n\n//# sourceURL=webpack://ApolloSIP/./lib/SIPMessage.js?");

/***/ }),

/***/ "./lib/Service.js":
/*!************************!*\
  !*** ./lib/Service.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./lib/SIPMessage.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar RequestSender = __webpack_require__(/*! ./RequestSender */ \"./lib/RequestSender.js\");\nvar Exceptions = __webpack_require__(/*! ./Exceptions */ \"./lib/Exceptions.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:Service');\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(Service, _EventEmitter);\n\n  function Service(ua) {\n    _classCallCheck(this, Service);\n\n    var _this = _possibleConstructorReturn(this, (Service.__proto__ || Object.getPrototypeOf(Service)).call(this));\n\n    _this._ua = ua;\n    _this._request = null;\n    _this._closed = false;\n\n    _this._direction = null;\n    _this._local_identity = null;\n    _this._remote_identity = null;\n\n    // Whether an incoming message has been replied.\n    _this._is_replied = false;\n    return _this;\n  }\n\n  _createClass(Service, [{\n    key: 'send',\n    value: function send(target, event, body) {\n      var _this2 = this;\n\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var originalTarget = target;\n\n      if (target === undefined || event === undefined || body === undefined) {\n        throw new TypeError('Not enough arguments');\n      }\n\n      // Check target validity.\n      target = this._ua.normalizeTarget(target);\n      if (!target) {\n        throw new TypeError('Invalid target: ' + originalTarget);\n      }\n\n      // Get call options.\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var eventHandlers = options.eventHandlers || {};\n      var contentType = options.contentType || 'text/plain';\n      var params = { cseq: 1 };\n\n      // Set event handlers.\n      for (var handler in eventHandlers) {\n        if (Object.prototype.hasOwnProperty.call(eventHandlers, handler)) {\n          this.on(handler, eventHandlers[handler]);\n        }\n      }\n\n      extraHeaders.push('Event: ' + event);\n      extraHeaders.push('Content-Type: ' + contentType);\n\n      this._request = new SIPMessage.OutgoingRequest(SIP_C.SERVICE, target, this._ua, params, extraHeaders);\n\n      if (body) {\n        this._request.body = body;\n      }\n\n      var request_sender = new RequestSender(this._ua, this._request, {\n        onRequestTimeout: function onRequestTimeout() {\n          _this2._onRequestTimeout();\n        },\n        onTransportError: function onTransportError() {\n          _this2._onTransportError();\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          _this2._receiveResponse(response);\n        }\n      });\n\n      this._newService('local', this._request);\n\n      request_sender.send();\n    }\n  }, {\n    key: 'init_incoming',\n    value: function init_incoming(request) {\n      this._request = request;\n\n      this._newService('remote', request);\n\n      // Reply with a 200 OK if the user didn't reply.\n      if (!this._is_replied) {\n        this._is_replied = true;\n        request.reply(200);\n      }\n\n      this._close();\n    }\n\n    /**\n     * Accept the incoming Service\n     * Only valid for incoming Service\n     */\n\n  }, {\n    key: 'accept',\n    value: function accept() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var body = options.body;\n\n      if (this._direction !== 'incoming') {\n        throw new Exceptions.NotSupportedError('\"accept\" not supported for outgoing Service');\n      }\n\n      if (this._is_replied) {\n        throw new Error('incoming Service already replied');\n      }\n\n      this._is_replied = true;\n      this._request.reply(200, null, extraHeaders, body);\n    }\n\n    /**\n     * Reject the incoming Service\n     * Only valid for incoming Service\n     */\n\n  }, {\n    key: 'reject',\n    value: function reject() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var status_code = options.status_code || 480;\n      var reason_phrase = options.reason_phrase;\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var body = options.body;\n\n      if (this._direction !== 'incoming') {\n        throw new Exceptions.NotSupportedError('\"reject\" not supported for outgoing Service');\n      }\n\n      if (this._is_replied) {\n        throw new Error('incoming Service already replied');\n      }\n\n      if (status_code < 300 || status_code >= 700) {\n        throw new TypeError('Invalid status_code: ' + status_code);\n      }\n\n      this._is_replied = true;\n      this._request.reply(status_code, reason_phrase, extraHeaders, body);\n    }\n  }, {\n    key: '_receiveResponse',\n    value: function _receiveResponse(response) {\n      if (this._closed) {\n        return;\n      }\n      switch (true) {\n        case /^1[0-9]{2}$/.test(response.status_code):\n          // Ignore provisional responses.\n          break;\n\n        case /^2[0-9]{2}$/.test(response.status_code):\n          this._succeeded('remote', response);\n          break;\n\n        default:\n          {\n            var cause = Utils.sipErrorCause(response.status_code);\n\n            this._failed('remote', response, cause);\n            break;\n          }\n      }\n    }\n  }, {\n    key: '_onRequestTimeout',\n    value: function _onRequestTimeout() {\n      if (this._closed) {\n        return;\n      }\n      this._failed('system', null, SIP_C.causes.REQUEST_TIMEOUT);\n    }\n  }, {\n    key: '_onTransportError',\n    value: function _onTransportError() {\n      if (this._closed) {\n        return;\n      }\n      this._failed('system', null, SIP_C.causes.CONNECTION_ERROR);\n    }\n  }, {\n    key: '_close',\n    value: function _close() {\n      this._closed = true;\n      this._ua.destroyService(this);\n    }\n\n    /**\n     * Internal Callbacks\n     */\n\n  }, {\n    key: '_newService',\n    value: function _newService(originator, request) {\n      if (originator === 'remote') {\n        this._direction = 'incoming';\n        this._local_identity = request.to;\n        this._remote_identity = request.from;\n      } else if (originator === 'local') {\n        this._direction = 'outgoing';\n        this._local_identity = request.from;\n        this._remote_identity = request.to;\n      }\n\n      this._ua.newService(this, {\n        originator: originator,\n        service: this,\n        request: request\n      });\n    }\n  }, {\n    key: '_failed',\n    value: function _failed(originator, response, cause) {\n      debug('SERVICE failed');\n\n      this._close();\n\n      debug('emit \"failed\"');\n\n      this.emit('failed', {\n        originator: originator,\n        response: response || null,\n        cause: cause\n      });\n    }\n  }, {\n    key: '_succeeded',\n    value: function _succeeded(originator, response) {\n      debug('SERVICE succeeded');\n\n      this._close();\n\n      debug('emit \"succeeded\"');\n\n      this.emit('succeeded', {\n        originator: originator,\n        response: response\n      });\n    }\n  }, {\n    key: 'direction',\n    get: function get() {\n      return this._direction;\n    }\n  }, {\n    key: 'local_identity',\n    get: function get() {\n      return this._local_identity;\n    }\n  }, {\n    key: 'remote_identity',\n    get: function get() {\n      return this._remote_identity;\n    }\n  }]);\n\n  return Service;\n}(EventEmitter);\n\n//# sourceURL=webpack://ApolloSIP/./lib/Service.js?");

/***/ }),

/***/ "./lib/Socket.js":
/*!***********************!*\
  !*** ./lib/Socket.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./lib/Grammar.js\");\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:ERROR:Socket');\n\ndebugerror.log = console.warn.bind(console);\n\n/**\n * Interface documentation: http://jssip.net/documentation/$last_version/api/socket/\n *\n * interface Socket {\n *  attribute String via_transport\n *  attribute String url\n *  attribute String sip_uri\n *\n *  method connect();\n *  method disconnect();\n *  method send(data);\n *\n *  attribute EventHandler onconnect\n *  attribute EventHandler ondisconnect\n *  attribute EventHandler ondata\n * }\n *\n */\n\nexports.isSocket = function (socket) {\n  // Ignore if an array is given.\n  if (Array.isArray(socket)) {\n    return false;\n  }\n\n  if (typeof socket === 'undefined') {\n    debugerror('undefined SIP.Socket instance');\n\n    return false;\n  }\n\n  // Check Properties.\n  try {\n    if (!Utils.isString(socket.url)) {\n      debugerror('missing or invalid SIP.Socket url property');\n      throw new Error();\n    }\n\n    if (!Utils.isString(socket.via_transport)) {\n      debugerror('missing or invalid SIP.Socket via_transport property');\n      throw new Error();\n    }\n\n    if (Grammar.parse(socket.sip_uri, 'SIP_URI') === -1) {\n      debugerror('missing or invalid SIP.Socket sip_uri property');\n      throw new Error();\n    }\n  } catch (e) {\n    return false;\n  }\n\n  // Check Methods.\n  try {\n    ['connect', 'disconnect', 'send'].forEach(function (method) {\n      if (!Utils.isFunction(socket[method])) {\n        debugerror('missing or invalid SIP.Socket method: ' + method);\n        throw new Error();\n      }\n    });\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n};\n\n//# sourceURL=webpack://ApolloSIP/./lib/Socket.js?");

/***/ }),

/***/ "./lib/SocketIOInterface.js":
/*!**********************************!*\
  !*** ./lib/SocketIOInterface.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar IO = __webpack_require__(/*! socket.io-client */ \"./node_modules/socket.io-client/lib/index.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./lib/Grammar.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:SocketIOInterface');\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:ERROR:SocketIOInterface');\n\ndebugerror.log = console.warn.bind(console);\n\nfunction on(obj, ev, fn) {\n  obj.on(ev, fn);\n\n  return {\n    destroy: function destroy() {\n      obj.removeListener(ev, fn);\n    }\n  };\n}\n\nmodule.exports = function () {\n  function SocketIOInterface(url, options) {\n    _classCallCheck(this, SocketIOInterface);\n\n    debug('new() [url:\"%s\"]', url);\n\n    this._url = url;\n    this._options = options;\n    this._sip_uri = null;\n    this._via_transport = null;\n    this._socket = null;\n\n    var parsed_url = Grammar.parse(url, 'absoluteURI');\n\n    if (parsed_url === -1) {\n      debugerror('invalid WebSocket URI: ' + url);\n      throw new TypeError('Invalid argument: ' + url);\n    } else if (parsed_url.scheme !== 'wss' && parsed_url.scheme !== 'ws') {\n      debugerror('invalid WebSocket URI scheme: ' + parsed_url.scheme);\n      throw new TypeError('Invalid argument: ' + url);\n    } else {\n      this._sip_uri = 'sip:' + parsed_url.host + (parsed_url.port ? ':' + parsed_url.port : '') + ';transport=ws';\n      this._via_transport = parsed_url.scheme.toUpperCase();\n    }\n  }\n\n  _createClass(SocketIOInterface, [{\n    key: 'connect',\n    value: function connect() {\n      debug('connect()');\n\n      if (this.isConnected()) {\n        debug('WebSocket ' + this._url + ' is already connected');\n\n        return;\n      } else if (this.isConnecting()) {\n        debug('WebSocket ' + this._url + ' is connecting');\n\n        return;\n      }\n\n      if (this._socket) {\n        this.disconnect();\n      }\n\n      debug('connecting to WebSocket ' + this._url);\n\n      try {\n        this._socket = new IO(this._url, this._options);\n\n        this._socket.binaryType = 'arraybuffer';\n\n        this.onopen = on(this._socket, 'connect', this._onOpen.bind(this));\n        this.onclose = on(this._socket, 'disconnect', this._onClose.bind(this));\n        this.onmessage = on(this._socket, 'message', this._onMessage.bind(this));\n        this.onerror = on(this._socket, 'error', this._onError.bind(this));\n      } catch (e) {\n        this._onError(e);\n      }\n    }\n  }, {\n    key: 'disconnect',\n    value: function disconnect() {\n      debug('disconnect()');\n\n      if (this._socket) {\n        // Unbind websocket event callbacks.\n        this.onopen.destroy();\n        this.onclose.destroy();\n        this.onmessage.destroy();\n        this.onerror.destroy();\n\n        this._socket.close();\n        this._socket = null;\n      }\n    }\n  }, {\n    key: 'send',\n    value: function send(message) {\n      debug('send()');\n\n      if (this.isConnected()) {\n        this._socket.send(message);\n\n        return true;\n      } else {\n        debugerror('unable to send message, WebSocket is not open');\n\n        return false;\n      }\n    }\n  }, {\n    key: 'isConnected',\n    value: function isConnected() {\n      return this._socket && this._socket.connected;\n    }\n  }, {\n    key: 'isConnecting',\n    value: function isConnecting() {\n      return this._socket && this._socket.io.readyState === 'connecting';\n    }\n\n    /**\n     * WebSocket Event Handlers\n     */\n\n  }, {\n    key: '_onOpen',\n    value: function _onOpen() {\n      debug('WebSocket ' + this._url + ' connected');\n\n      this.onconnect();\n    }\n  }, {\n    key: '_onClose',\n    value: function _onClose(_ref) {\n      var wasClean = _ref.wasClean,\n          code = _ref.code,\n          reason = _ref.reason;\n\n      debug('WebSocket ' + this._url + ' closed');\n\n      if (wasClean === false) {\n        debug('WebSocket abrupt disconnection');\n      }\n\n      var data = {\n        socket: this,\n        error: !wasClean,\n        code: code,\n        reason: reason\n      };\n\n      this.ondisconnect(data);\n    }\n  }, {\n    key: '_onMessage',\n    value: function _onMessage(data) {\n      debug('received WebSocket message');\n\n      this.ondata(data);\n    }\n  }, {\n    key: '_onError',\n    value: function _onError(e) {\n      debugerror('WebSocket ' + this._url + ' error: %o', e);\n    }\n  }, {\n    key: 'via_transport',\n    get: function get() {\n      return this._via_transport;\n    },\n    set: function set(value) {\n      this._via_transport = value.toUpperCase();\n    }\n  }, {\n    key: 'sip_uri',\n    get: function get() {\n      return this._sip_uri;\n    }\n  }, {\n    key: 'url',\n    get: function get() {\n      return this._url;\n    }\n  }]);\n\n  return SocketIOInterface;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./lib/SocketIOInterface.js?");

/***/ }),

/***/ "./lib/Subscription.js":
/*!*****************************!*\
  !*** ./lib/Subscription.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./lib/SIPMessage.js\");\nvar Dialog = __webpack_require__(/*! ./Dialog */ \"./lib/Dialog.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar RequestSender = __webpack_require__(/*! ./RequestSender */ \"./lib/RequestSender.js\");\nvar Timers = __webpack_require__(/*! ./Timers */ \"./lib/Timers.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:Subscription');\n\nvar C = {\n  // RTCSession states.\n  STATUS_NULL: 0,\n  STATUS_SUBSCRIBE_SENT: 1,\n  STATUS_1XX_RECEIVED: 2,\n  STATUS_WAITING_FOR_NOTIFY: 3,\n  STATUS_PENDING: 4,\n  STATUS_TERMINATED: 5,\n  STATUS_ACTIVE: 6\n};\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(Subscription, _EventEmitter);\n\n  function Subscription(ua) {\n    _classCallCheck(this, Subscription);\n\n    var _this = _possibleConstructorReturn(this, (Subscription.__proto__ || Object.getPrototypeOf(Subscription)).call(this));\n\n    _this._ua = ua;\n    _this._id = null;\n    _this._status = C.STATUS_NULL;\n    _this._from_tag = null;\n    _this._to_tag = null;\n    _this._expires = SIP_C.SUBSCRIPTION_EXPIRES;\n    _this._contact = _this._ua.contact.toString();\n    _this._earlyDialogs = {};\n    _this._dialog = null;\n    _this._request = null;\n    _this._timers = { N: null, sub_duration: null };\n\n    _this._target = null;\n    _this._event = null;\n    _this._options = null;\n    _this._contentType = null;\n    return _this;\n  }\n\n  _createClass(Subscription, [{\n    key: 'subscribe',\n    value: function subscribe(target, event) {\n      var _this2 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (this._status === C.STATUS_ACTIVE) {\n        this._refresh();\n\n        return;\n      } else if (this._status === C.STATUS_SUBSCRIBE_SENT || this._status === C.STATUS_1XX_RECEIVED || this._status === C.STATUS_WAITING_FOR_NOTIFY) {\n        return;\n      }\n\n      var originalTarget = target;\n\n      if (target === undefined || event === undefined) {\n        throw new TypeError('Not enough arguments');\n      }\n\n      // Check target validity.\n      target = this._ua.normalizeTarget(target);\n      if (!target) {\n        throw new TypeError('Invalid target: ' + originalTarget);\n      }\n\n      // Get call options.\n      var extraHeaders = Utils.cloneArray(options.extraHeaders);\n      var eventHandlers = options.eventHandlers || {};\n      var contentType = options.contentType || 'text/plain';\n\n      if (Utils.isDecimal(options.expires)) {\n        this._expires = options.expires;\n      } else {\n        debug('expires must be a decimal. Using default of 3600.');\n        this._expires = SIP_C.SUBSCRIPTION_EXPIRES;\n      }\n\n      // Set event handlers.\n      for (var handler in eventHandlers) {\n        if (Object.prototype.hasOwnProperty.call(eventHandlers, handler)) {\n          this.on(handler, eventHandlers[handler]);\n        }\n      }\n\n      this._target = target;\n      this._event = event;\n      this._options = options;\n      this._contentType = contentType;\n\n      delete this._options.eventHandlers;\n\n      extraHeaders.push('Event: ' + this._event);\n      extraHeaders.push('Expires: ' + this._expires);\n      extraHeaders.push('Contact: ' + this._contact);\n      extraHeaders.push('Content-Type: ' + this._contentType);\n\n      this._request = new SIPMessage.OutgoingRequest(SIP_C.SUBSCRIBE, target, this._ua, null, extraHeaders);\n\n      if (options.body) {\n        this._request.body = options.body;\n      }\n\n      clearTimeout(this._timers.sub_duration);\n      clearTimeout(this._timers.N);\n\n      this._timers.N = setTimeout(function () {\n        _this2._timer_fire();\n      }, Timers.TIMER_N);\n\n      var request_sender = new RequestSender(this._ua, this._request, {\n        onRequestTimeout: function onRequestTimeout() {\n          _this2._onRequestTimeout();\n        },\n        onTransportError: function onTransportError() {\n          _this2._onTransportError();\n        },\n        onReceiveResponse: function onReceiveResponse(response) {\n          _this2._receiveResponse(response);\n        }\n      });\n\n      request_sender.send();\n\n      this._status = C.STATUS_SUBSCRIBE_SENT;\n    }\n  }, {\n    key: 'terminate',\n    value: function terminate() {\n      if (this._status === C.STATUS_TERMINATED) {\n        return;\n      } else if (this._status === C.STATUS_ACTIVE) {\n        var extraHeaders = [];\n\n        extraHeaders.push('Event: ' + this._event);\n        extraHeaders.push('Expires: 0');\n        extraHeaders.push('Contact: ' + this._contact);\n        extraHeaders.push('Content-Type: ' + this._contentType);\n\n        this.sendRequest(SIP_C.SUBSCRIBE, {\n          extraHeaders: extraHeaders,\n          body: this._request.body\n        });\n      }\n\n      clearTimeout(this._timers.N);\n      clearTimeout(this._timers.sub_duration);\n\n      this._status = C.STATUS_TERMINATED;\n      this._destroyDialog();\n      this._ua.destroySubscription(this);\n    }\n  }, {\n    key: '_receiveResponse',\n    value: function _receiveResponse(response) {\n      var _this3 = this;\n\n      if (this._status === C.STATUS_SUBSCRIBE_SENT && response.status_code >= 300) {\n        var cause = Utils.sipErrorCause(response.status_code);\n\n        this._failed('remote', response, cause);\n      }\n\n      if (this._status !== C.STATUS_SUBSCRIBE_SENT) {\n        return;\n      }\n\n      switch (true) {\n        case /^100$/.test(response.status_code):\n          this._status = C.STATUS_1XX_RECEIVED;\n          break;\n\n        case /^1[0-9]{2}$/.test(response.status_code):\n          {\n            // Do nothing with 1xx responses without To tag.\n            if (!response.to_tag) {\n              debug('1xx response received without to tag');\n              break;\n            }\n\n            // Create Early Dialog if 1XX comes with contact.\n            if (response.hasHeader('contact')) {\n              // An error on dialog creation will fire 'failed' event.\n              if (!this._createDialog(response, 'UAS', true)) {\n                break;\n              }\n            }\n\n            this._status = C.STATUS_1XX_RECEIVED;\n            this._progress('remote', response);\n            break;\n          }\n\n        case /^2[0-9]{2}$/.test(response.status_code):\n          {\n            // Do nothing with 1xx responses without To tag.\n            if (!response.to_tag) {\n              debug('2xx response received without to tag');\n              break;\n            }\n\n            this._status = C.STATUS_WAITING_FOR_NOTIFY;\n\n            var expires = response.getHeader('Expires');\n\n            if (Utils.isDecimal(expires) && expires <= this._expires) {\n              // Preserve new expires value for subsequent requests\n              this._expires = expires;\n              this._timers.sub_duration = setTimeout(function () {\n                _this3._refresh();\n              }, expires * 900);\n            } else if (!expires) {\n              debug('Expires header missing in a 200-class response to SUBSCRIBE');\n              this._failed('remote', response, SIP_C.causes.EXPIRES_HEADER_MISSING);\n            } else {\n              this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');\n              this._failed('remote', response, SIP_C.causes.INVALID_EXPIRES_HEADER);\n            }\n\n            if (response.hasHeader('contact')) {\n              this._id = response.call_id + response.to_tag + this._event;\n              this._newSubscription('local', this._request);\n              this._succeeded('remote', response);\n            }\n\n            break;\n          }\n\n        default:\n          {\n            var _cause = Utils.sipErrorCause(response.status_code);\n\n            this._failed('remote', response, _cause);\n          }\n      }\n    }\n  }, {\n    key: '_onRequestTimeout',\n    value: function _onRequestTimeout() {\n      this.terminate();\n      this._failed('system', null, SIP_C.causes.REQUEST_TIMEOUT);\n    }\n  }, {\n    key: '_onTransportError',\n    value: function _onTransportError() {\n      this.terminate();\n      this._failed('system', null, SIP_C.causes.CONNECTION_ERROR);\n    }\n\n    /**\n     * Internal Callbacks\n     */\n\n  }, {\n    key: '_timer_fire',\n    value: function _timer_fire() {\n      if (this._status === C.STATUS_ACTIVE) {\n        this.refresh();\n      } else {\n        this.terminate();\n      }\n    }\n  }, {\n    key: '_newSubscription',\n    value: function _newSubscription(originator, request) {\n      debug('new subscription');\n      this._ua.newSubscription(this, {\n        originator: originator,\n        subscription: this,\n        request: request\n      });\n    }\n  }, {\n    key: '_refresh',\n    value: function _refresh() {\n      if (this._status === C.STATUS_ACTIVE) {\n        this.sendRequest(SIP_C.SUBSCRIBE, {\n          extraHeaders: this._request.extraHeaders,\n          body: this._request.body\n        });\n      }\n    }\n\n    /**\n     * Dialog Management\n     */\n\n  }, {\n    key: '_createDialog',\n    value: function _createDialog(message, type, early) {\n      var local_tag = type === 'UAS' ? message.to_tag : message.from_tag;\n      var remote_tag = type === 'UAS' ? message.from_tag : message.to_tag;\n      var id = message.call_id + local_tag + remote_tag;\n\n      var early_dialog = this._earlyDialogs[id];\n\n      // Early Dialog.\n      if (early) {\n        if (early_dialog) {\n          return true;\n        } else {\n          early_dialog = new Dialog(this, message, type, Dialog.C.STATUS_EARLY);\n\n          // Dialog has been successfully created.\n          if (early_dialog.error) {\n            debug(early_dialog.error);\n            this._failed('remote', message, SIP_C.causes.INTERNAL_ERROR);\n\n            return false;\n          } else {\n            this._earlyDialogs[id] = early_dialog;\n\n            return true;\n          }\n        }\n      }\n\n      // Confirmed Dialog.\n      else {\n          this._from_tag = message.from_tag;\n          this._to_tag = message.to_tag;\n\n          // In case the dialog is in _early_ state, update it.\n          if (early_dialog) {\n            early_dialog.update(message, type);\n            this._dialog = early_dialog;\n            this._dialog._local_seqnum = this._request.cseq;\n            delete this._earlyDialogs[id];\n\n            return true;\n          }\n\n          // Otherwise, create a _confirmed_ dialog.\n          var dialog = new Dialog(this, message, type);\n\n          if (dialog.error) {\n            debug(dialog.error);\n            this._failed('remote', message, SIP_C.causes.INTERNAL_ERROR);\n\n            return false;\n          } else {\n            this._dialog = dialog;\n            this._dialog._local_seqnum = this._request.cseq;\n\n            return true;\n          }\n        }\n    }\n  }, {\n    key: '_destroyDialog',\n    value: function _destroyDialog() {\n      // Terminate confirmed dialog.\n      if (this._dialog) {\n        this._dialog.terminate();\n        delete this._dialog;\n      }\n\n      // Terminate early dialogs.\n      for (var dialog in this._earlyDialogs) {\n        if (Object.prototype.hasOwnProperty.call(this._earlyDialogs, dialog)) {\n          this._earlyDialogs[dialog].terminate();\n          delete this._earlyDialogs[dialog];\n        }\n      }\n    }\n  }, {\n    key: '_matchEvent',\n    value: function _matchEvent(request) {\n      // Check mandatory header Event\n      if (!request.hasHeader('Event')) {\n        debug('missing Event header');\n\n        return false;\n      }\n      // Check mandatory header Subscription-State\n      if (!request.hasHeader('Subscription-State')) {\n        debug('missing Subscription-State header');\n\n        return false;\n      }\n\n      // Check whether the event in NOTIFY matches the event in SUBSCRIBE\n      var event = request.parseHeader('event').event;\n\n      if (this._event !== event) {\n        debug('event match failed');\n        request.reply(481, 'Event Match Failed');\n\n        return false;\n      } else {\n        return true;\n      }\n    }\n\n    /**\n     * Send a generic in-dialog Request\n     */\n\n  }, {\n    key: 'sendRequest',\n    value: function sendRequest(method, options) {\n      var _this4 = this;\n\n      debug('sendRequest()');\n\n      options.eventHandlers = {\n        onSuccessResponse: function onSuccessResponse(response) {\n          _this4._succeeded('remote', response);\n        },\n        onErrorResponse: function onErrorResponse(response) {\n          _this4._failed('remote', response, SIP_C.causes.SIP_FAILURE_CODE);\n        },\n        onTransportError: function onTransportError() {\n          _this4._onTransportError();\n        },\n        onRequestTimeout: function onRequestTimeout() {\n          _this4._onRequestTimeout();\n        },\n        onDialogError: function onDialogError(response) {\n          _this4._failed('local', response, SIP_C.causes.DIALOG_ERROR);\n        }\n      };\n\n      return this._dialog.sendRequest(method, options);\n    }\n\n    /**\n     * In dialog Request Reception\n     */\n\n  }, {\n    key: 'receiveRequest',\n    value: function receiveRequest(request) {\n      var _this5 = this;\n\n      debug('receiveRequest()');\n\n      if (!this._matchEvent(request)) {\n        // checks event and subscription_state headers\n        request.reply(489);\n\n        return;\n      }\n\n      if (!this._dialog) {\n        if (!this._createDialog(request, 'UAS', false)) {\n          debug('failed to create comfirm dialog');\n        }\n      }\n\n      var sub_state = request.parseHeader('Subscription-State');\n\n      request.reply(200);\n\n      clearTimeout(this._timers.N);\n\n      if (request.body) this._notify('remote', request);\n\n      if (this._status === C.STATUS_TERMINATED) {\n        debug('received notify while subscription is terminated');\n\n        return;\n      }\n\n      switch (sub_state.state) {\n        case 'active':\n          setExpiresTimeout.call(this);\n          this._status = C.STATUS_ACTIVE;\n          break;\n        case 'pending':\n          if (this.state === C.STATUS_WAITING_FOR_NOTIFY || this.state === C.STATUS_SUBSCRIBE_SENT) {\n            setExpiresTimeout.call(this);\n          }\n          this.state = C.STATUS_PENDING;\n          break;\n        case 'terminated':\n          clearTimeout(this._timers.sub_duration);\n          if (sub_state.reason) {\n            debug('terminating subscription with reason ' + sub_state.reason);\n            switch (sub_state.reason) {\n              case 'deactivated':\n              case 'timeout':\n                this.subscribe(this._target, this._event, this._options);\n\n                return;\n              case 'probation':\n              case 'giveup':\n                if (sub_state.params && sub_state.params['retry-after']) {\n                  this.timers.sub_duration = setTimeout(function () {\n                    _this5.subscribe(_this5._target, _this5._event, _this5._options);\n                  }, sub_state.params['retry-after']);\n                } else {\n                  this.subscribe(this._target, this._event, this._options);\n                }\n\n                return;\n              case 'rejected':\n              case 'noresource':\n              case 'invariant':\n                break;\n            }\n          }\n          this.terminate();\n          break;\n      }\n\n      function setExpiresTimeout() {\n        var _this6 = this;\n\n        if (sub_state.expires) {\n          clearTimeout(this._timers.sub_duration);\n\n          sub_state.expires = Math.min(this._expires, Math.max(sub_state.expires, 0));\n\n          this._timers.sub_duration = setTimeout(function () {\n            _this6._refresh();\n          }, sub_state.expires * 900);\n        }\n      }\n    }\n  }, {\n    key: '_notify',\n    value: function _notify(originator, request) {\n      debug('emit \"notify\"');\n\n      this.emit('notify', {\n        originator: originator,\n        request: request || null,\n        notify: request.body\n      });\n    }\n  }, {\n    key: '_progress',\n    value: function _progress(originator, response) {\n      debug('subscription progress');\n\n      this.emit('progress', {\n        originator: originator,\n        response: response || null\n      });\n    }\n  }, {\n    key: '_succeeded',\n    value: function _succeeded(originator, response) {\n      debug('subscription successed');\n\n      this.emit('successed', {\n        originator: originator,\n        response: response || null\n      });\n    }\n  }, {\n    key: '_failed',\n    value: function _failed(originator, response, cause) {\n      debug('subscription failed');\n\n      this.terminate();\n\n      this.emit('failed', {\n        originator: originator,\n        response: response || null,\n        cause: cause\n      });\n    }\n  }, {\n    key: 'id',\n    get: function get() {\n      return this._id;\n    }\n  }, {\n    key: 'isActive',\n    get: function get() {\n      return this._status === C.STATUS_ACTIVE;\n    }\n  }]);\n\n  return Subscription;\n}(EventEmitter);\n\n//# sourceURL=webpack://ApolloSIP/./lib/Subscription.js?");

/***/ }),

/***/ "./lib/Timers.js":
/*!***********************!*\
  !*** ./lib/Timers.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar T1 = 500,\n    T2 = 4000,\n    T4 = 5000;\n\nmodule.exports = {\n  T1: T1,\n  T2: T2,\n  T4: T4,\n  TIMER_B: 64 * T1,\n  TIMER_D: 0 * T1,\n  TIMER_F: 64 * T1,\n  TIMER_H: 64 * T1,\n  TIMER_I: 0 * T1,\n  TIMER_J: 0 * T1,\n  TIMER_K: 0 * T4,\n  TIMER_L: 64 * T1,\n  TIMER_M: 64 * T1,\n  TIMER_N: 64 * T1,\n  PROVISIONAL_RESPONSE_INTERVAL: 60000 // See RFC 3261 Section 13.3.1.1\n};\n\n//# sourceURL=webpack://ApolloSIP/./lib/Timers.js?");

/***/ }),

/***/ "./lib/Transactions.js":
/*!*****************************!*\
  !*** ./lib/Transactions.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./lib/SIPMessage.js\");\nvar Timers = __webpack_require__(/*! ./Timers */ \"./lib/Timers.js\");\nvar debugnict = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:NonInviteClientTransaction');\nvar debugict = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:InviteClientTransaction');\nvar debugact = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:AckClientTransaction');\nvar debugnist = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:NonInviteServerTransaction');\nvar debugist = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:InviteServerTransaction');\n\nvar C = {\n  // Transaction states.\n  STATUS_TRYING: 1,\n  STATUS_PROCEEDING: 2,\n  STATUS_CALLING: 3,\n  STATUS_ACCEPTED: 4,\n  STATUS_COMPLETED: 5,\n  STATUS_TERMINATED: 6,\n  STATUS_CONFIRMED: 7,\n\n  // Transaction types.\n  NON_INVITE_CLIENT: 'nict',\n  NON_INVITE_SERVER: 'nist',\n  INVITE_CLIENT: 'ict',\n  INVITE_SERVER: 'ist'\n};\n\nvar NonInviteClientTransaction = function (_EventEmitter) {\n  _inherits(NonInviteClientTransaction, _EventEmitter);\n\n  function NonInviteClientTransaction(ua, transport, request, eventHandlers) {\n    _classCallCheck(this, NonInviteClientTransaction);\n\n    var _this = _possibleConstructorReturn(this, (NonInviteClientTransaction.__proto__ || Object.getPrototypeOf(NonInviteClientTransaction)).call(this));\n\n    _this.type = C.NON_INVITE_CLIENT;\n    _this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n    _this.ua = ua;\n    _this.transport = transport;\n    _this.request = request;\n    _this.eventHandlers = eventHandlers;\n\n    var via = 'SIP/2.0/' + transport.via_transport;\n\n    via += ' ' + ua.configuration.via_host + ';branch=' + _this.id;\n\n    _this.request.setHeader('via', via);\n\n    _this.ua.newTransaction(_this);\n    return _this;\n  }\n\n  _createClass(NonInviteClientTransaction, [{\n    key: 'stateChanged',\n    value: function stateChanged(state) {\n      this.state = state;\n      this.emit('stateChanged');\n    }\n  }, {\n    key: 'send',\n    value: function send() {\n      var _this2 = this;\n\n      this.stateChanged(C.STATUS_TRYING);\n      this.F = setTimeout(function () {\n        _this2.timer_F();\n      }, Timers.TIMER_F);\n\n      if (!this.transport.send(this.request)) {\n        this.onTransportError();\n      }\n    }\n  }, {\n    key: 'onTransportError',\n    value: function onTransportError() {\n      debugnict('transport error occurred, deleting transaction ' + this.id);\n      clearTimeout(this.F);\n      clearTimeout(this.K);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n      this.eventHandlers.onTransportError();\n    }\n  }, {\n    key: 'timer_F',\n    value: function timer_F() {\n      debugnict('Timer F expired for transaction ' + this.id);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n      this.eventHandlers.onRequestTimeout();\n    }\n  }, {\n    key: 'timer_K',\n    value: function timer_K() {\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }, {\n    key: 'receiveResponse',\n    value: function receiveResponse(response) {\n      var _this3 = this;\n\n      var status_code = response.status_code;\n\n      if (status_code < 200) {\n        switch (this.state) {\n          case C.STATUS_TRYING:\n          case C.STATUS_PROCEEDING:\n            this.stateChanged(C.STATUS_PROCEEDING);\n            this.eventHandlers.onReceiveResponse(response);\n            break;\n        }\n      } else {\n        switch (this.state) {\n          case C.STATUS_TRYING:\n          case C.STATUS_PROCEEDING:\n            this.stateChanged(C.STATUS_COMPLETED);\n            clearTimeout(this.F);\n\n            if (status_code === 408) {\n              this.eventHandlers.onRequestTimeout();\n            } else {\n              this.eventHandlers.onReceiveResponse(response);\n            }\n\n            this.K = setTimeout(function () {\n              _this3.timer_K();\n            }, Timers.TIMER_K);\n            break;\n          case C.STATUS_COMPLETED:\n            break;\n        }\n      }\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  return NonInviteClientTransaction;\n}(EventEmitter);\n\nvar InviteClientTransaction = function (_EventEmitter2) {\n  _inherits(InviteClientTransaction, _EventEmitter2);\n\n  function InviteClientTransaction(ua, transport, request, eventHandlers) {\n    _classCallCheck(this, InviteClientTransaction);\n\n    var _this4 = _possibleConstructorReturn(this, (InviteClientTransaction.__proto__ || Object.getPrototypeOf(InviteClientTransaction)).call(this));\n\n    _this4.type = C.INVITE_CLIENT;\n    _this4.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n    _this4.ua = ua;\n    _this4.transport = transport;\n    _this4.request = request;\n    _this4.eventHandlers = eventHandlers;\n    request.transaction = _this4;\n\n    var via = 'SIP/2.0/' + transport.via_transport;\n\n    via += ' ' + ua.configuration.via_host + ';branch=' + _this4.id;\n\n    _this4.request.setHeader('via', via);\n\n    _this4.ua.newTransaction(_this4);\n    return _this4;\n  }\n\n  _createClass(InviteClientTransaction, [{\n    key: 'stateChanged',\n    value: function stateChanged(state) {\n      this.state = state;\n      this.emit('stateChanged');\n    }\n  }, {\n    key: 'send',\n    value: function send() {\n      var _this5 = this;\n\n      this.stateChanged(C.STATUS_CALLING);\n      this.B = setTimeout(function () {\n        _this5.timer_B();\n      }, Timers.TIMER_B);\n\n      if (!this.transport.send(this.request)) {\n        this.onTransportError();\n      }\n    }\n  }, {\n    key: 'onTransportError',\n    value: function onTransportError() {\n      clearTimeout(this.B);\n      clearTimeout(this.D);\n      clearTimeout(this.M);\n\n      if (this.state !== C.STATUS_ACCEPTED) {\n        debugict('transport error occurred, deleting transaction ' + this.id);\n        this.eventHandlers.onTransportError();\n      }\n\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n\n    // RFC 6026 7.2.\n\n  }, {\n    key: 'timer_M',\n    value: function timer_M() {\n      debugict('Timer M expired for transaction ' + this.id);\n\n      if (this.state === C.STATUS_ACCEPTED) {\n        clearTimeout(this.B);\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.ua.destroyTransaction(this);\n      }\n    }\n\n    // RFC 3261 17.1.1.\n\n  }, {\n    key: 'timer_B',\n    value: function timer_B() {\n      debugict('Timer B expired for transaction ' + this.id);\n      if (this.state === C.STATUS_CALLING) {\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.ua.destroyTransaction(this);\n        this.eventHandlers.onRequestTimeout();\n      }\n    }\n  }, {\n    key: 'timer_D',\n    value: function timer_D() {\n      debugict('Timer D expired for transaction ' + this.id);\n      clearTimeout(this.B);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }, {\n    key: 'sendACK',\n    value: function sendACK(response) {\n      var _this6 = this;\n\n      var ack = new SIPMessage.OutgoingRequest(SIP_C.ACK, this.request.ruri, this.ua, {\n        'route_set': this.request.getHeader('route'),\n        'call_id': this.request.getHeader('call-id'),\n        'cseq': this.request.cseq\n      });\n\n      ack.setHeader('from', this.request.getHeader('from'));\n      ack.setHeader('via', this.request.getHeader('via'));\n      ack.setHeader('to', response.getHeader('to'));\n\n      this.D = setTimeout(function () {\n        _this6.timer_D();\n      }, Timers.TIMER_D);\n\n      this.transport.send(ack);\n    }\n  }, {\n    key: 'cancel',\n    value: function cancel(reason) {\n      // Send only if a provisional response (>100) has been received.\n      if (this.state !== C.STATUS_PROCEEDING) {\n        return;\n      }\n\n      var cancel = new SIPMessage.OutgoingRequest(SIP_C.CANCEL, this.request.ruri, this.ua, {\n        'route_set': this.request.getHeader('route'),\n        'call_id': this.request.getHeader('call-id'),\n        'cseq': this.request.cseq\n      });\n\n      cancel.setHeader('from', this.request.getHeader('from'));\n      cancel.setHeader('via', this.request.getHeader('via'));\n      cancel.setHeader('to', this.request.getHeader('to'));\n\n      if (reason) {\n        cancel.setHeader('reason', reason);\n      }\n\n      this.transport.send(cancel);\n    }\n  }, {\n    key: 'receiveResponse',\n    value: function receiveResponse(response) {\n      var _this7 = this;\n\n      var status_code = response.status_code;\n\n      if (status_code >= 100 && status_code <= 199) {\n        switch (this.state) {\n          case C.STATUS_CALLING:\n            this.stateChanged(C.STATUS_PROCEEDING);\n            this.eventHandlers.onReceiveResponse(response);\n            break;\n          case C.STATUS_PROCEEDING:\n            this.eventHandlers.onReceiveResponse(response);\n            break;\n        }\n      } else if (status_code >= 200 && status_code <= 299) {\n        switch (this.state) {\n          case C.STATUS_CALLING:\n          case C.STATUS_PROCEEDING:\n            this.stateChanged(C.STATUS_ACCEPTED);\n            this.M = setTimeout(function () {\n              _this7.timer_M();\n            }, Timers.TIMER_M);\n            this.eventHandlers.onReceiveResponse(response);\n            break;\n          case C.STATUS_ACCEPTED:\n            this.eventHandlers.onReceiveResponse(response);\n            break;\n        }\n      } else if (status_code >= 300 && status_code <= 699) {\n        switch (this.state) {\n          case C.STATUS_CALLING:\n          case C.STATUS_PROCEEDING:\n            this.stateChanged(C.STATUS_COMPLETED);\n            this.sendACK(response);\n            this.eventHandlers.onReceiveResponse(response);\n            break;\n          case C.STATUS_COMPLETED:\n            this.sendACK(response);\n            break;\n        }\n      }\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  return InviteClientTransaction;\n}(EventEmitter);\n\nvar AckClientTransaction = function (_EventEmitter3) {\n  _inherits(AckClientTransaction, _EventEmitter3);\n\n  function AckClientTransaction(ua, transport, request, eventHandlers) {\n    _classCallCheck(this, AckClientTransaction);\n\n    var _this8 = _possibleConstructorReturn(this, (AckClientTransaction.__proto__ || Object.getPrototypeOf(AckClientTransaction)).call(this));\n\n    _this8.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n    _this8.transport = transport;\n    _this8.request = request;\n    _this8.eventHandlers = eventHandlers;\n\n    var via = 'SIP/2.0/' + transport.via_transport;\n\n    via += ' ' + ua.configuration.via_host + ';branch=' + _this8.id;\n\n    _this8.request.setHeader('via', via);\n    return _this8;\n  }\n\n  _createClass(AckClientTransaction, [{\n    key: 'send',\n    value: function send() {\n      if (!this.transport.send(this.request)) {\n        this.onTransportError();\n      }\n    }\n  }, {\n    key: 'onTransportError',\n    value: function onTransportError() {\n      debugact('transport error occurred for transaction ' + this.id);\n      this.eventHandlers.onTransportError();\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  return AckClientTransaction;\n}(EventEmitter);\n\nvar NonInviteServerTransaction = function (_EventEmitter4) {\n  _inherits(NonInviteServerTransaction, _EventEmitter4);\n\n  function NonInviteServerTransaction(ua, transport, request) {\n    _classCallCheck(this, NonInviteServerTransaction);\n\n    var _this9 = _possibleConstructorReturn(this, (NonInviteServerTransaction.__proto__ || Object.getPrototypeOf(NonInviteServerTransaction)).call(this));\n\n    _this9.type = C.NON_INVITE_SERVER;\n    _this9.id = request.via_branch;\n    _this9.ua = ua;\n    _this9.transport = transport;\n    _this9.request = request;\n    _this9.last_response = '';\n    request.server_transaction = _this9;\n\n    _this9.state = C.STATUS_TRYING;\n\n    ua.newTransaction(_this9);\n    return _this9;\n  }\n\n  _createClass(NonInviteServerTransaction, [{\n    key: 'stateChanged',\n    value: function stateChanged(state) {\n      this.state = state;\n      this.emit('stateChanged');\n    }\n  }, {\n    key: 'timer_J',\n    value: function timer_J() {\n      debugnist('Timer J expired for transaction ' + this.id);\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }, {\n    key: 'onTransportError',\n    value: function onTransportError() {\n      if (!this.transportError) {\n        this.transportError = true;\n\n        debugnist('transport error occurred, deleting transaction ' + this.id);\n\n        clearTimeout(this.J);\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.ua.destroyTransaction(this);\n      }\n    }\n  }, {\n    key: 'receiveResponse',\n    value: function receiveResponse(status_code, response, onSuccess, onFailure) {\n      var _this10 = this;\n\n      if (status_code === 100) {\n        /* RFC 4320 4.1\n         * 'A SIP element MUST NOT\n         * send any provisional response with a\n         * Status-Code other than 100 to a non-INVITE request.'\n         */\n        switch (this.state) {\n          case C.STATUS_TRYING:\n            this.stateChanged(C.STATUS_PROCEEDING);\n            if (!this.transport.send(response)) {\n              this.onTransportError();\n            }\n            break;\n          case C.STATUS_PROCEEDING:\n            this.last_response = response;\n            if (!this.transport.send(response)) {\n              this.onTransportError();\n              if (onFailure) {\n                onFailure();\n              }\n            } else if (onSuccess) {\n              onSuccess();\n            }\n            break;\n        }\n      } else if (status_code >= 200 && status_code <= 699) {\n        switch (this.state) {\n          case C.STATUS_TRYING:\n          case C.STATUS_PROCEEDING:\n            this.stateChanged(C.STATUS_COMPLETED);\n            this.last_response = response;\n            this.J = setTimeout(function () {\n              _this10.timer_J();\n            }, Timers.TIMER_J);\n            if (!this.transport.send(response)) {\n              this.onTransportError();\n              if (onFailure) {\n                onFailure();\n              }\n            } else if (onSuccess) {\n              onSuccess();\n            }\n            break;\n          case C.STATUS_COMPLETED:\n            break;\n        }\n      }\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  return NonInviteServerTransaction;\n}(EventEmitter);\n\nvar InviteServerTransaction = function (_EventEmitter5) {\n  _inherits(InviteServerTransaction, _EventEmitter5);\n\n  function InviteServerTransaction(ua, transport, request) {\n    _classCallCheck(this, InviteServerTransaction);\n\n    var _this11 = _possibleConstructorReturn(this, (InviteServerTransaction.__proto__ || Object.getPrototypeOf(InviteServerTransaction)).call(this));\n\n    _this11.type = C.INVITE_SERVER;\n    _this11.id = request.via_branch;\n    _this11.ua = ua;\n    _this11.transport = transport;\n    _this11.request = request;\n    _this11.last_response = '';\n    request.server_transaction = _this11;\n\n    _this11.state = C.STATUS_PROCEEDING;\n\n    ua.newTransaction(_this11);\n\n    _this11.resendProvisionalTimer = null;\n\n    request.reply(100);\n    return _this11;\n  }\n\n  _createClass(InviteServerTransaction, [{\n    key: 'stateChanged',\n    value: function stateChanged(state) {\n      this.state = state;\n      this.emit('stateChanged');\n    }\n  }, {\n    key: 'timer_H',\n    value: function timer_H() {\n      debugist('Timer H expired for transaction ' + this.id);\n\n      if (this.state === C.STATUS_COMPLETED) {\n        debugist('ACK not received, dialog will be terminated');\n      }\n\n      this.stateChanged(C.STATUS_TERMINATED);\n      this.ua.destroyTransaction(this);\n    }\n  }, {\n    key: 'timer_I',\n    value: function timer_I() {\n      this.stateChanged(C.STATUS_TERMINATED);\n    }\n\n    // RFC 6026 7.1.\n\n  }, {\n    key: 'timer_L',\n    value: function timer_L() {\n      debugist('Timer L expired for transaction ' + this.id);\n\n      if (this.state === C.STATUS_ACCEPTED) {\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.ua.destroyTransaction(this);\n      }\n    }\n  }, {\n    key: 'onTransportError',\n    value: function onTransportError() {\n      if (!this.transportError) {\n        this.transportError = true;\n\n        debugist('transport error occurred, deleting transaction ' + this.id);\n\n        if (this.resendProvisionalTimer !== null) {\n          clearInterval(this.resendProvisionalTimer);\n          this.resendProvisionalTimer = null;\n        }\n\n        clearTimeout(this.L);\n        clearTimeout(this.H);\n        clearTimeout(this.I);\n\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.ua.destroyTransaction(this);\n      }\n    }\n  }, {\n    key: 'resend_provisional',\n    value: function resend_provisional() {\n      if (!this.transport.send(this.last_response)) {\n        this.onTransportError();\n      }\n    }\n\n    // INVITE Server Transaction RFC 3261 17.2.1.\n\n  }, {\n    key: 'receiveResponse',\n    value: function receiveResponse(status_code, response, onSuccess, onFailure) {\n      var _this12 = this;\n\n      if (status_code >= 100 && status_code <= 199) {\n        switch (this.state) {\n          case C.STATUS_PROCEEDING:\n            if (!this.transport.send(response)) {\n              this.onTransportError();\n            }\n            this.last_response = response;\n            break;\n        }\n      }\n\n      if (status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {\n        // Trigger the resendProvisionalTimer only for the first non 100 provisional response.\n        if (this.resendProvisionalTimer === null) {\n          this.resendProvisionalTimer = setInterval(function () {\n            _this12.resend_provisional();\n          }, Timers.PROVISIONAL_RESPONSE_INTERVAL);\n        }\n      } else if (status_code >= 200 && status_code <= 299) {\n        switch (this.state) {\n          case C.STATUS_PROCEEDING:\n            this.stateChanged(C.STATUS_ACCEPTED);\n            this.last_response = response;\n            this.L = setTimeout(function () {\n              _this12.timer_L();\n            }, Timers.TIMER_L);\n\n            if (this.resendProvisionalTimer !== null) {\n              clearInterval(this.resendProvisionalTimer);\n              this.resendProvisionalTimer = null;\n            }\n\n          /* falls through */\n          case C.STATUS_ACCEPTED:\n            // Note that this point will be reached for proceeding this.state also.\n            if (!this.transport.send(response)) {\n              this.onTransportError();\n              if (onFailure) {\n                onFailure();\n              }\n            } else if (onSuccess) {\n              onSuccess();\n            }\n            break;\n        }\n      } else if (status_code >= 300 && status_code <= 699) {\n        switch (this.state) {\n          case C.STATUS_PROCEEDING:\n            if (this.resendProvisionalTimer !== null) {\n              clearInterval(this.resendProvisionalTimer);\n              this.resendProvisionalTimer = null;\n            }\n\n            if (!this.transport.send(response)) {\n              this.onTransportError();\n              if (onFailure) {\n                onFailure();\n              }\n            } else {\n              this.stateChanged(C.STATUS_COMPLETED);\n              this.H = setTimeout(function () {\n                _this12.timer_H();\n              }, Timers.TIMER_H);\n              if (onSuccess) {\n                onSuccess();\n              }\n            }\n            break;\n        }\n      }\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  return InviteServerTransaction;\n}(EventEmitter);\n\n/**\n * INVITE:\n *  _true_ if retransmission\n *  _false_ new request\n *\n * ACK:\n *  _true_  ACK to non2xx response\n *  _false_ ACK must be passed to TU (accepted state)\n *          ACK to 2xx response\n *\n * CANCEL:\n *  _true_  no matching invite transaction\n *  _false_ matching invite transaction and no final response sent\n *\n * OTHER:\n *  _true_  retransmission\n *  _false_ new request\n */\n\n\nfunction checkTransaction(_ref, request) {\n  var _transactions = _ref._transactions;\n\n  var tr = void 0;\n\n  switch (request.method) {\n    case SIP_C.INVITE:\n      tr = _transactions.ist[request.via_branch];\n      if (tr) {\n        switch (tr.state) {\n          case C.STATUS_PROCEEDING:\n            tr.transport.send(tr.last_response);\n            break;\n\n          // RFC 6026 7.1 Invite retransmission.\n          // Received while in C.STATUS_ACCEPTED state. Absorb it.\n          case C.STATUS_ACCEPTED:\n            break;\n        }\n\n        return true;\n      }\n      break;\n    case SIP_C.ACK:\n      tr = _transactions.ist[request.via_branch];\n\n      // RFC 6026 7.1.\n      if (tr) {\n        if (tr.state === C.STATUS_ACCEPTED) {\n          return false;\n        } else if (tr.state === C.STATUS_COMPLETED) {\n          tr.state = C.STATUS_CONFIRMED;\n          tr.I = setTimeout(function () {\n            tr.timer_I();\n          }, Timers.TIMER_I);\n\n          return true;\n        }\n      }\n      // ACK to 2XX Response.\n      else {\n          return false;\n        }\n      break;\n    case SIP_C.CANCEL:\n      tr = _transactions.ist[request.via_branch];\n      if (tr) {\n        request.reply_sl(200);\n        if (tr.state === C.STATUS_PROCEEDING) {\n          return false;\n        } else {\n          return true;\n        }\n      } else {\n        request.reply_sl(481);\n\n        return true;\n      }\n    default:\n\n      // Non-INVITE Server Transaction RFC 3261 17.2.2.\n      tr = _transactions.nist[request.via_branch];\n      if (tr) {\n        switch (tr.state) {\n          case C.STATUS_TRYING:\n            break;\n          case C.STATUS_PROCEEDING:\n          case C.STATUS_COMPLETED:\n            tr.transport.send(tr.last_response);\n            break;\n        }\n\n        return true;\n      }\n      break;\n  }\n}\n\nmodule.exports = {\n  C: C,\n  NonInviteClientTransaction: NonInviteClientTransaction,\n  InviteClientTransaction: InviteClientTransaction,\n  AckClientTransaction: AckClientTransaction,\n  NonInviteServerTransaction: NonInviteServerTransaction,\n  InviteServerTransaction: InviteServerTransaction,\n  checkTransaction: checkTransaction\n};\n\n//# sourceURL=webpack://ApolloSIP/./lib/Transactions.js?");

/***/ }),

/***/ "./lib/Transport.js":
/*!**************************!*\
  !*** ./lib/Transport.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Socket = __webpack_require__(/*! ./Socket */ \"./lib/Socket.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:Transport');\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:ERROR:Transport');\n\ndebugerror.log = console.warn.bind(console);\n\n/**\n * Constants\n */\nvar C = {\n  // Transport status.\n  STATUS_CONNECTED: 0,\n  STATUS_CONNECTING: 1,\n  STATUS_DISCONNECTED: 2,\n\n  // Socket status.\n  SOCKET_STATUS_READY: 0,\n  SOCKET_STATUS_ERROR: 1,\n\n  // Recovery options.\n  recovery_options: {\n    min_interval: 2, // minimum interval in seconds between recover attempts\n    max_interval: 30 // maximum interval in seconds between recover attempts\n  }\n};\n\n/*\n * Manages one or multiple SIP.Socket instances.\n * Is reponsible for transport recovery logic among all socket instances.\n *\n * @socket SIP::Socket instance\n */\nmodule.exports = function () {\n  function Transport(sockets) {\n    var recovery_options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : C.recovery_options;\n\n    _classCallCheck(this, Transport);\n\n    debug('new()');\n\n    this.status = C.STATUS_DISCONNECTED;\n\n    // Current socket.\n    this.socket = null;\n\n    // Socket collection.\n    this.sockets = [];\n\n    this.recovery_options = recovery_options;\n    this.recover_attempts = 0;\n    this.recovery_timer = null;\n\n    this._keepAliveInterval = 5;\n    this._keepAliveTimer = null;\n    this._keepAliveTimeout = null;\n\n    this.close_requested = false;\n\n    if (typeof sockets === 'undefined') {\n      throw new TypeError('Invalid argument.' + ' undefined \\'sockets\\' argument');\n    }\n\n    this._setSocket(sockets);\n    // Get the socket with higher weight.\n    this._getSocket();\n  }\n\n  /**\n   * Instance Methods\n   */\n\n  _createClass(Transport, [{\n    key: 'connect',\n    value: function connect() {\n      debug('connect()');\n\n      if (this.isConnected()) {\n        debug('Transport is already connected');\n\n        return;\n      } else if (this.isConnecting()) {\n        debug('Transport is connecting');\n\n        return;\n      }\n\n      this.close_requested = false;\n      this.status = C.STATUS_CONNECTING;\n      this.onconnecting({ socket: this.socket, attempts: this.recover_attempts });\n\n      if (!this.close_requested) {\n        // Bind socket event callbacks.\n        this.socket.onconnect = this._onConnect.bind(this);\n        this.socket.ondisconnect = this._onDisconnect.bind(this);\n        this.socket.ondata = this._onData.bind(this);\n\n        this.socket.connect();\n      }\n\n      return;\n    }\n  }, {\n    key: 'disconnect',\n    value: function disconnect() {\n      debug('close()');\n\n      this.close_requested = true;\n      this.recover_attempts = 0;\n      this.status = C.STATUS_DISCONNECTED;\n\n      // Clear recovery_timer.\n      if (this.recovery_timer !== null) {\n        clearTimeout(this.recovery_timer);\n        this.recovery_timer = null;\n      }\n\n      // Clear keep alive timer.\n      this._stopSendingKeepAlives();\n\n      // Unbind socket event callbacks.\n      this.socket.onconnect = function () {};\n      this.socket.ondisconnect = function () {};\n      this.socket.ondata = function () {};\n\n      this.socket.disconnect();\n      this.ondisconnect();\n    }\n  }, {\n    key: 'send',\n    value: function send(data) {\n      debug('send()');\n\n      if (!this.isConnected()) {\n        debugerror('unable to send message, transport is not connected');\n\n        return false;\n      }\n\n      var message = data.toString();\n\n      if (message === '\\r\\n\\r\\n') {\n        debug('sending keep alive message');\n      } else {\n        debug('sending message:\\n\\n' + message + '\\n');\n      }\n\n      return this.socket.send(message);\n    }\n  }, {\n    key: 'isConnected',\n    value: function isConnected() {\n      return this.status === C.STATUS_CONNECTED;\n    }\n  }, {\n    key: 'isConnecting',\n    value: function isConnecting() {\n      return this.status === C.STATUS_CONNECTING;\n    }\n\n    /**\n     * Private API.\n     */\n\n  }, {\n    key: '_reconnect',\n    value: function _reconnect() {\n      var _this = this;\n\n      this.recover_attempts += 1;\n\n      var k = Math.floor(Math.random() * Math.pow(2, this.recover_attempts) + 1);\n\n      if (k < this.recovery_options.min_interval) {\n        k = this.recovery_options.min_interval;\n      } else if (k > this.recovery_options.max_interval) {\n        k = this.recovery_options.max_interval;\n      }\n\n      debug('reconnection attempt: ' + this.recover_attempts + '. next connection attempt in ' + k + ' seconds');\n\n      this.recovery_timer = setTimeout(function () {\n        if (!_this.close_requested && !(_this.isConnected() || _this.isConnecting())) {\n          // Get the next available socket with higher weight.\n          _this._getSocket();\n\n          // Connect the socket.\n          _this.connect();\n        }\n      }, k * 1000);\n    }\n  }, {\n    key: '_setSocket',\n    value: function _setSocket(sockets) {\n      if (!(sockets instanceof Array)) {\n        sockets = [sockets];\n      }\n\n      sockets.forEach(function (socket) {\n        if (!Socket.isSocket(socket.socket)) {\n          throw new TypeError('Invalid argument.' + ' invalid \\'SIP.Socket\\' instance');\n        }\n\n        if (socket.weight && !Number(socket.weight)) {\n          throw new TypeError('Invalid argument.' + ' \\'weight\\' attribute is not a number');\n        }\n\n        this.sockets.push({\n          socket: socket.socket,\n          weight: socket.weight || 0,\n          status: C.SOCKET_STATUS_READY\n        });\n      }, this);\n    }\n\n    /**\n     * get the next available socket with higher weight\n     */\n\n  }, {\n    key: '_getSocket',\n    value: function _getSocket() {\n\n      var candidates = [];\n\n      this.sockets.forEach(function (socket) {\n        if (socket.status === C.SOCKET_STATUS_ERROR) {\n          return; // continue the array iteration\n        } else if (candidates.length === 0) {\n          candidates.push(socket);\n        } else if (socket.weight > candidates[0].weight) {\n          candidates = [socket];\n        } else if (socket.weight === candidates[0].weight) {\n          candidates.push(socket);\n        }\n      });\n\n      if (candidates.length === 0) {\n        // All sockets have failed. reset sockets status.\n        this.sockets.forEach(function (socket) {\n          socket.status = C.SOCKET_STATUS_READY;\n        });\n\n        // Get next available socket.\n        this._getSocket();\n\n        return;\n      }\n\n      var idx = Math.floor(Math.random() * candidates.length);\n\n      this.socket = candidates[idx].socket;\n    }\n\n    /**\n     * Socket Event Handlers\n     */\n\n  }, {\n    key: '_onConnect',\n    value: function _onConnect() {\n      this.recover_attempts = 0;\n      this.status = C.STATUS_CONNECTED;\n\n      // Clear recovery_timer.\n      if (this.recovery_timer !== null) {\n        clearTimeout(this.recovery_timer);\n        this.recovery_timer = null;\n      }\n\n      this._startSendingKeepAlives();\n\n      this.onconnect({ socket: this });\n    }\n  }, {\n    key: '_onDisconnect',\n    value: function _onDisconnect(error, code, reason) {\n      this.status = C.STATUS_DISCONNECTED;\n\n      this._stopSendingKeepAlives();\n\n      this.ondisconnect({\n        socket: this.socket,\n        error: error,\n        code: code,\n        reason: reason\n      });\n\n      if (this.close_requested) {\n        return;\n      }\n\n      // Update socket status.\n      else {\n          this.sockets.forEach(function (socket) {\n            if (this.socket === socket.socket) {\n              socket.status = C.SOCKET_STATUS_ERROR;\n            }\n          }, this);\n        }\n\n      this._reconnect(error);\n    }\n  }, {\n    key: '_onData',\n    value: function _onData(data) {\n      // CRLF Keep Alive response from server. Ignore it.\n      if (data === '\\r\\n') {\n        debug('received message with CRLF Keep Alive response');\n\n        clearTimeout(this._keepAliveTimeout);\n        this._keepAliveTimeout = null;\n\n        return;\n      }\n\n      // Binary message.\n      else if (typeof data !== 'string') {\n          try {\n            data = String.fromCharCode.apply(null, new Uint8Array(data));\n          } catch (evt) {\n            debug('received binary message failed to be converted into string,' + ' message discarded');\n\n            return;\n          }\n\n          debug('received binary message:\\n\\n' + data + '\\n');\n        }\n\n        // Text message.\n        else {\n            debug('received text message:\\n\\n' + data + '\\n');\n          }\n\n      this.ondata({ transport: this, message: data });\n    }\n  }, {\n    key: '_startSendingKeepAlives',\n    value: function _startSendingKeepAlives() {\n      var _this2 = this;\n\n      if (this._keepAliveInterval && !this._keepAliveTimer) {\n        this._keepAliveTimer = setTimeout(function () {\n          _this2._sendKeepAlive();\n          _this2._keepAliveTimer = null;\n          _this2._startSendingKeepAlives();\n        }, this._computeKeepAliveTimeout(this._keepAliveInterval));\n      }\n    }\n  }, {\n    key: '_stopSendingKeepAlives',\n    value: function _stopSendingKeepAlives() {\n      if (this._keepAliveTimer) {\n        clearTimeout(this._keepAliveTimer);\n        this._keepAliveTimer = null;\n      }\n      if (this._keepAliveTimeout) {\n        clearTimeout(this._keepAliveTimeout);\n        this._keepAliveTimeout = null;\n      }\n    }\n  }, {\n    key: '_sendKeepAlive',\n    value: function _sendKeepAlive() {\n      var _this3 = this;\n\n      if (this._keepAliveTimeout) {\n        return;\n      }\n\n      this._keepAliveTimeout = setTimeout(function () {\n        _this3._keepAliveTimeout = null;\n        debugerror('keepAliveTimeout');\n      }, 10000);\n\n      return this.send('\\r\\n\\r\\n');\n    }\n  }, {\n    key: '_computeKeepAliveTimeout',\n    value: function _computeKeepAliveTimeout(upperBound) {\n      var lowerBound = upperBound * 0.8;\n\n      return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);\n    }\n  }, {\n    key: 'via_transport',\n    get: function get() {\n      return this.socket.via_transport;\n    }\n  }, {\n    key: 'url',\n    get: function get() {\n      return this.socket.url;\n    }\n  }, {\n    key: 'sip_uri',\n    get: function get() {\n      return this.socket.sip_uri;\n    }\n  }]);\n\n  return Transport;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./lib/Transport.js?");

/***/ }),

/***/ "./lib/UA.js":
/*!*******************!*\
  !*** ./lib/UA.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar Registrator = __webpack_require__(/*! ./Registrator */ \"./lib/Registrator.js\");\nvar RTCSession = __webpack_require__(/*! ./RTCSession */ \"./lib/RTCSession.js\");\nvar Message = __webpack_require__(/*! ./Message */ \"./lib/Message.js\");\nvar Service = __webpack_require__(/*! ./Service */ \"./lib/Service.js\");\nvar Subscription = __webpack_require__(/*! ./Subscription */ \"./lib/Subscription.js\");\nvar Transactions = __webpack_require__(/*! ./Transactions */ \"./lib/Transactions.js\");\nvar Transport = __webpack_require__(/*! ./Transport */ \"./lib/Transport.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar Exceptions = __webpack_require__(/*! ./Exceptions */ \"./lib/Exceptions.js\");\nvar URI = __webpack_require__(/*! ./URI */ \"./lib/URI.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./lib/Grammar.js\");\nvar Parser = __webpack_require__(/*! ./Parser */ \"./lib/Parser.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./lib/SIPMessage.js\");\nvar sanityCheck = __webpack_require__(/*! ./sanityCheck */ \"./lib/sanityCheck.js\");\nvar config = __webpack_require__(/*! ./Config */ \"./lib/Config.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:UA');\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:ERROR:UA');\n\ndebugerror.log = console.warn.bind(console);\n\nvar C = {\n  // UA status codes.\n  STATUS_INIT: 0,\n  STATUS_READY: 1,\n  STATUS_USER_CLOSED: 2,\n  STATUS_NOT_READY: 3,\n\n  // UA error codes.\n  CONFIGURATION_ERROR: 1,\n  NETWORK_ERROR: 2\n};\n\n/**\n * The User-Agent class.\n * @class SIP.UA\n * @param {Object} configuration Configuration parameters.\n * @throws {SIP.Exceptions.ConfigurationError} If a configuration parameter is invalid.\n * @throws {TypeError} If no configuration is given.\n */\nmodule.exports = function (_EventEmitter) {\n  _inherits(UA, _EventEmitter);\n\n  _createClass(UA, null, [{\n    key: 'C',\n\n    // Expose C object.\n    get: function get() {\n      return C;\n    }\n  }]);\n\n  function UA(configuration) {\n    _classCallCheck(this, UA);\n\n    debug('new() [configuration:%o]', configuration);\n\n    var _this = _possibleConstructorReturn(this, (UA.__proto__ || Object.getPrototypeOf(UA)).call(this));\n\n    _this._cache = {\n      challenges: {},\n      credentials: {}\n    };\n\n    _this._configuration = Object.assign({}, config.settings);\n    _this._dynConfiguration = {};\n    _this._dialogs = {};\n\n    // User actions outside any session/dialog (MESSAGE/SERVICE).\n    _this._applicants = {};\n\n    _this._sessions = {};\n    _this._subscriptions = {};\n    _this._transport = null;\n    _this._contact = null;\n    _this._status = C.STATUS_INIT;\n    _this._error = null;\n    _this._transactions = {\n      nist: {},\n      nict: {},\n      ist: {},\n      ict: {}\n    };\n\n    // Custom UA empty object for high level use.\n    _this._data = {};\n\n    _this._closeTimer = null;\n\n    // Check configuration argument.\n    if (configuration === undefined) {\n      throw new TypeError('Not enough arguments');\n    }\n\n    // Load configuration.\n    try {\n      _this._loadConfig(configuration);\n    } catch (e) {\n      _this._status = C.STATUS_NOT_READY;\n      _this._error = C.CONFIGURATION_ERROR;\n      throw e;\n    }\n\n    // Initialize registrator.\n    _this._registrator = new Registrator(_this);\n    return _this;\n  }\n\n  _createClass(UA, [{\n    key: 'start',\n\n\n    // =================\n    //  High Level API\n    // =================\n\n    /**\n     * Connect to the server if status = STATUS_INIT.\n     * Resume UA after being closed.\n     */\n    value: function start() {\n      debug('start()');\n\n      if (this._status === C.STATUS_INIT) {\n        this._transport.connect();\n      } else if (this._status === C.STATUS_USER_CLOSED) {\n        debug('restarting UA');\n\n        // Disconnect.\n        if (this._closeTimer !== null) {\n          clearTimeout(this._closeTimer);\n          this._closeTimer = null;\n          this._transport.disconnect();\n        }\n\n        // Reconnect.\n        this._status = C.STATUS_INIT;\n        this._transport.connect();\n      } else if (this._status === C.STATUS_READY) {\n        debug('UA is in READY status, not restarted');\n      } else {\n        debug('ERROR: connection is down, Auto-Recovery system is trying to reconnect');\n      }\n\n      // Set dynamic configuration.\n      this._dynConfiguration.register = this._configuration.register;\n    }\n\n    /**\n     * Register.\n     */\n\n  }, {\n    key: 'register',\n    value: function register() {\n      debug('register()');\n\n      this._dynConfiguration.register = true;\n      this._registrator.register();\n    }\n\n    /**\n     * Unregister.\n     */\n\n  }, {\n    key: 'unregister',\n    value: function unregister(options) {\n      debug('unregister()');\n\n      this._dynConfiguration.register = false;\n      this._registrator.unregister(options);\n    }\n\n    /**\n     * Get the Registrator instance.\n     */\n\n  }, {\n    key: 'registrator',\n    value: function registrator() {\n      return this._registrator;\n    }\n\n    /**\n     * Registration state.\n     */\n\n  }, {\n    key: 'isRegistered',\n    value: function isRegistered() {\n      return this._registrator.registered;\n    }\n\n    /**\n     * Connection state.\n     */\n\n  }, {\n    key: 'isConnected',\n    value: function isConnected() {\n      return this._transport.isConnected();\n    }\n\n    /**\n     * Make an outgoing call.\n     *\n     * -param {String} target\n     * -param {Object} [options]\n     *\n     * -throws {TypeError}\n     *\n     */\n\n  }, {\n    key: 'call',\n    value: function call(target, options) {\n      debug('call()');\n\n      var session = new RTCSession(this);\n\n      session.connect(target, options);\n\n      return session;\n    }\n\n    /**\n     * Send a message.\n     *\n     * -param {String} target\n     * -param {String} body\n     * -param {Object} [options]\n     *\n     * -throws {TypeError}\n     *\n     */\n\n  }, {\n    key: 'sendMessage',\n    value: function sendMessage(target, body, options) {\n      debug('sendMessage()');\n\n      var message = new Message(this);\n\n      message.send(target, body, options);\n\n      return message;\n    }\n  }, {\n    key: 'sendService',\n    value: function sendService(target, event, body, options) {\n      debug('sendService()');\n\n      var service = new Service(this);\n\n      service.send(target, event, body, options);\n\n      return service;\n    }\n  }, {\n    key: 'subscribe',\n    value: function subscribe(target, event, options) {\n      debug('subscribe()');\n\n      var subscription = new Subscription(this);\n\n      subscription.subscribe(target, event, options);\n\n      return subscription;\n    }\n\n    /**\n     * Terminate ongoing sessions.\n     */\n\n  }, {\n    key: 'terminateSessions',\n    value: function terminateSessions(options) {\n      debug('terminateSessions()');\n\n      for (var idx in this._sessions) {\n        if (!this._sessions[idx].isEnded()) {\n          this._sessions[idx].terminate(options);\n        }\n      }\n    }\n  }, {\n    key: 'terminateSubscriptions',\n    value: function terminateSubscriptions() {\n      debug('terminateSubscriptions()');\n\n      for (var subscription in this._subscriptions) {\n        if (Object.prototype.hasOwnProperty.call(this._subscriptions, subscription)) {\n          debug('closing subscription ' + subscription);\n          try {\n            this._subscriptions[subscription].terminate();\n          } catch (error) {}\n        }\n      }\n    }\n\n    /**\n     * Gracefully close.\n     *\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      var _this2 = this;\n\n      debug('stop()');\n\n      // Remove dynamic settings.\n      this._dynConfiguration = {};\n\n      if (this._status === C.STATUS_USER_CLOSED) {\n        debug('UA already closed');\n\n        return;\n      }\n\n      // Close registrator.\n      this._registrator.close();\n\n      // If there are session wait a bit so CANCEL/BYE can be sent and their responses received.\n      var num_sessions = Object.keys(this._sessions).length;\n\n      // Run  _terminate_ on every Session.\n      for (var session in this._sessions) {\n        if (Object.prototype.hasOwnProperty.call(this._sessions, session)) {\n          debug('closing session ' + session);\n          try {\n            this._sessions[session].terminate();\n          } catch (error) {}\n        }\n      }\n\n      // Run  _terminate_ on every Subscription.\n      for (var subscription in this._subscriptions) {\n        if (Object.prototype.hasOwnProperty.call(this._subscriptions, subscription)) {\n          debug('closing subscription ' + subscription);\n          try {\n            this._subscriptions[subscription].terminate();\n          } catch (error) {}\n        }\n      }\n\n      // Run  _close_ on every applicant.\n      for (var applicant in this._applicants) {\n        if (Object.prototype.hasOwnProperty.call(this._applicants, applicant)) try {\n          this._applicants[applicant].close();\n        } catch (error) {}\n      }\n\n      this._status = C.STATUS_USER_CLOSED;\n\n      var num_transactions = Object.keys(this._transactions.nict).length + Object.keys(this._transactions.nist).length + Object.keys(this._transactions.ict).length + Object.keys(this._transactions.ist).length;\n\n      if (num_transactions === 0 && num_sessions === 0) {\n        this._transport.disconnect();\n      } else {\n        this._closeTimer = setTimeout(function () {\n          _this2._closeTimer = null;\n          _this2._transport.disconnect();\n        }, 2000);\n      }\n    }\n\n    /**\n     * Normalice a string into a valid SIP request URI\n     * -param {String} target\n     * -returns {SIP.URI|undefined}\n     */\n\n  }, {\n    key: 'normalizeTarget',\n    value: function normalizeTarget(target) {\n      return Utils.normalizeTarget(target, this._configuration.hostport_params);\n    }\n\n    /**\n     * Allow retrieving configuration and autogenerated fields in runtime.\n     */\n\n  }, {\n    key: 'get',\n    value: function get(parameter) {\n      switch (parameter) {\n        case 'realm':\n          return this._configuration.realm;\n\n        case 'ha1':\n          return this._configuration.ha1;\n\n        case 'display_name':\n          return this._configuration.display_name;\n\n        default:\n          debugerror('get() | cannot get \"%s\" parameter in runtime', parameter);\n\n          return undefined;\n      }\n    }\n\n    /**\n     * Allow configuration changes in runtime.\n     * Returns true if the parameter could be set.\n     */\n\n  }, {\n    key: 'set',\n    value: function set(parameter, value) {\n      switch (parameter) {\n        case 'password':\n          {\n            this._configuration.password = String(value);\n            break;\n          }\n\n        case 'realm':\n          {\n            this._configuration.realm = String(value);\n            break;\n          }\n\n        case 'ha1':\n          {\n            this._configuration.ha1 = String(value);\n            // Delete the plain SIP password.\n            this._configuration.password = null;\n            break;\n          }\n\n        case 'display_name':\n          {\n            if (Grammar.parse('\"' + value + '\"', 'display_name') === -1) {\n              debugerror('set() | wrong \"display_name\"');\n\n              return false;\n            }\n            this._configuration.display_name = value;\n            break;\n          }\n\n        default:\n          debugerror('set() | cannot set \"%s\" parameter in runtime', parameter);\n\n          return false;\n      }\n\n      return true;\n    }\n\n    // ==========================\n    // Event Handlers.\n    // ==========================\n\n    /**\n     * new Transaction\n     */\n\n  }, {\n    key: 'newTransaction',\n    value: function newTransaction(transaction) {\n      this._transactions[transaction.type][transaction.id] = transaction;\n      this.emit('newTransaction', {\n        transaction: transaction\n      });\n    }\n\n    /**\n     * Transaction destroyed.\n     */\n\n  }, {\n    key: 'destroyTransaction',\n    value: function destroyTransaction(transaction) {\n      delete this._transactions[transaction.type][transaction.id];\n      this.emit('transactionDestroyed', {\n        transaction: transaction\n      });\n    }\n\n    /**\n     * new Dialog\n     */\n\n  }, {\n    key: 'newDialog',\n    value: function newDialog(dialog) {\n      this._dialogs[dialog.id] = dialog;\n    }\n\n    /**\n     * Dialog destroyed.\n     */\n\n  }, {\n    key: 'destroyDialog',\n    value: function destroyDialog(dialog) {\n      delete this._dialogs[dialog.id];\n    }\n\n    /**\n     *  new Message\n     */\n\n  }, {\n    key: 'newMessage',\n    value: function newMessage(message, data) {\n      this._applicants[message] = message;\n      this.emit('newMessage', data);\n    }\n\n    /**\n     *  Message destroyed.\n     */\n\n  }, {\n    key: 'destroyMessage',\n    value: function destroyMessage(message) {\n      delete this._applicants[message];\n    }\n\n    /**\n     *  new Service\n     */\n\n  }, {\n    key: 'newService',\n    value: function newService(service, data) {\n      this._applicants[service] = service;\n      this.emit('newService', data);\n    }\n\n    /**\n     *  Service destroyed.\n     */\n\n  }, {\n    key: 'destroyService',\n    value: function destroyService(service) {\n      delete this._applicants[service];\n    }\n\n    /**\n     * new RTCSession\n     */\n\n  }, {\n    key: 'newRTCSession',\n    value: function newRTCSession(session, data) {\n      this._sessions[session.id] = session;\n      this.emit('newRTCSession', data);\n    }\n\n    /**\n     * RTCSession destroyed.\n     */\n\n  }, {\n    key: 'destroyRTCSession',\n    value: function destroyRTCSession(session) {\n      delete this._sessions[session.id];\n    }\n\n    /**\n     * new Subscription\n     */\n\n  }, {\n    key: 'newSubscription',\n    value: function newSubscription(subscription, data) {\n      this._subscriptions[subscription.id] = subscription;\n      this.emit('newSubscription', data);\n    }\n\n    /**\n     * RTCSession destroyed.\n     */\n\n  }, {\n    key: 'destroySubscription',\n    value: function destroySubscription(subscription) {\n      delete this._subscriptions[subscription.id];\n    }\n\n    /**\n     * Registered\n     */\n\n  }, {\n    key: 'registered',\n    value: function registered(data) {\n      this.emit('registered', data);\n    }\n\n    /**\n     * Unregistered\n     */\n\n  }, {\n    key: 'unregistered',\n    value: function unregistered(data) {\n      this.emit('unregistered', data);\n    }\n\n    /**\n     * Registration Failed\n     */\n\n  }, {\n    key: 'registrationFailed',\n    value: function registrationFailed(data) {\n      this.emit('registrationFailed', data);\n    }\n\n    // =========================\n    // ReceiveRequest.\n    // =========================\n\n    /**\n     * Request reception\n     */\n\n  }, {\n    key: 'receiveRequest',\n    value: function receiveRequest(request) {\n      var method = request.method;\n\n      // Check that request URI points to us.\n      if (request.ruri.user !== this._configuration.uri.user && request.ruri.user !== this._contact.uri.user) {\n        debug('Request-URI does not point to us');\n        if (request.method !== SIP_C.ACK) {\n          request.reply_sl(404);\n        }\n\n        return;\n      }\n\n      // Check request URI scheme.\n      if (request.ruri.scheme === SIP_C.SIPS) {\n        request.reply_sl(416);\n\n        return;\n      }\n\n      // Check transaction.\n      if (Transactions.checkTransaction(this, request)) {\n        return;\n      }\n\n      // Create the server transaction.\n      if (method === SIP_C.INVITE) {\n        /* eslint-disable no-new */\n        new Transactions.InviteServerTransaction(this, this._transport, request);\n        /* eslint-enable no-new */\n      } else if (method !== SIP_C.ACK && method !== SIP_C.CANCEL) {\n        /* eslint-disable no-new */\n        new Transactions.NonInviteServerTransaction(this, this._transport, request);\n        /* eslint-enable no-new */\n      }\n\n      /* RFC3261 12.2.2\n       * Requests that do not change in any way the state of a dialog may be\n       * received within a dialog (for example, an OPTIONS request).\n       * They are processed as if they had been received outside the dialog.\n       */\n      if (method === SIP_C.OPTIONS) {\n        request.reply(200);\n      } else if (method === SIP_C.MESSAGE) {\n        if (this.listeners('newMessage').length === 0) {\n          request.reply(405);\n\n          return;\n        }\n        var message = new Message(this);\n\n        message.init_incoming(request);\n      } else if (method === SIP_C.SERVICE) {\n        if (this.listeners('newService').length === 0) {\n          request.reply(405);\n\n          return;\n        }\n        var service = new Service(this);\n\n        service.init_incoming(request);\n      } else if (method === SIP_C.INVITE) {\n        // Initial INVITE.\n        if (!request.to_tag && this.listeners('newRTCSession').length === 0) {\n          request.reply(405);\n\n          return;\n        }\n      }\n\n      var dialog = void 0;\n      var session = void 0;\n      var subscription = void 0;\n\n      // Initial Request.\n      if (!request.to_tag) {\n        switch (method) {\n          case SIP_C.INVITE:\n            if (window.RTCPeerConnection) {\n              // TODO\n              if (request.hasHeader('replaces')) {\n                var replaces = request.replaces;\n\n                dialog = this._findDialog(replaces.call_id, replaces.from_tag, replaces.to_tag);\n                if (dialog) {\n                  session = dialog.owner;\n                  if (!session.isEnded()) {\n                    session.receiveRequest(request);\n                  } else {\n                    request.reply(603);\n                  }\n                } else {\n                  request.reply(481);\n                }\n              } else {\n                session = new RTCSession(this);\n                session.init_incoming(request);\n              }\n            } else {\n              debugerror('INVITE received but WebRTC is not supported');\n              request.reply(488);\n            }\n            break;\n          case SIP_C.BYE:\n            // Out of dialog BYE received.\n            request.reply(481);\n            break;\n          case SIP_C.CANCEL:\n            session = this._findSession(request);\n            if (session) {\n              session.receiveRequest(request);\n            } else {\n              debug('received CANCEL request for a non existent session');\n            }\n            break;\n          case SIP_C.ACK:\n            /* Absorb it.\n             * ACK request without a corresponding Invite Transaction\n             * and without To tag.\n             */\n            break;\n          default:\n            request.reply(405);\n            break;\n        }\n      }\n      // In-dialog request.\n      else {\n          dialog = this._findDialog(request.call_id, request.from_tag, request.to_tag);\n\n          if (dialog) {\n            dialog.receiveRequest(request);\n          } else if (method === SIP_C.NOTIFY) {\n            subscription = this._findSubscription(request);\n            session = this._findSession(request);\n            if (session) {\n              session.receiveRequest(request);\n            } else if (subscription) {\n              subscription.receiveRequest(request);\n            } else {\n              debug('received NOTIFY request for a non existent subscription');\n              request.reply(481, 'Subscription Does Not Exist');\n            }\n          }\n\n          /* RFC3261 12.2.2\n           * Request with to tag, but no matching dialog found.\n           * Exception: ACK for an Invite request for which a dialog has not\n           * been created.\n           */\n          else if (method !== SIP_C.ACK) {\n              request.reply(481);\n            }\n        }\n    }\n\n    // =================\n    // Utils.\n    // =================\n\n    /**\n     * Get the subscription to which the request belongs to, if any.\n     */\n\n  }, {\n    key: '_findSubscription',\n    value: function _findSubscription(request) {\n      var call_id = request.call_id;\n      var from_tag = request.from_tag;\n      var to_tag = request.to_tag;\n      var event = request.getHeader('event');\n\n      var subscriptionIDa = call_id + from_tag + event;\n      var subscriptionA = this._subscriptions[subscriptionIDa];\n      var subscriptionIDb = call_id + to_tag + event;\n      var subscriptionB = this._subscriptions[subscriptionIDb];\n\n      if (subscriptionA) {\n        return subscriptionA;\n      } else if (subscriptionIDb) {\n        return subscriptionB;\n      } else {\n        return null;\n      }\n    }\n\n    /**\n     * Get the session to which the request belongs to, if any.\n     */\n\n  }, {\n    key: '_findSession',\n    value: function _findSession(_ref) {\n      var call_id = _ref.call_id,\n          from_tag = _ref.from_tag,\n          to_tag = _ref.to_tag;\n\n      var sessionIDa = call_id + from_tag;\n      var sessionA = this._sessions[sessionIDa];\n      var sessionIDb = call_id + to_tag;\n      var sessionB = this._sessions[sessionIDb];\n\n      if (sessionA) {\n        return sessionA;\n      } else if (sessionB) {\n        return sessionB;\n      } else {\n        return null;\n      }\n    }\n\n    /**\n     * Get the dialog to which the request belongs to, if any.\n     */\n\n  }, {\n    key: '_findDialog',\n    value: function _findDialog(call_id, from_tag, to_tag) {\n      var id = call_id + from_tag + to_tag;\n      var dialog = this._dialogs[id];\n\n      if (dialog) {\n        return dialog;\n      } else {\n        id = call_id + to_tag + from_tag;\n        dialog = this._dialogs[id];\n        if (dialog) {\n          return dialog;\n        } else {\n          return null;\n        }\n      }\n    }\n  }, {\n    key: '_loadConfig',\n    value: function _loadConfig(configuration) {\n      // Check and load the given configuration.\n      try {\n        config.load(this._configuration, configuration);\n      } catch (e) {\n        throw e;\n      }\n\n      // Post Configuration Process.\n\n      // Allow passing 0 number as display_name.\n      if (this._configuration.display_name === 0) {\n        this._configuration.display_name = '0';\n      }\n\n      // Instance-id for GRUU.\n      if (!this._configuration.instance_id) {\n        this._configuration.instance_id = Utils.newUUID();\n      }\n\n      // Jssip_id instance parameter. Static random tag of length 5.\n      this._configuration.jssip_id = Utils.createRandomToken(5);\n\n      // String containing this._configuration.uri without scheme and user.\n      var hostport_params = this._configuration.uri.clone();\n\n      hostport_params.user = null;\n      this._configuration.hostport_params = hostport_params.toString().replace(/^sip:/i, '');\n\n      // Transport.\n      try {\n        this._transport = new Transport(this._configuration.sockets, {\n          // Recovery options.\n          max_interval: this._configuration.connection_recovery_max_interval,\n          min_interval: this._configuration.connection_recovery_min_interval\n        });\n\n        // Transport event callbacks.\n        this._transport.onconnecting = onTransportConnecting.bind(this);\n        this._transport.onconnect = onTransportConnect.bind(this);\n        this._transport.ondisconnect = onTransportDisconnect.bind(this);\n        this._transport.ondata = onTransportData.bind(this);\n      } catch (e) {\n        debugerror(e);\n        throw new Exceptions.ConfigurationError('sockets', this._configuration.sockets);\n      }\n\n      // Remove sockets instance from configuration object.\n      delete this._configuration.sockets;\n\n      // Check whether authorization_user is explicitly defined.\n      // Take 'this._configuration.uri.user' value if not.\n      if (!this._configuration.authorization_user) {\n        this._configuration.authorization_user = this._configuration.uri.user;\n      }\n\n      // If no 'registrar_server' is set use the 'uri' value without user portion and\n      // without URI params/headers.\n      if (!this._configuration.registrar_server) {\n        var registrar_server = this._configuration.uri.clone();\n\n        registrar_server.user = null;\n        registrar_server.clearParams();\n        registrar_server.clearHeaders();\n        this._configuration.registrar_server = registrar_server;\n      }\n\n      // User no_answer_timeout.\n      this._configuration.no_answer_timeout *= 1000;\n\n      // Via Host.\n      if (this._configuration.contact_uri) {\n        this._configuration.via_host = this._configuration.contact_uri.host;\n      }\n\n      // Contact URI.\n      else {\n          this._configuration.contact_uri = new URI('sip', Utils.createRandomToken(8), this._configuration.via_host, null, { transport: 'ws' });\n        }\n\n      this._contact = {\n        pub_gruu: null,\n        temp_gruu: null,\n        uri: this._configuration.contact_uri,\n        toString: function toString() {\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          var anonymous = options.anonymous || null;\n          var outbound = options.outbound || null;\n          var contact = '<';\n\n          if (anonymous) {\n            contact += this.temp_gruu || 'sip:anonymous@anonymous.invalid;transport=ws';\n          } else {\n            contact += this.pub_gruu || this.uri.toString();\n          }\n\n          if (outbound && (anonymous ? !this.temp_gruu : !this.pub_gruu)) {\n            contact += ';ob';\n          }\n\n          contact += '>';\n\n          return contact;\n        }\n      };\n\n      // Seal the configuration.\n      var writable_parameters = ['password', 'realm', 'ha1', 'display_name', 'register'];\n\n      for (var parameter in this._configuration) {\n        if (Object.prototype.hasOwnProperty.call(this._configuration, parameter)) {\n          if (writable_parameters.indexOf(parameter) !== -1) {\n            Object.defineProperty(this._configuration, parameter, {\n              writable: true,\n              configurable: false\n            });\n          } else {\n            Object.defineProperty(this._configuration, parameter, {\n              writable: false,\n              configurable: false\n            });\n          }\n        }\n      }\n\n      debug('configuration parameters after validation:');\n      for (var _parameter in this._configuration) {\n        // Only show the user user configurable parameters.\n        if (Object.prototype.hasOwnProperty.call(config.settings, _parameter)) {\n          switch (_parameter) {\n            case 'uri':\n            case 'registrar_server':\n              debug('- ' + _parameter + ': ' + this._configuration[_parameter]);\n              break;\n            case 'password':\n            case 'ha1':\n              debug('- ' + _parameter + ': NOT SHOWN');\n              break;\n            default:\n              debug('- ' + _parameter + ': ' + JSON.stringify(this._configuration[_parameter]));\n          }\n        }\n      }\n\n      return;\n    }\n  }, {\n    key: 'C',\n    get: function get() {\n      return C;\n    }\n  }, {\n    key: 'status',\n    get: function get() {\n      return this._status;\n    }\n  }, {\n    key: 'contact',\n    get: function get() {\n      return this._contact;\n    }\n  }, {\n    key: 'configuration',\n    get: function get() {\n      return this._configuration;\n    }\n  }, {\n    key: 'transport',\n    get: function get() {\n      return this._transport;\n    }\n  }]);\n\n  return UA;\n}(EventEmitter);\n\n/**\n * Transport event handlers\n */\n\n// Transport connecting event.\nfunction onTransportConnecting(data) {\n  this.emit('connecting', data);\n}\n\n// Transport connected event.\nfunction onTransportConnect(data) {\n  if (this._status === C.STATUS_USER_CLOSED) {\n    return;\n  }\n\n  this._status = C.STATUS_READY;\n  this._error = null;\n\n  this.emit('connected', data);\n\n  if (this._dynConfiguration.register) {\n    this._registrator.register();\n  }\n}\n\n// Transport disconnected event.\nfunction onTransportDisconnect(data) {\n  // Run _onTransportError_ callback on every client transaction using _transport_.\n  var client_transactions = ['nict', 'ict', 'nist', 'ist'];\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = client_transactions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var type = _step.value;\n\n      for (var id in this._transactions[type]) {\n        if (Object.prototype.hasOwnProperty.call(this._transactions[type], id)) {\n          this._transactions[type][id].onTransportError();\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  this.emit('disconnected', data);\n\n  // Call registrator _onTransportClosed_.\n  this._registrator.onTransportClosed();\n\n  if (this._status !== C.STATUS_USER_CLOSED) {\n    this._status = C.STATUS_NOT_READY;\n    this._error = C.NETWORK_ERROR;\n  }\n}\n\n// Transport data event.\nfunction onTransportData(data) {\n  var transport = data.transport;\n  var message = data.message;\n\n  message = Parser.parseMessage(message, this);\n\n  if (!message) {\n    return;\n  }\n\n  if (this._status === C.STATUS_USER_CLOSED && message instanceof SIPMessage.IncomingRequest) {\n    return;\n  }\n\n  // Do some sanity check.\n  if (!sanityCheck(message, this, transport)) {\n    return;\n  }\n\n  if (message instanceof SIPMessage.IncomingRequest) {\n    message.transport = transport;\n    this.receiveRequest(message);\n  } else if (message instanceof SIPMessage.IncomingResponse) {\n    /* Unike stated in 18.1.2, if a response does not match\n    * any transaction, it is discarded here and no passed to the core\n    * in order to be discarded there.\n    */\n\n    var transaction = void 0;\n\n    switch (message.method) {\n      case SIP_C.INVITE:\n        transaction = this._transactions.ict[message.via_branch];\n        if (transaction) {\n          transaction.receiveResponse(message);\n        }\n        break;\n      case SIP_C.ACK:\n        // Just in case ;-).\n        break;\n      default:\n        transaction = this._transactions.nict[message.via_branch];\n        if (transaction) {\n          transaction.receiveResponse(message);\n        }\n        break;\n    }\n  }\n}\n\n//# sourceURL=webpack://ApolloSIP/./lib/UA.js?");

/***/ }),

/***/ "./lib/URI.js":
/*!********************!*\
  !*** ./lib/URI.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./lib/Grammar.js\");\n\n/**\n * -param {String} [scheme]\n * -param {String} [user]\n * -param {String} host\n * -param {String} [port]\n * -param {Object} [parameters]\n * -param {Object} [headers]\n *\n */\nmodule.exports = function () {\n  _createClass(URI, null, [{\n    key: 'parse',\n\n    /**\n      * Parse the given string and returns a SIP.URI instance or undefined if\n      * it is an invalid URI.\n      */\n    value: function parse(uri) {\n      uri = Grammar.parse(uri, 'SIP_URI');\n\n      if (uri !== -1) {\n        return uri;\n      } else {\n        return undefined;\n      }\n    }\n  }]);\n\n  function URI(scheme, user, host, port) {\n    var parameters = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var headers = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n\n    _classCallCheck(this, URI);\n\n    // Checks.\n    if (!host) {\n      throw new TypeError('missing or invalid \"host\" parameter');\n    }\n\n    // Initialize parameters.\n    this._parameters = {};\n    this._headers = {};\n\n    this._scheme = scheme || SIP_C.SIP;\n    this._user = user;\n    this._host = host;\n    this._port = port;\n\n    for (var param in parameters) {\n      if (Object.prototype.hasOwnProperty.call(parameters, param)) {\n        this.setParam(param, parameters[param]);\n      }\n    }\n\n    for (var header in headers) {\n      if (Object.prototype.hasOwnProperty.call(headers, header)) {\n        this.setHeader(header, headers[header]);\n      }\n    }\n  }\n\n  _createClass(URI, [{\n    key: 'setParam',\n    value: function setParam(key, value) {\n      if (key) {\n        this._parameters[key.toLowerCase()] = typeof value === 'undefined' || value === null ? null : value.toString();\n      }\n    }\n  }, {\n    key: 'getParam',\n    value: function getParam(key) {\n      if (key) {\n        return this._parameters[key.toLowerCase()];\n      }\n    }\n  }, {\n    key: 'hasParam',\n    value: function hasParam(key) {\n      if (key) {\n        return this._parameters.hasOwnProperty(key.toLowerCase()) && true || false;\n      }\n    }\n  }, {\n    key: 'deleteParam',\n    value: function deleteParam(parameter) {\n      parameter = parameter.toLowerCase();\n      if (this._parameters.hasOwnProperty(parameter)) {\n        var value = this._parameters[parameter];\n\n        delete this._parameters[parameter];\n\n        return value;\n      }\n    }\n  }, {\n    key: 'clearParams',\n    value: function clearParams() {\n      this._parameters = {};\n    }\n  }, {\n    key: 'setHeader',\n    value: function setHeader(name, value) {\n      this._headers[Utils.headerize(name)] = Array.isArray(value) ? value : [value];\n    }\n  }, {\n    key: 'getHeader',\n    value: function getHeader(name) {\n      if (name) {\n        return this._headers[Utils.headerize(name)];\n      }\n    }\n  }, {\n    key: 'hasHeader',\n    value: function hasHeader(name) {\n      if (name) {\n        return this._headers.hasOwnProperty(Utils.headerize(name)) && true || false;\n      }\n    }\n  }, {\n    key: 'deleteHeader',\n    value: function deleteHeader(header) {\n      header = Utils.headerize(header);\n      if (this._headers.hasOwnProperty(header)) {\n        var value = this._headers[header];\n\n        delete this._headers[header];\n\n        return value;\n      }\n    }\n  }, {\n    key: 'clearHeaders',\n    value: function clearHeaders() {\n      this._headers = {};\n    }\n  }, {\n    key: 'clone',\n    value: function clone() {\n      return new URI(this._scheme, this._user, this._host, this._port, JSON.parse(JSON.stringify(this._parameters)), JSON.parse(JSON.stringify(this._headers)));\n    }\n  }, {\n    key: 'toString',\n    value: function toString() {\n      var headers = [];\n\n      var uri = this._scheme + ':';\n\n      if (this._user) {\n        uri += Utils.escapeUser(this._user) + '@';\n      }\n      uri += this._host;\n      if (this._port || this._port === 0) {\n        uri += ':' + this._port;\n      }\n\n      for (var parameter in this._parameters) {\n        if (Object.prototype.hasOwnProperty.call(this._parameters, parameter)) {\n          uri += ';' + parameter;\n\n          if (this._parameters[parameter] !== null) {\n            uri += '=' + this._parameters[parameter];\n          }\n        }\n      }\n\n      for (var header in this._headers) {\n        if (Object.prototype.hasOwnProperty.call(this._headers, header)) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = this._headers[header][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var item = _step.value;\n\n              headers.push(header + '=' + item);\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      }\n\n      if (headers.length > 0) {\n        uri += '?' + headers.join('&');\n      }\n\n      return uri;\n    }\n  }, {\n    key: 'toAor',\n    value: function toAor(show_port) {\n      var aor = this._scheme + ':';\n\n      if (this._user) {\n        aor += Utils.escapeUser(this._user) + '@';\n      }\n      aor += this._host;\n      if (show_port && (this._port || this._port === 0)) {\n        aor += ':' + this._port;\n      }\n\n      return aor;\n    }\n  }, {\n    key: 'scheme',\n    get: function get() {\n      return this._scheme;\n    },\n    set: function set(value) {\n      this._scheme = value.toLowerCase();\n    }\n  }, {\n    key: 'user',\n    get: function get() {\n      return this._user;\n    },\n    set: function set(value) {\n      this._user = value;\n    }\n  }, {\n    key: 'host',\n    get: function get() {\n      return this._host;\n    },\n    set: function set(value) {\n      this._host = value.toLowerCase();\n    }\n  }, {\n    key: 'port',\n    get: function get() {\n      return this._port;\n    },\n    set: function set(value) {\n      this._port = value === 0 ? value : parseInt(value, 10) || null;\n    }\n  }]);\n\n  return URI;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./lib/URI.js?");

/***/ }),

/***/ "./lib/Utils.js":
/*!**********************!*\
  !*** ./lib/Utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar URI = __webpack_require__(/*! ./URI */ \"./lib/URI.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./lib/Grammar.js\");\n\nexports.str_utf8_length = function (string) {\n  return unescape(encodeURIComponent(string)).length;\n};\n\n// Used by 'hasMethods'.\nvar isFunction = exports.isFunction = function (fn) {\n  if (fn !== undefined) {\n    return Object.prototype.toString.call(fn) === '[object Function]' ? true : false;\n  } else {\n    return false;\n  }\n};\n\nexports.isString = function (str) {\n  if (str !== undefined) {\n    return Object.prototype.toString.call(str) === '[object String]' ? true : false;\n  } else {\n    return false;\n  }\n};\n\nexports.isDecimal = function (num) {\n  return !isNaN(num) && parseFloat(num) === parseInt(num, 10);\n};\n\nexports.isEmpty = function (value) {\n  return value === null || value === '' || value === undefined || Array.isArray(value) && value.length === 0 || typeof value === 'number' && isNaN(value);\n};\n\nexports.hasMethods = function (obj) {\n  for (var _len = arguments.length, methodNames = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    methodNames[_key - 1] = arguments[_key];\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = methodNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var methodName = _step.value;\n\n      if (isFunction(obj[methodName])) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return true;\n};\n\n// Used by 'newTag'.\nvar createRandomToken = exports.createRandomToken = function (size) {\n  var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n\n  var i = void 0,\n      r = void 0,\n      token = '';\n\n  for (i = 0; i < size; i++) {\n    r = Math.random() * base | 0;\n    token += r.toString(base);\n  }\n\n  return token;\n};\n\nexports.newTag = function () {\n  return createRandomToken(10);\n};\n\n// http://stackoverflow.com/users/109538/broofa.\nexports.newUUID = function () {\n  var UUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0,\n        v = c === 'x' ? r : r & 0x3 | 0x8;\n\n    return v.toString(16);\n  });\n\n  return UUID;\n};\n\nexports.hostType = function (host) {\n  if (!host) {\n    return;\n  } else {\n    host = Grammar.parse(host, 'host');\n    if (host !== -1) {\n      return host.host_type;\n    }\n  }\n};\n\n/**\n* Hex-escape a SIP URI user.\n* Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n*\n* Used by 'normalizeTarget'.\n*/\nvar escapeUser = exports.escapeUser = function (user) {\n  return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');\n};\n\n/**\n* Normalize SIP URI.\n* NOTE: It does not allow a SIP URI without username.\n* Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.\n* Detects the domain part (if given) and properly hex-escapes the user portion.\n* If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.\n*/\nexports.normalizeTarget = function (target, domain) {\n  // If no target is given then raise an error.\n  if (!target) {\n    return;\n    // If a URI instance is given then return it.\n  } else if (target instanceof URI) {\n    return target;\n\n    // If a string is given split it by '@':\n    // - Last fragment is the desired domain.\n    // - Otherwise append the given domain argument.\n  } else if (typeof target === 'string') {\n    var target_array = target.split('@');\n    var target_user = void 0;\n    var target_domain = void 0;\n\n    switch (target_array.length) {\n      case 1:\n        if (!domain) {\n          return;\n        }\n        target_user = target;\n        target_domain = domain;\n        break;\n      case 2:\n        target_user = target_array[0];\n        target_domain = target_array[1];\n        break;\n      default:\n        target_user = target_array.slice(0, target_array.length - 1).join('@');\n        target_domain = target_array[target_array.length - 1];\n    }\n\n    // Remove the URI scheme (if present).\n    target_user = target_user.replace(/^(sips?|tel):/i, '');\n\n    // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.\n    if (/^[-.()]*\\+?[0-9\\-.()]+$/.test(target_user)) {\n      target_user = target_user.replace(/[-.()]/g, '');\n    }\n\n    // Build the complete SIP URI.\n    target = SIP_C.SIP + ':' + escapeUser(target_user) + '@' + target_domain;\n\n    // Finally parse the resulting URI.\n    var uri = void 0;\n\n    if (uri = URI.parse(target)) {\n      return uri;\n    } else {\n      return;\n    }\n  } else {\n    return;\n  }\n};\n\nexports.headerize = function (string) {\n  var exceptions = {\n    'Call-Id': 'Call-ID',\n    'Cseq': 'CSeq',\n    'Www-Authenticate': 'WWW-Authenticate'\n  };\n\n  var name = string.toLowerCase().replace(/_/g, '-').split('-');\n  var hname = '';\n  var parts = name.length;\n  var part = void 0;\n\n  for (part = 0; part < parts; part++) {\n    if (part !== 0) {\n      hname += '-';\n    }\n    hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);\n  }\n  if (exceptions[hname]) {\n    hname = exceptions[hname];\n  }\n\n  return hname;\n};\n\nexports.sipErrorCause = function (status_code) {\n  for (var cause in SIP_C.SIP_ERROR_CAUSES) {\n    if (SIP_C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {\n      return SIP_C.causes[cause];\n    }\n  }\n\n  return SIP_C.causes.SIP_FAILURE_CODE;\n};\n\n/**\n* Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n*/\nexports.getRandomTestNetIP = function () {\n  function getOctet(from, to) {\n    return Math.floor(Math.random() * (to - from + 1) + from);\n  }\n\n  return '192.0.2.' + getOctet(1, 254);\n};\n\n// MD5 (Message-Digest Algorithm) http://www.webtoolkit.info.\nexports.calculateMD5 = function (string) {\n  function rotateLeft(lValue, iShiftBits) {\n    return lValue << iShiftBits | lValue >>> 32 - iShiftBits;\n  }\n\n  function addUnsigned(lX, lY) {\n    var lX8 = lX & 0x80000000;\n    var lY8 = lY & 0x80000000;\n    var lX4 = lX & 0x40000000;\n    var lY4 = lY & 0x40000000;\n    var lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);\n\n    if (lX4 & lY4) {\n      return lResult ^ 0x80000000 ^ lX8 ^ lY8;\n    }\n    if (lX4 | lY4) {\n      if (lResult & 0x40000000) {\n        return lResult ^ 0xC0000000 ^ lX8 ^ lY8;\n      } else {\n        return lResult ^ 0x40000000 ^ lX8 ^ lY8;\n      }\n    } else {\n      return lResult ^ lX8 ^ lY8;\n    }\n  }\n\n  function doF(x, y, z) {\n    return x & y | ~x & z;\n  }\n\n  function doG(x, y, z) {\n    return x & z | y & ~z;\n  }\n\n  function doH(x, y, z) {\n    return x ^ y ^ z;\n  }\n\n  function doI(x, y, z) {\n    return y ^ (x | ~z);\n  }\n\n  function doFF(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doF(b, c, d), x), ac));\n\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function doGG(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doG(b, c, d), x), ac));\n\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function doHH(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doH(b, c, d), x), ac));\n\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function doII(a, b, c, d, x, s, ac) {\n    a = addUnsigned(a, addUnsigned(addUnsigned(doI(b, c, d), x), ac));\n\n    return addUnsigned(rotateLeft(a, s), b);\n  }\n\n  function convertToWordArray(str) {\n    var lWordCount = void 0;\n    var lMessageLength = str.length;\n    var lNumberOfWords_temp1 = lMessageLength + 8;\n    var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - lNumberOfWords_temp1 % 64) / 64;\n    var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;\n    var lWordArray = new Array(lNumberOfWords - 1);\n    var lBytePosition = 0;\n    var lByteCount = 0;\n\n    while (lByteCount < lMessageLength) {\n      lWordCount = (lByteCount - lByteCount % 4) / 4;\n      lBytePosition = lByteCount % 4 * 8;\n      lWordArray[lWordCount] = lWordArray[lWordCount] | str.charCodeAt(lByteCount) << lBytePosition;\n      lByteCount++;\n    }\n    lWordCount = (lByteCount - lByteCount % 4) / 4;\n    lBytePosition = lByteCount % 4 * 8;\n    lWordArray[lWordCount] = lWordArray[lWordCount] | 0x80 << lBytePosition;\n    lWordArray[lNumberOfWords - 2] = lMessageLength << 3;\n    lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;\n\n    return lWordArray;\n  }\n\n  function wordToHex(lValue) {\n    var wordToHexValue = '',\n        wordToHexValue_temp = '',\n        lByte = void 0,\n        lCount = void 0;\n\n    for (lCount = 0; lCount <= 3; lCount++) {\n      lByte = lValue >>> lCount * 8 & 255;\n      wordToHexValue_temp = '0' + lByte.toString(16);\n      wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);\n    }\n\n    return wordToHexValue;\n  }\n\n  function utf8Encode(str) {\n    str = str.replace(/\\r\\n/g, '\\n');\n    var utftext = '';\n\n    for (var n = 0; n < str.length; n++) {\n      var _c = str.charCodeAt(n);\n\n      if (_c < 128) {\n        utftext += String.fromCharCode(_c);\n      } else if (_c > 127 && _c < 2048) {\n        utftext += String.fromCharCode(_c >> 6 | 192);\n        utftext += String.fromCharCode(_c & 63 | 128);\n      } else {\n        utftext += String.fromCharCode(_c >> 12 | 224);\n        utftext += String.fromCharCode(_c >> 6 & 63 | 128);\n        utftext += String.fromCharCode(_c & 63 | 128);\n      }\n    }\n\n    return utftext;\n  }\n\n  var x = [];\n  var k = void 0,\n      AA = void 0,\n      BB = void 0,\n      CC = void 0,\n      DD = void 0,\n      a = void 0,\n      b = void 0,\n      c = void 0,\n      d = void 0;\n  var S11 = 7,\n      S12 = 12,\n      S13 = 17,\n      S14 = 22;\n  var S21 = 5,\n      S22 = 9,\n      S23 = 14,\n      S24 = 20;\n  var S31 = 4,\n      S32 = 11,\n      S33 = 16,\n      S34 = 23;\n  var S41 = 6,\n      S42 = 10,\n      S43 = 15,\n      S44 = 21;\n\n  string = utf8Encode(string);\n\n  x = convertToWordArray(string);\n\n  a = 0x67452301;b = 0xEFCDAB89;c = 0x98BADCFE;d = 0x10325476;\n\n  for (k = 0; k < x.length; k += 16) {\n    AA = a;BB = b;CC = c;DD = d;\n    a = doFF(a, b, c, d, x[k + 0], S11, 0xD76AA478);\n    d = doFF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);\n    c = doFF(c, d, a, b, x[k + 2], S13, 0x242070DB);\n    b = doFF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);\n    a = doFF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);\n    d = doFF(d, a, b, c, x[k + 5], S12, 0x4787C62A);\n    c = doFF(c, d, a, b, x[k + 6], S13, 0xA8304613);\n    b = doFF(b, c, d, a, x[k + 7], S14, 0xFD469501);\n    a = doFF(a, b, c, d, x[k + 8], S11, 0x698098D8);\n    d = doFF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);\n    c = doFF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);\n    b = doFF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);\n    a = doFF(a, b, c, d, x[k + 12], S11, 0x6B901122);\n    d = doFF(d, a, b, c, x[k + 13], S12, 0xFD987193);\n    c = doFF(c, d, a, b, x[k + 14], S13, 0xA679438E);\n    b = doFF(b, c, d, a, x[k + 15], S14, 0x49B40821);\n    a = doGG(a, b, c, d, x[k + 1], S21, 0xF61E2562);\n    d = doGG(d, a, b, c, x[k + 6], S22, 0xC040B340);\n    c = doGG(c, d, a, b, x[k + 11], S23, 0x265E5A51);\n    b = doGG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);\n    a = doGG(a, b, c, d, x[k + 5], S21, 0xD62F105D);\n    d = doGG(d, a, b, c, x[k + 10], S22, 0x2441453);\n    c = doGG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);\n    b = doGG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);\n    a = doGG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);\n    d = doGG(d, a, b, c, x[k + 14], S22, 0xC33707D6);\n    c = doGG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);\n    b = doGG(b, c, d, a, x[k + 8], S24, 0x455A14ED);\n    a = doGG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);\n    d = doGG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);\n    c = doGG(c, d, a, b, x[k + 7], S23, 0x676F02D9);\n    b = doGG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);\n    a = doHH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);\n    d = doHH(d, a, b, c, x[k + 8], S32, 0x8771F681);\n    c = doHH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);\n    b = doHH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);\n    a = doHH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);\n    d = doHH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);\n    c = doHH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);\n    b = doHH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);\n    a = doHH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);\n    d = doHH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);\n    c = doHH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);\n    b = doHH(b, c, d, a, x[k + 6], S34, 0x4881D05);\n    a = doHH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);\n    d = doHH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);\n    c = doHH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);\n    b = doHH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);\n    a = doII(a, b, c, d, x[k + 0], S41, 0xF4292244);\n    d = doII(d, a, b, c, x[k + 7], S42, 0x432AFF97);\n    c = doII(c, d, a, b, x[k + 14], S43, 0xAB9423A7);\n    b = doII(b, c, d, a, x[k + 5], S44, 0xFC93A039);\n    a = doII(a, b, c, d, x[k + 12], S41, 0x655B59C3);\n    d = doII(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);\n    c = doII(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);\n    b = doII(b, c, d, a, x[k + 1], S44, 0x85845DD1);\n    a = doII(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);\n    d = doII(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);\n    c = doII(c, d, a, b, x[k + 6], S43, 0xA3014314);\n    b = doII(b, c, d, a, x[k + 13], S44, 0x4E0811A1);\n    a = doII(a, b, c, d, x[k + 4], S41, 0xF7537E82);\n    d = doII(d, a, b, c, x[k + 11], S42, 0xBD3AF235);\n    c = doII(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);\n    b = doII(b, c, d, a, x[k + 9], S44, 0xEB86D391);\n    a = addUnsigned(a, AA);\n    b = addUnsigned(b, BB);\n    c = addUnsigned(c, CC);\n    d = addUnsigned(d, DD);\n  }\n\n  var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);\n\n  return temp.toLowerCase();\n};\n\nexports.closeMediaStream = function (stream) {\n  if (!stream) {\n    return;\n  }\n\n  // Latest spec states that MediaStream has no stop() method and instead must\n  // call stop() on every MediaStreamTrack.\n  try {\n    var tracks = void 0;\n\n    if (stream.getTracks) {\n      tracks = stream.getTracks();\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = tracks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var track = _step2.value;\n\n          track.stop();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    } else {\n      tracks = stream.getAudioTracks();\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = tracks[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _track = _step3.value;\n\n          _track.stop();\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      tracks = stream.getVideoTracks();\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = tracks[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var _track2 = _step4.value;\n\n          _track2.stop();\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n  } catch (error) {\n    // Deprecated by the spec, but still in use.\n    // NOTE: In Temasys IE plugin stream.stop is a callable 'object'.\n    if (typeof stream.stop === 'function' || _typeof(stream.stop) === 'object') {\n      stream.stop();\n    }\n  }\n};\n\nexports.cloneArray = function (array) {\n  return array && array.slice() || [];\n};\n\n//# sourceURL=webpack://ApolloSIP/./lib/Utils.js?");

/***/ }),

/***/ "./lib/WebSocket.js":
/*!**************************!*\
  !*** ./lib/WebSocket.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ws = null;\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket;\n} else if (typeof MozWebSocket !== 'undefined') {\n  /* eslint-disable no-undef */\n  ws = MozWebSocket;\n  /* eslint-enable no-undef */\n} else if (typeof global !== 'undefined') {\n  ws = global.WebSocket || global.MozWebSocket;\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket;\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket;\n}\n\nmodule.exports = ws;\n\n//# sourceURL=webpack://ApolloSIP/./lib/WebSocket.js?");

/***/ }),

/***/ "./lib/WebSocketInterface.js":
/*!***********************************!*\
  !*** ./lib/WebSocketInterface.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar WebSocket = __webpack_require__(/*! ./WebSocket */ \"./lib/WebSocket.js\");\nvar Grammar = __webpack_require__(/*! ./Grammar */ \"./lib/Grammar.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:WebSocketInterface');\nvar debugerror = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:ERROR:WebSocketInterface');\n\ndebugerror.log = console.warn.bind(console);\n\nmodule.exports = function () {\n  function WebSocketInterface(url, options) {\n    _classCallCheck(this, WebSocketInterface);\n\n    debug('new() [url:\"%s\"]', url);\n\n    this._url = url;\n    this._options = options;\n    this._sip_uri = null;\n    this._via_transport = null;\n    this._ws = null;\n\n    var parsed_url = Grammar.parse(url, 'absoluteURI');\n\n    if (parsed_url === -1) {\n      debugerror('invalid WebSocket URI: ' + url);\n      throw new TypeError('Invalid argument: ' + url);\n    } else if (parsed_url.scheme !== 'wss' && parsed_url.scheme !== 'ws') {\n      debugerror('invalid WebSocket URI scheme: ' + parsed_url.scheme);\n      throw new TypeError('Invalid argument: ' + url);\n    } else {\n      this._sip_uri = 'sip:' + parsed_url.host + (parsed_url.port ? ':' + parsed_url.port : '') + ';transport=ws';\n      this._via_transport = parsed_url.scheme.toUpperCase();\n    }\n  }\n\n  _createClass(WebSocketInterface, [{\n    key: 'connect',\n    value: function connect() {\n      debug('connect()');\n\n      if (this.isConnected()) {\n        debug('WebSocket ' + this._url + ' is already connected');\n\n        return;\n      } else if (this.isConnecting()) {\n        debug('WebSocket ' + this._url + ' is connecting');\n\n        return;\n      }\n\n      if (this._ws) {\n        this.disconnect();\n      }\n\n      debug('connecting to WebSocket ' + this._url);\n\n      try {\n        this._ws = new WebSocket(this._url, 'sip', this._options);\n\n        this._ws.binaryType = 'arraybuffer';\n\n        this._ws.onopen = this._onOpen.bind(this);\n        this._ws.onclose = this._onClose.bind(this);\n        this._ws.onmessage = this._onMessage.bind(this);\n        this._ws.onerror = this._onError.bind(this);\n      } catch (e) {\n        this._onError(e);\n      }\n    }\n  }, {\n    key: 'disconnect',\n    value: function disconnect() {\n      debug('disconnect()');\n\n      if (this._ws) {\n        // Unbind websocket event callbacks.\n        this._ws.onopen = function () {};\n        this._ws.onclose = function () {};\n        this._ws.onmessage = function () {};\n        this._ws.onerror = function () {};\n\n        this._ws.close();\n        this._ws = null;\n      }\n    }\n  }, {\n    key: 'send',\n    value: function send(message) {\n      debug('send()');\n\n      if (this.isConnected()) {\n        this._ws.send(message);\n\n        return true;\n      } else {\n        debugerror('unable to send message, WebSocket is not open');\n\n        return false;\n      }\n    }\n  }, {\n    key: 'isConnected',\n    value: function isConnected() {\n      return this._ws && this._ws.readyState === this._ws.OPEN;\n    }\n  }, {\n    key: 'isConnecting',\n    value: function isConnecting() {\n      return this._ws && this._ws.readyState === this._ws.CONNECTING;\n    }\n\n    /**\n     * WebSocket Event Handlers\n     */\n\n  }, {\n    key: '_onOpen',\n    value: function _onOpen() {\n      debug('WebSocket ' + this._url + ' connected');\n\n      this.onconnect();\n    }\n  }, {\n    key: '_onClose',\n    value: function _onClose(_ref) {\n      var wasClean = _ref.wasClean,\n          code = _ref.code,\n          reason = _ref.reason;\n\n      debug('WebSocket ' + this._url + ' closed');\n\n      if (wasClean === false) {\n        debug('WebSocket abrupt disconnection');\n      }\n\n      var data = {\n        socket: this,\n        error: !wasClean,\n        code: code,\n        reason: reason\n      };\n\n      this.ondisconnect(data);\n    }\n  }, {\n    key: '_onMessage',\n    value: function _onMessage(_ref2) {\n      var data = _ref2.data;\n\n      debug('received WebSocket message');\n\n      this.ondata(data);\n    }\n  }, {\n    key: '_onError',\n    value: function _onError(e) {\n      debugerror('WebSocket ' + this._url + ' error: %o', e);\n    }\n  }, {\n    key: 'via_transport',\n    get: function get() {\n      return this._via_transport;\n    },\n    set: function set(value) {\n      this._via_transport = value.toUpperCase();\n    }\n  }, {\n    key: 'sip_uri',\n    get: function get() {\n      return this._sip_uri;\n    }\n  }, {\n    key: 'url',\n    get: function get() {\n      return this._url;\n    }\n  }]);\n\n  return WebSocketInterface;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./lib/WebSocketInterface.js?");

/***/ }),

/***/ "./lib/sanityCheck.js":
/*!****************************!*\
  !*** ./lib/sanityCheck.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar SIP_C = __webpack_require__(/*! ./Constants */ \"./lib/Constants.js\");\nvar SIPMessage = __webpack_require__(/*! ./SIPMessage */ \"./lib/SIPMessage.js\");\nvar Utils = __webpack_require__(/*! ./Utils */ \"./lib/Utils.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('SIP:sanityCheck');\n\n// Checks for requests and responses.\nvar all = [minimumHeaders];\n\n// Checks for requests.\nvar requests = [rfc3261_8_2_2_1, rfc3261_16_3_4, rfc3261_18_3_request, rfc3261_8_2_2_2];\n\n// Checks for responses.\nvar responses = [rfc3261_8_1_3_3, rfc3261_18_3_response];\n\n// local variables.\nvar message = void 0;\nvar ua = void 0;\nvar transport = void 0;\n\nmodule.exports = function (m, u, t) {\n  message = m;\n  ua = u;\n  transport = t;\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = all[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var check = _step.value;\n\n      if (check() === false) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (message instanceof SIPMessage.IncomingRequest) {\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = requests[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _check = _step2.value;\n\n        if (_check() === false) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  } else if (message instanceof SIPMessage.IncomingResponse) {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = responses[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _check2 = _step3.value;\n\n        if (_check2() === false) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n  }\n\n  // Everything is OK.\n  return true;\n};\n\n/*\n * Sanity Check for incoming Messages\n *\n * Requests:\n *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme\n *  - _rfc3261_16_3_4_ Receive a Request already sent by us\n *   Does not look at via sent-by but at jssip_id, which is inserted as\n *   a prefix in all initial requests generated by the ua\n *  - _rfc3261_18_3_request_ Body Content-Length\n *  - _rfc3261_8_2_2_2_ Merged Requests\n *\n * Responses:\n *  - _rfc3261_8_1_3_3_ Multiple Via headers\n *  - _rfc3261_18_3_response_ Body Content-Length\n *\n * All:\n *  - Minimum headers in a SIP message\n */\n\n// Sanity Check functions for requests.\nfunction rfc3261_8_2_2_1() {\n  if (message.s('to').uri.scheme !== 'sip') {\n    reply(416);\n\n    return false;\n  }\n}\n\nfunction rfc3261_16_3_4() {\n  if (!message.to_tag) {\n    if (message.call_id.substr(0, 5) === ua.configuration.jssip_id) {\n      reply(482);\n\n      return false;\n    }\n  }\n}\n\nfunction rfc3261_18_3_request() {\n  var len = Utils.str_utf8_length(message.body);\n  var contentLength = message.getHeader('content-length');\n\n  if (len < contentLength) {\n    reply(400);\n\n    return false;\n  }\n}\n\nfunction rfc3261_8_2_2_2() {\n  var fromTag = message.from_tag;\n  var call_id = message.call_id;\n  var cseq = message.cseq;\n  var tr = void 0;\n\n  // Accept any in-dialog request.\n  if (message.to_tag) {\n    return;\n  }\n\n  // INVITE request.\n  if (message.method === SIP_C.INVITE) {\n    // If the branch matches the key of any IST then assume it is a retransmission\n    // and ignore the INVITE.\n    // TODO: we should reply the last response.\n    if (ua._transactions.ist[message.via_branch]) {\n      return false;\n    }\n    // Otherwise check whether it is a merged request.\n    else {\n        for (var transaction in ua._transactions.ist) {\n          if (Object.prototype.hasOwnProperty.call(ua._transactions.ist, transaction)) {\n            tr = ua._transactions.ist[transaction];\n            if (tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n              reply(482);\n\n              return false;\n            }\n          }\n        }\n      }\n  }\n\n  // Non INVITE request.\n\n  // If the branch matches the key of any NIST then assume it is a retransmission\n  // and ignore the request.\n  // TODO: we should reply the last response.\n  else if (ua._transactions.nist[message.via_branch]) {\n      return false;\n    }\n\n    // Otherwise check whether it is a merged request.\n    else {\n        for (var _transaction in ua._transactions.nist) {\n          if (Object.prototype.hasOwnProperty.call(ua._transactions.nist, _transaction)) {\n            tr = ua._transactions.nist[_transaction];\n            if (tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n              reply(482);\n\n              return false;\n            }\n          }\n        }\n      }\n}\n\n// Sanity Check functions for responses.\nfunction rfc3261_8_1_3_3() {\n  if (message.getHeaders('via').length > 1) {\n    debug('more than one Via header field present in the response, dropping the response');\n\n    return false;\n  }\n}\n\nfunction rfc3261_18_3_response() {\n  var len = Utils.str_utf8_length(message.body),\n      contentLength = message.getHeader('content-length');\n\n  if (len < contentLength) {\n    debug('message body length is lower than the value in Content-Length header field, dropping the response');\n\n    return false;\n  }\n}\n\n// Sanity Check functions for requests and responses.\nfunction minimumHeaders() {\n  var mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'];\n\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = mandatoryHeaders[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var header = _step4.value;\n\n      if (!message.hasHeader(header)) {\n        debug('missing mandatory header field : ' + header + ', dropping the response');\n\n        return false;\n      }\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\n// Reply.\nfunction reply(status_code) {\n  var vias = message.getHeaders('via');\n\n  var to = void 0;\n  var response = 'SIP/2.0 ' + status_code + ' ' + SIP_C.REASON_PHRASE[status_code] + '\\r\\n';\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = vias[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var via = _step5.value;\n\n      response += 'Via: ' + via + '\\r\\n';\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n\n  to = message.getHeader('To');\n\n  if (!message.to_tag) {\n    to += ';tag=' + Utils.newTag();\n  }\n\n  response += 'To: ' + to + '\\r\\n';\n  response += 'From: ' + message.getHeader('From') + '\\r\\n';\n  response += 'Call-ID: ' + message.call_id + '\\r\\n';\n  response += 'CSeq: ' + message.cseq + ' ' + message.method + '\\r\\n';\n  response += '\\r\\n';\n\n  transport.send(response);\n}\n\n//# sourceURL=webpack://ApolloSIP/./lib/sanityCheck.js?");

/***/ }),

/***/ "./node_modules/after/index.js":
/*!*************************************!*\
  !*** ./node_modules/after/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = after\n\nfunction after(count, callback, err_cb) {\n    var bail = false\n    err_cb = err_cb || noop\n    proxy.count = count\n\n    return (count === 0) ? callback() : proxy\n\n    function proxy(err, result) {\n        if (proxy.count <= 0) {\n            throw new Error('after called too many times')\n        }\n        --proxy.count\n\n        // after first error, rest are passed to err_cb\n        if (err) {\n            bail = true\n            callback(err)\n            // future error callbacks will go to error handler\n            callback = err_cb\n        } else if (proxy.count === 0 && !bail) {\n            callback(null, result)\n        }\n    }\n}\n\nfunction noop() {}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/after/index.js?");

/***/ }),

/***/ "./node_modules/async-limiter/index.js":
/*!*********************************************!*\
  !*** ./node_modules/async-limiter/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction Queue(options) {\n  if (!(this instanceof Queue)) {\n    return new Queue(options);\n  }\n\n  options = options || {};\n  this.concurrency = options.concurrency || Infinity;\n  this.pending = 0;\n  this.jobs = [];\n  this.cbs = [];\n  this._done = done.bind(this);\n}\n\nvar arrayAddMethods = [\n  'push',\n  'unshift',\n  'splice'\n];\n\narrayAddMethods.forEach(function(method) {\n  Queue.prototype[method] = function() {\n    var methodResult = Array.prototype[method].apply(this.jobs, arguments);\n    this._run();\n    return methodResult;\n  };\n});\n\nObject.defineProperty(Queue.prototype, 'length', {\n  get: function() {\n    return this.pending + this.jobs.length;\n  }\n});\n\nQueue.prototype._run = function() {\n  if (this.pending === this.concurrency) {\n    return;\n  }\n  if (this.jobs.length) {\n    var job = this.jobs.shift();\n    this.pending++;\n    job(this._done);\n    this._run();\n  }\n\n  if (this.pending === 0) {\n    while (this.cbs.length !== 0) {\n      var cb = this.cbs.pop();\n      process.nextTick(cb);\n    }\n  }\n};\n\nQueue.prototype.onDone = function(cb) {\n  if (typeof cb === 'function') {\n    this.cbs.push(cb);\n    this._run();\n  }\n};\n\nfunction done() {\n  this.pending--;\n  this._run();\n}\n\nmodule.exports = Queue;\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/async-limiter/index.js?");

/***/ }),

/***/ "./node_modules/backo2/index.js":
/*!**************************************!*\
  !*** ./node_modules/backo2/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * Expose `Backoff`.\n */\n\nmodule.exports = Backoff;\n\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction Backoff(opts) {\n  opts = opts || {};\n  this.ms = opts.min || 100;\n  this.max = opts.max || 10000;\n  this.factor = opts.factor || 2;\n  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n  this.attempts = 0;\n}\n\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\n\nBackoff.prototype.duration = function(){\n  var ms = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var rand =  Math.random();\n    var deviation = Math.floor(rand * this.jitter * ms);\n    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;\n  }\n  return Math.min(ms, this.max) | 0;\n};\n\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\n\nBackoff.prototype.reset = function(){\n  this.attempts = 0;\n};\n\n/**\n * Set the minimum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMin = function(min){\n  this.ms = min;\n};\n\n/**\n * Set the maximum duration\n *\n * @api public\n */\n\nBackoff.prototype.setMax = function(max){\n  this.max = max;\n};\n\n/**\n * Set the jitter\n *\n * @api public\n */\n\nBackoff.prototype.setJitter = function(jitter){\n  this.jitter = jitter;\n};\n\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/backo2/index.js?");

/***/ }),

/***/ "./node_modules/bowser/src/bowser.js":
/*!*******************************************!*\
  !*** ./node_modules/bowser/src/bowser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Bowser - a browser detector\n * https://github.com/ded/bowser\n * MIT License | (c) Dustin Diaz 2015\n */\n\n!function (root, name, definition) {\n  if (typeof module != 'undefined' && module.exports) module.exports = definition()\n  else if (true) __webpack_require__(/*! !webpack amd define */ \"./node_modules/webpack/buildin/amd-define.js\")(name, definition)\n  else {}\n}(this, 'bowser', function () {\n  /**\n    * See useragents.js for examples of navigator.userAgent\n    */\n\n  var t = true\n\n  function detect(ua) {\n\n    function getFirstMatch(regex) {\n      var match = ua.match(regex);\n      return (match && match.length > 1 && match[1]) || '';\n    }\n\n    function getSecondMatch(regex) {\n      var match = ua.match(regex);\n      return (match && match.length > 1 && match[2]) || '';\n    }\n\n    var iosdevice = getFirstMatch(/(ipod|iphone|ipad)/i).toLowerCase()\n      , likeAndroid = /like android/i.test(ua)\n      , android = !likeAndroid && /android/i.test(ua)\n      , nexusMobile = /nexus\\s*[0-6]\\s*/i.test(ua)\n      , nexusTablet = !nexusMobile && /nexus\\s*[0-9]+/i.test(ua)\n      , chromeos = /CrOS/.test(ua)\n      , silk = /silk/i.test(ua)\n      , sailfish = /sailfish/i.test(ua)\n      , tizen = /tizen/i.test(ua)\n      , webos = /(web|hpw)os/i.test(ua)\n      , windowsphone = /windows phone/i.test(ua)\n      , samsungBrowser = /SamsungBrowser/i.test(ua)\n      , windows = !windowsphone && /windows/i.test(ua)\n      , mac = !iosdevice && !silk && /macintosh/i.test(ua)\n      , linux = !android && !sailfish && !tizen && !webos && /linux/i.test(ua)\n      , edgeVersion = getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.\\d+)?)/i)\n      , versionIdentifier = getFirstMatch(/version\\/(\\d+(\\.\\d+)?)/i)\n      , tablet = /tablet/i.test(ua) && !/tablet pc/i.test(ua)\n      , mobile = !tablet && /[^-]mobi/i.test(ua)\n      , xbox = /xbox/i.test(ua)\n      , result\n\n    if (/opera/i.test(ua)) {\n      //  an old Opera\n      result = {\n        name: 'Opera'\n      , opera: t\n      , version: versionIdentifier || getFirstMatch(/(?:opera|opr|opios)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    } else if (/opr\\/|opios/i.test(ua)) {\n      // a new Opera\n      result = {\n        name: 'Opera'\n        , opera: t\n        , version: getFirstMatch(/(?:opr|opios)[\\s\\/](\\d+(\\.\\d+)?)/i) || versionIdentifier\n      }\n    }\n    else if (/SamsungBrowser/i.test(ua)) {\n      result = {\n        name: 'Samsung Internet for Android'\n        , samsungBrowser: t\n        , version: versionIdentifier || getFirstMatch(/(?:SamsungBrowser)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/coast/i.test(ua)) {\n      result = {\n        name: 'Opera Coast'\n        , coast: t\n        , version: versionIdentifier || getFirstMatch(/(?:coast)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/yabrowser/i.test(ua)) {\n      result = {\n        name: 'Yandex Browser'\n      , yandexbrowser: t\n      , version: versionIdentifier || getFirstMatch(/(?:yabrowser)[\\s\\/](\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/ucbrowser/i.test(ua)) {\n      result = {\n          name: 'UC Browser'\n        , ucbrowser: t\n        , version: getFirstMatch(/(?:ucbrowser)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/mxios/i.test(ua)) {\n      result = {\n        name: 'Maxthon'\n        , maxthon: t\n        , version: getFirstMatch(/(?:mxios)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/epiphany/i.test(ua)) {\n      result = {\n        name: 'Epiphany'\n        , epiphany: t\n        , version: getFirstMatch(/(?:epiphany)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/puffin/i.test(ua)) {\n      result = {\n        name: 'Puffin'\n        , puffin: t\n        , version: getFirstMatch(/(?:puffin)[\\s\\/](\\d+(?:\\.\\d+)?)/i)\n      }\n    }\n    else if (/sleipnir/i.test(ua)) {\n      result = {\n        name: 'Sleipnir'\n        , sleipnir: t\n        , version: getFirstMatch(/(?:sleipnir)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (/k-meleon/i.test(ua)) {\n      result = {\n        name: 'K-Meleon'\n        , kMeleon: t\n        , version: getFirstMatch(/(?:k-meleon)[\\s\\/](\\d+(?:\\.\\d+)+)/i)\n      }\n    }\n    else if (windowsphone) {\n      result = {\n        name: 'Windows Phone'\n      , osname: 'Windows Phone'\n      , windowsphone: t\n      }\n      if (edgeVersion) {\n        result.msedge = t\n        result.version = edgeVersion\n      }\n      else {\n        result.msie = t\n        result.version = getFirstMatch(/iemobile\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/msie|trident/i.test(ua)) {\n      result = {\n        name: 'Internet Explorer'\n      , msie: t\n      , version: getFirstMatch(/(?:msie |rv:)(\\d+(\\.\\d+)?)/i)\n      }\n    } else if (chromeos) {\n      result = {\n        name: 'Chrome'\n      , osname: 'Chrome OS'\n      , chromeos: t\n      , chromeBook: t\n      , chrome: t\n      , version: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i)\n      }\n    } else if (/edg([ea]|ios)/i.test(ua)) {\n      result = {\n        name: 'Microsoft Edge'\n      , msedge: t\n      , version: edgeVersion\n      }\n    }\n    else if (/vivaldi/i.test(ua)) {\n      result = {\n        name: 'Vivaldi'\n        , vivaldi: t\n        , version: getFirstMatch(/vivaldi\\/(\\d+(\\.\\d+)?)/i) || versionIdentifier\n      }\n    }\n    else if (sailfish) {\n      result = {\n        name: 'Sailfish'\n      , osname: 'Sailfish OS'\n      , sailfish: t\n      , version: getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/seamonkey\\//i.test(ua)) {\n      result = {\n        name: 'SeaMonkey'\n      , seamonkey: t\n      , version: getFirstMatch(/seamonkey\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/firefox|iceweasel|fxios/i.test(ua)) {\n      result = {\n        name: 'Firefox'\n      , firefox: t\n      , version: getFirstMatch(/(?:firefox|iceweasel|fxios)[ \\/](\\d+(\\.\\d+)?)/i)\n      }\n      if (/\\((mobile|tablet);[^\\)]*rv:[\\d\\.]+\\)/i.test(ua)) {\n        result.firefoxos = t\n        result.osname = 'Firefox OS'\n      }\n    }\n    else if (silk) {\n      result =  {\n        name: 'Amazon Silk'\n      , silk: t\n      , version : getFirstMatch(/silk\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/phantom/i.test(ua)) {\n      result = {\n        name: 'PhantomJS'\n      , phantom: t\n      , version: getFirstMatch(/phantomjs\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/slimerjs/i.test(ua)) {\n      result = {\n        name: 'SlimerJS'\n        , slimer: t\n        , version: getFirstMatch(/slimerjs\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (/blackberry|\\bbb\\d+/i.test(ua) || /rim\\stablet/i.test(ua)) {\n      result = {\n        name: 'BlackBerry'\n      , osname: 'BlackBerry OS'\n      , blackberry: t\n      , version: versionIdentifier || getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (webos) {\n      result = {\n        name: 'WebOS'\n      , osname: 'WebOS'\n      , webos: t\n      , version: versionIdentifier || getFirstMatch(/w(?:eb)?osbrowser\\/(\\d+(\\.\\d+)?)/i)\n      };\n      /touchpad\\//i.test(ua) && (result.touchpad = t)\n    }\n    else if (/bada/i.test(ua)) {\n      result = {\n        name: 'Bada'\n      , osname: 'Bada'\n      , bada: t\n      , version: getFirstMatch(/dolfin\\/(\\d+(\\.\\d+)?)/i)\n      };\n    }\n    else if (tizen) {\n      result = {\n        name: 'Tizen'\n      , osname: 'Tizen'\n      , tizen: t\n      , version: getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.\\d+)?)/i) || versionIdentifier\n      };\n    }\n    else if (/qupzilla/i.test(ua)) {\n      result = {\n        name: 'QupZilla'\n        , qupzilla: t\n        , version: getFirstMatch(/(?:qupzilla)[\\s\\/](\\d+(?:\\.\\d+)+)/i) || versionIdentifier\n      }\n    }\n    else if (/chromium/i.test(ua)) {\n      result = {\n        name: 'Chromium'\n        , chromium: t\n        , version: getFirstMatch(/(?:chromium)[\\s\\/](\\d+(?:\\.\\d+)?)/i) || versionIdentifier\n      }\n    }\n    else if (/chrome|crios|crmo/i.test(ua)) {\n      result = {\n        name: 'Chrome'\n        , chrome: t\n        , version: getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.\\d+)?)/i)\n      }\n    }\n    else if (android) {\n      result = {\n        name: 'Android'\n        , version: versionIdentifier\n      }\n    }\n    else if (/safari|applewebkit/i.test(ua)) {\n      result = {\n        name: 'Safari'\n      , safari: t\n      }\n      if (versionIdentifier) {\n        result.version = versionIdentifier\n      }\n    }\n    else if (iosdevice) {\n      result = {\n        name : iosdevice == 'iphone' ? 'iPhone' : iosdevice == 'ipad' ? 'iPad' : 'iPod'\n      }\n      // WTF: version is not part of user agent in web apps\n      if (versionIdentifier) {\n        result.version = versionIdentifier\n      }\n    }\n    else if(/googlebot/i.test(ua)) {\n      result = {\n        name: 'Googlebot'\n      , googlebot: t\n      , version: getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i) || versionIdentifier\n      }\n    }\n    else {\n      result = {\n        name: getFirstMatch(/^(.*)\\/(.*) /),\n        version: getSecondMatch(/^(.*)\\/(.*) /)\n     };\n   }\n\n    // set webkit or gecko flag for browsers based on these engines\n    if (!result.msedge && /(apple)?webkit/i.test(ua)) {\n      if (/(apple)?webkit\\/537\\.36/i.test(ua)) {\n        result.name = result.name || \"Blink\"\n        result.blink = t\n      } else {\n        result.name = result.name || \"Webkit\"\n        result.webkit = t\n      }\n      if (!result.version && versionIdentifier) {\n        result.version = versionIdentifier\n      }\n    } else if (!result.opera && /gecko\\//i.test(ua)) {\n      result.name = result.name || \"Gecko\"\n      result.gecko = t\n      result.version = result.version || getFirstMatch(/gecko\\/(\\d+(\\.\\d+)?)/i)\n    }\n\n    // set OS flags for platforms that have multiple browsers\n    if (!result.windowsphone && (android || result.silk)) {\n      result.android = t\n      result.osname = 'Android'\n    } else if (!result.windowsphone && iosdevice) {\n      result[iosdevice] = t\n      result.ios = t\n      result.osname = 'iOS'\n    } else if (mac) {\n      result.mac = t\n      result.osname = 'macOS'\n    } else if (xbox) {\n      result.xbox = t\n      result.osname = 'Xbox'\n    } else if (windows) {\n      result.windows = t\n      result.osname = 'Windows'\n    } else if (linux) {\n      result.linux = t\n      result.osname = 'Linux'\n    }\n\n    function getWindowsVersion (s) {\n      switch (s) {\n        case 'NT': return 'NT'\n        case 'XP': return 'XP'\n        case 'NT 5.0': return '2000'\n        case 'NT 5.1': return 'XP'\n        case 'NT 5.2': return '2003'\n        case 'NT 6.0': return 'Vista'\n        case 'NT 6.1': return '7'\n        case 'NT 6.2': return '8'\n        case 'NT 6.3': return '8.1'\n        case 'NT 10.0': return '10'\n        default: return undefined\n      }\n    }\n\n    // OS version extraction\n    var osVersion = '';\n    if (result.windows) {\n      osVersion = getWindowsVersion(getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i))\n    } else if (result.windowsphone) {\n      osVersion = getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i);\n    } else if (result.mac) {\n      osVersion = getFirstMatch(/Mac OS X (\\d+([_\\.\\s]\\d+)*)/i);\n      osVersion = osVersion.replace(/[_\\s]/g, '.');\n    } else if (iosdevice) {\n      osVersion = getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i);\n      osVersion = osVersion.replace(/[_\\s]/g, '.');\n    } else if (android) {\n      osVersion = getFirstMatch(/android[ \\/-](\\d+(\\.\\d+)*)/i);\n    } else if (result.webos) {\n      osVersion = getFirstMatch(/(?:web|hpw)os\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.blackberry) {\n      osVersion = getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i);\n    } else if (result.bada) {\n      osVersion = getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i);\n    } else if (result.tizen) {\n      osVersion = getFirstMatch(/tizen[\\/\\s](\\d+(\\.\\d+)*)/i);\n    }\n    if (osVersion) {\n      result.osversion = osVersion;\n    }\n\n    // device type extraction\n    var osMajorVersion = !result.windows && osVersion.split('.')[0];\n    if (\n         tablet\n      || nexusTablet\n      || iosdevice == 'ipad'\n      || (android && (osMajorVersion == 3 || (osMajorVersion >= 4 && !mobile)))\n      || result.silk\n    ) {\n      result.tablet = t\n    } else if (\n         mobile\n      || iosdevice == 'iphone'\n      || iosdevice == 'ipod'\n      || android\n      || nexusMobile\n      || result.blackberry\n      || result.webos\n      || result.bada\n    ) {\n      result.mobile = t\n    }\n\n    // Graded Browser Support\n    // http://developer.yahoo.com/yui/articles/gbs\n    if (result.msedge ||\n        (result.msie && result.version >= 10) ||\n        (result.yandexbrowser && result.version >= 15) ||\n\t\t    (result.vivaldi && result.version >= 1.0) ||\n        (result.chrome && result.version >= 20) ||\n        (result.samsungBrowser && result.version >= 4) ||\n        (result.firefox && result.version >= 20.0) ||\n        (result.safari && result.version >= 6) ||\n        (result.opera && result.version >= 10.0) ||\n        (result.ios && result.osversion && result.osversion.split(\".\")[0] >= 6) ||\n        (result.blackberry && result.version >= 10.1)\n        || (result.chromium && result.version >= 20)\n        ) {\n      result.a = t;\n    }\n    else if ((result.msie && result.version < 10) ||\n        (result.chrome && result.version < 20) ||\n        (result.firefox && result.version < 20.0) ||\n        (result.safari && result.version < 6) ||\n        (result.opera && result.version < 10.0) ||\n        (result.ios && result.osversion && result.osversion.split(\".\")[0] < 6)\n        || (result.chromium && result.version < 20)\n        ) {\n      result.c = t\n    } else result.x = t\n\n    return result\n  }\n\n  var bowser = detect(typeof navigator !== 'undefined' ? navigator.userAgent || '' : '')\n\n  bowser.test = function (browserList) {\n    for (var i = 0; i < browserList.length; ++i) {\n      var browserItem = browserList[i];\n      if (typeof browserItem=== 'string') {\n        if (browserItem in bowser) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get version precisions count\n   *\n   * @example\n   *   getVersionPrecision(\"1.10.3\") // 3\n   *\n   * @param  {string} version\n   * @return {number}\n   */\n  function getVersionPrecision(version) {\n    return version.split(\".\").length;\n  }\n\n  /**\n   * Array::map polyfill\n   *\n   * @param  {Array} arr\n   * @param  {Function} iterator\n   * @return {Array}\n   */\n  function map(arr, iterator) {\n    var result = [], i;\n    if (Array.prototype.map) {\n      return Array.prototype.map.call(arr, iterator);\n    }\n    for (i = 0; i < arr.length; i++) {\n      result.push(iterator(arr[i]));\n    }\n    return result;\n  }\n\n  /**\n   * Calculate browser version weight\n   *\n   * @example\n   *   compareVersions(['1.10.2.1',  '1.8.2.1.90'])    // 1\n   *   compareVersions(['1.010.2.1', '1.09.2.1.90']);  // 1\n   *   compareVersions(['1.10.2.1',  '1.10.2.1']);     // 0\n   *   compareVersions(['1.10.2.1',  '1.0800.2']);     // -1\n   *\n   * @param  {Array<String>} versions versions to compare\n   * @return {Number} comparison result\n   */\n  function compareVersions(versions) {\n    // 1) get common precision for both versions, for example for \"10.0\" and \"9\" it should be 2\n    var precision = Math.max(getVersionPrecision(versions[0]), getVersionPrecision(versions[1]));\n    var chunks = map(versions, function (version) {\n      var delta = precision - getVersionPrecision(version);\n\n      // 2) \"9\" -> \"9.0\" (for precision = 2)\n      version = version + new Array(delta + 1).join(\".0\");\n\n      // 3) \"9.0\" -> [\"000000000\"\", \"000000009\"]\n      return map(version.split(\".\"), function (chunk) {\n        return new Array(20 - chunk.length).join(\"0\") + chunk;\n      }).reverse();\n    });\n\n    // iterate in reverse order by reversed chunks array\n    while (--precision >= 0) {\n      // 4) compare: \"000000009\" > \"000000010\" = false (but \"9\" > \"10\" = true)\n      if (chunks[0][precision] > chunks[1][precision]) {\n        return 1;\n      }\n      else if (chunks[0][precision] === chunks[1][precision]) {\n        if (precision === 0) {\n          // all version chunks are same\n          return 0;\n        }\n      }\n      else {\n        return -1;\n      }\n    }\n  }\n\n  /**\n   * Check if browser is unsupported\n   *\n   * @example\n   *   bowser.isUnsupportedBrowser({\n   *     msie: \"10\",\n   *     firefox: \"23\",\n   *     chrome: \"29\",\n   *     safari: \"5.1\",\n   *     opera: \"16\",\n   *     phantom: \"534\"\n   *   });\n   *\n   * @param  {Object}  minVersions map of minimal version to browser\n   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map\n   * @param  {String}  [ua] user agent string\n   * @return {Boolean}\n   */\n  function isUnsupportedBrowser(minVersions, strictMode, ua) {\n    var _bowser = bowser;\n\n    // make strictMode param optional with ua param usage\n    if (typeof strictMode === 'string') {\n      ua = strictMode;\n      strictMode = void(0);\n    }\n\n    if (strictMode === void(0)) {\n      strictMode = false;\n    }\n    if (ua) {\n      _bowser = detect(ua);\n    }\n\n    var version = \"\" + _bowser.version;\n    for (var browser in minVersions) {\n      if (minVersions.hasOwnProperty(browser)) {\n        if (_bowser[browser]) {\n          if (typeof minVersions[browser] !== 'string') {\n            throw new Error('Browser version in the minVersion map should be a string: ' + browser + ': ' + String(minVersions));\n          }\n\n          // browser version and min supported version.\n          return compareVersions([version, minVersions[browser]]) < 0;\n        }\n      }\n    }\n\n    return strictMode; // not found\n  }\n\n  /**\n   * Check if browser is supported\n   *\n   * @param  {Object} minVersions map of minimal version to browser\n   * @param  {Boolean} [strictMode = false] flag to return false if browser wasn't found in map\n   * @param  {String}  [ua] user agent string\n   * @return {Boolean}\n   */\n  function check(minVersions, strictMode, ua) {\n    return !isUnsupportedBrowser(minVersions, strictMode, ua);\n  }\n\n  bowser.isUnsupportedBrowser = isUnsupportedBrowser;\n  bowser.compareVersions = compareVersions;\n  bowser.check = check;\n\n  /*\n   * Set our detect method to the main bowser object so we can\n   * reuse it to test other user agents.\n   * This is needed to implement future tests.\n   */\n  bowser._detect = detect;\n\n  /*\n   * Set our detect public method to the main bowser object\n   * This is needed to implement bowser in server side\n   */\n  bowser.detect = detect;\n  return bowser\n});\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/bowser/src/bowser.js?");

/***/ }),

/***/ "./node_modules/component-bind/index.js":
/*!**********************************************!*\
  !*** ./node_modules/component-bind/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Slice reference.\n */\n\nvar slice = [].slice;\n\n/**\n * Bind `obj` to `fn`.\n *\n * @param {Object} obj\n * @param {Function|String} fn or string\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function(obj, fn){\n  if ('string' == typeof fn) fn = obj[fn];\n  if ('function' != typeof fn) throw new Error('bind() requires a function');\n  var args = slice.call(arguments, 2);\n  return function(){\n    return fn.apply(obj, args.concat(slice.call(arguments)));\n  }\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/component-bind/index.js?");

/***/ }),

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (true) {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  var args = [].slice.call(arguments, 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/component-emitter/index.js?");

/***/ }),

/***/ "./node_modules/component-inherit/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-inherit/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nmodule.exports = function(a, b){\n  var fn = function(){};\n  fn.prototype = b.prototype;\n  a.prototype = new fn;\n  a.prototype.constructor = a;\n};\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/component-inherit/index.js?");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/debug.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/debug.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/debug/src/debug.js?");

/***/ }),

/***/ "./node_modules/debug/src/index.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer') {\n  module.exports = __webpack_require__(/*! ./browser.js */ \"./node_modules/debug/src/browser.js\");\n} else {\n  module.exports = __webpack_require__(/*! ./node.js */ \"./node_modules/debug/src/node.js\");\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/debug/src/index.js?");

/***/ }),

/***/ "./node_modules/debug/src/node.js":
/*!****************************************!*\
  !*** ./node_modules/debug/src/node.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar tty = __webpack_require__(/*! tty */ \"tty\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/debug/src/debug.js\");\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [ 6, 2, 3, 4, 5, 1 ];\n\ntry {\n  var supportsColor = __webpack_require__(/*! supports-color */ \"./node_modules/supports-color/index.js\");\n  if (supportsColor && supportsColor.level >= 2) {\n    exports.colors = [\n      20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68,\n      69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134,\n      135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171,\n      172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204,\n      205, 206, 207, 208, 209, 214, 215, 220, 221\n    ];\n  }\n} catch (err) {\n  // swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(process.stderr.fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var colorCode = '\\u001b[3' + (c < 8 ? c : '8;5;' + c);\n    var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = getDate() + name + ' ' + args[0];\n  }\n}\n\nfunction getDate() {\n  if (exports.inspectOpts.hideDate) {\n    return '';\n  } else {\n    return new Date().toISOString() + ' ';\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log() {\n  return process.stderr.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/debug/src/node.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nmodule.exports = __webpack_require__(/*! ./socket */ \"./node_modules/engine.io-client/lib/socket.js\");\n\n/**\n * Exports parser\n *\n * @api public\n *\n */\nmodule.exports.parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/index.js\");\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/engine.io-client/lib/index.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/engine.io-client/lib/socket.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar transports = __webpack_require__(/*! ./transports/index */ \"./node_modules/engine.io-client/lib/transports/index.js\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('engine.io-client:socket');\nvar index = __webpack_require__(/*! indexof */ \"./node_modules/indexof/index.js\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/index.js\");\nvar parseuri = __webpack_require__(/*! parseuri */ \"./node_modules/parseuri/index.js\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"./node_modules/parseqs/index.js\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Socket constructor.\n *\n * @param {String|Object} uri or options\n * @param {Object} options\n * @api public\n */\n\nfunction Socket (uri, opts) {\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\n  opts = opts || {};\n\n  if (uri && 'object' === typeof uri) {\n    opts = uri;\n    uri = null;\n  }\n\n  if (uri) {\n    uri = parseuri(uri);\n    opts.hostname = uri.host;\n    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';\n    opts.port = uri.port;\n    if (uri.query) opts.query = uri.query;\n  } else if (opts.host) {\n    opts.hostname = parseuri(opts.host).host;\n  }\n\n  this.secure = null != opts.secure ? opts.secure\n    : (global.location && 'https:' === location.protocol);\n\n  if (opts.hostname && !opts.port) {\n    // if no port is specified manually, use the protocol default\n    opts.port = this.secure ? '443' : '80';\n  }\n\n  this.agent = opts.agent || false;\n  this.hostname = opts.hostname ||\n    (global.location ? location.hostname : 'localhost');\n  this.port = opts.port || (global.location && location.port\n      ? location.port\n      : (this.secure ? 443 : 80));\n  this.query = opts.query || {};\n  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);\n  this.upgrade = false !== opts.upgrade;\n  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n  this.forceJSONP = !!opts.forceJSONP;\n  this.jsonp = false !== opts.jsonp;\n  this.forceBase64 = !!opts.forceBase64;\n  this.enablesXDR = !!opts.enablesXDR;\n  this.timestampParam = opts.timestampParam || 't';\n  this.timestampRequests = opts.timestampRequests;\n  this.transports = opts.transports || ['polling', 'websocket'];\n  this.transportOptions = opts.transportOptions || {};\n  this.readyState = '';\n  this.writeBuffer = [];\n  this.prevBufferLen = 0;\n  this.policyPort = opts.policyPort || 843;\n  this.rememberUpgrade = opts.rememberUpgrade || false;\n  this.binaryType = null;\n  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;\n  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;\n\n  if (true === this.perMessageDeflate) this.perMessageDeflate = {};\n  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {\n    this.perMessageDeflate.threshold = 1024;\n  }\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx || null;\n  this.key = opts.key || null;\n  this.passphrase = opts.passphrase || null;\n  this.cert = opts.cert || null;\n  this.ca = opts.ca || null;\n  this.ciphers = opts.ciphers || null;\n  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;\n  this.forceNode = !!opts.forceNode;\n\n  // other options for Node.js client\n  var freeGlobal = typeof global === 'object' && global;\n  if (freeGlobal.global === freeGlobal) {\n    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {\n      this.extraHeaders = opts.extraHeaders;\n    }\n\n    if (opts.localAddress) {\n      this.localAddress = opts.localAddress;\n    }\n  }\n\n  // set on handshake\n  this.id = null;\n  this.upgrades = null;\n  this.pingInterval = null;\n  this.pingTimeout = null;\n\n  // set on heartbeat\n  this.pingIntervalTimer = null;\n  this.pingTimeoutTimer = null;\n\n  this.open();\n}\n\nSocket.priorWebsocketSuccess = false;\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nSocket.protocol = parser.protocol; // this is an int\n\n/**\n * Expose deps for legacy compatibility\n * and standalone browser access.\n */\n\nSocket.Socket = Socket;\nSocket.Transport = __webpack_require__(/*! ./transport */ \"./node_modules/engine.io-client/lib/transport.js\");\nSocket.transports = __webpack_require__(/*! ./transports/index */ \"./node_modules/engine.io-client/lib/transports/index.js\");\nSocket.parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/index.js\");\n\n/**\n * Creates transport of the given type.\n *\n * @param {String} transport name\n * @return {Transport}\n * @api private\n */\n\nSocket.prototype.createTransport = function (name) {\n  debug('creating transport \"%s\"', name);\n  var query = clone(this.query);\n\n  // append engine.io protocol identifier\n  query.EIO = parser.protocol;\n\n  // transport name\n  query.transport = name;\n\n  // per-transport options\n  var options = this.transportOptions[name] || {};\n\n  // session id if we already have one\n  if (this.id) query.sid = this.id;\n\n  var transport = new transports[name]({\n    query: query,\n    socket: this,\n    agent: options.agent || this.agent,\n    hostname: options.hostname || this.hostname,\n    port: options.port || this.port,\n    secure: options.secure || this.secure,\n    path: options.path || this.path,\n    forceJSONP: options.forceJSONP || this.forceJSONP,\n    jsonp: options.jsonp || this.jsonp,\n    forceBase64: options.forceBase64 || this.forceBase64,\n    enablesXDR: options.enablesXDR || this.enablesXDR,\n    timestampRequests: options.timestampRequests || this.timestampRequests,\n    timestampParam: options.timestampParam || this.timestampParam,\n    policyPort: options.policyPort || this.policyPort,\n    pfx: options.pfx || this.pfx,\n    key: options.key || this.key,\n    passphrase: options.passphrase || this.passphrase,\n    cert: options.cert || this.cert,\n    ca: options.ca || this.ca,\n    ciphers: options.ciphers || this.ciphers,\n    rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,\n    perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,\n    extraHeaders: options.extraHeaders || this.extraHeaders,\n    forceNode: options.forceNode || this.forceNode,\n    localAddress: options.localAddress || this.localAddress,\n    requestTimeout: options.requestTimeout || this.requestTimeout,\n    protocols: options.protocols || void (0)\n  });\n\n  return transport;\n};\n\nfunction clone (obj) {\n  var o = {};\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      o[i] = obj[i];\n    }\n  }\n  return o;\n}\n\n/**\n * Initializes transport to use and starts probe.\n *\n * @api private\n */\nSocket.prototype.open = function () {\n  var transport;\n  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {\n    transport = 'websocket';\n  } else if (0 === this.transports.length) {\n    // Emit error on next tick so it can be listened to\n    var self = this;\n    setTimeout(function () {\n      self.emit('error', 'No transports available');\n    }, 0);\n    return;\n  } else {\n    transport = this.transports[0];\n  }\n  this.readyState = 'opening';\n\n  // Retry with the next transport if the transport is disabled (jsonp: false)\n  try {\n    transport = this.createTransport(transport);\n  } catch (e) {\n    this.transports.shift();\n    this.open();\n    return;\n  }\n\n  transport.open();\n  this.setTransport(transport);\n};\n\n/**\n * Sets the current transport. Disables the existing one (if any).\n *\n * @api private\n */\n\nSocket.prototype.setTransport = function (transport) {\n  debug('setting transport %s', transport.name);\n  var self = this;\n\n  if (this.transport) {\n    debug('clearing existing transport %s', this.transport.name);\n    this.transport.removeAllListeners();\n  }\n\n  // set up transport\n  this.transport = transport;\n\n  // set up transport listeners\n  transport\n  .on('drain', function () {\n    self.onDrain();\n  })\n  .on('packet', function (packet) {\n    self.onPacket(packet);\n  })\n  .on('error', function (e) {\n    self.onError(e);\n  })\n  .on('close', function () {\n    self.onClose('transport close');\n  });\n};\n\n/**\n * Probes a transport.\n *\n * @param {String} transport name\n * @api private\n */\n\nSocket.prototype.probe = function (name) {\n  debug('probing transport \"%s\"', name);\n  var transport = this.createTransport(name, { probe: 1 });\n  var failed = false;\n  var self = this;\n\n  Socket.priorWebsocketSuccess = false;\n\n  function onTransportOpen () {\n    if (self.onlyBinaryUpgrades) {\n      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;\n      failed = failed || upgradeLosesBinary;\n    }\n    if (failed) return;\n\n    debug('probe transport \"%s\" opened', name);\n    transport.send([{ type: 'ping', data: 'probe' }]);\n    transport.once('packet', function (msg) {\n      if (failed) return;\n      if ('pong' === msg.type && 'probe' === msg.data) {\n        debug('probe transport \"%s\" pong', name);\n        self.upgrading = true;\n        self.emit('upgrading', transport);\n        if (!transport) return;\n        Socket.priorWebsocketSuccess = 'websocket' === transport.name;\n\n        debug('pausing current transport \"%s\"', self.transport.name);\n        self.transport.pause(function () {\n          if (failed) return;\n          if ('closed' === self.readyState) return;\n          debug('changing transport and sending upgrade packet');\n\n          cleanup();\n\n          self.setTransport(transport);\n          transport.send([{ type: 'upgrade' }]);\n          self.emit('upgrade', transport);\n          transport = null;\n          self.upgrading = false;\n          self.flush();\n        });\n      } else {\n        debug('probe transport \"%s\" failed', name);\n        var err = new Error('probe error');\n        err.transport = transport.name;\n        self.emit('upgradeError', err);\n      }\n    });\n  }\n\n  function freezeTransport () {\n    if (failed) return;\n\n    // Any callback called by transport should be ignored since now\n    failed = true;\n\n    cleanup();\n\n    transport.close();\n    transport = null;\n  }\n\n  // Handle any error that happens while probing\n  function onerror (err) {\n    var error = new Error('probe error: ' + err);\n    error.transport = transport.name;\n\n    freezeTransport();\n\n    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\n    self.emit('upgradeError', error);\n  }\n\n  function onTransportClose () {\n    onerror('transport closed');\n  }\n\n  // When the socket is closed while we're probing\n  function onclose () {\n    onerror('socket closed');\n  }\n\n  // When the socket is upgraded while we're probing\n  function onupgrade (to) {\n    if (transport && to.name !== transport.name) {\n      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n      freezeTransport();\n    }\n  }\n\n  // Remove all listeners on the transport and on self\n  function cleanup () {\n    transport.removeListener('open', onTransportOpen);\n    transport.removeListener('error', onerror);\n    transport.removeListener('close', onTransportClose);\n    self.removeListener('close', onclose);\n    self.removeListener('upgrading', onupgrade);\n  }\n\n  transport.once('open', onTransportOpen);\n  transport.once('error', onerror);\n  transport.once('close', onTransportClose);\n\n  this.once('close', onclose);\n  this.once('upgrading', onupgrade);\n\n  transport.open();\n};\n\n/**\n * Called when connection is deemed open.\n *\n * @api public\n */\n\nSocket.prototype.onOpen = function () {\n  debug('socket open');\n  this.readyState = 'open';\n  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;\n  this.emit('open');\n  this.flush();\n\n  // we check for `readyState` in case an `open`\n  // listener already closed the socket\n  if ('open' === this.readyState && this.upgrade && this.transport.pause) {\n    debug('starting upgrade probes');\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n      this.probe(this.upgrades[i]);\n    }\n  }\n};\n\n/**\n * Handles a packet.\n *\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('opening' === this.readyState || 'open' === this.readyState ||\n      'closing' === this.readyState) {\n    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\n    this.emit('packet', packet);\n\n    // Socket is live - any packet counts\n    this.emit('heartbeat');\n\n    switch (packet.type) {\n      case 'open':\n        this.onHandshake(JSON.parse(packet.data));\n        break;\n\n      case 'pong':\n        this.setPing();\n        this.emit('pong');\n        break;\n\n      case 'error':\n        var err = new Error('server error');\n        err.code = packet.data;\n        this.onError(err);\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        break;\n    }\n  } else {\n    debug('packet received with socket readyState \"%s\"', this.readyState);\n  }\n};\n\n/**\n * Called upon handshake completion.\n *\n * @param {Object} handshake obj\n * @api private\n */\n\nSocket.prototype.onHandshake = function (data) {\n  this.emit('handshake', data);\n  this.id = data.sid;\n  this.transport.query.sid = data.sid;\n  this.upgrades = this.filterUpgrades(data.upgrades);\n  this.pingInterval = data.pingInterval;\n  this.pingTimeout = data.pingTimeout;\n  this.onOpen();\n  // In case open handler closes socket\n  if ('closed' === this.readyState) return;\n  this.setPing();\n\n  // Prolong liveness of socket on heartbeat\n  this.removeListener('heartbeat', this.onHeartbeat);\n  this.on('heartbeat', this.onHeartbeat);\n};\n\n/**\n * Resets ping timeout.\n *\n * @api private\n */\n\nSocket.prototype.onHeartbeat = function (timeout) {\n  clearTimeout(this.pingTimeoutTimer);\n  var self = this;\n  self.pingTimeoutTimer = setTimeout(function () {\n    if ('closed' === self.readyState) return;\n    self.onClose('ping timeout');\n  }, timeout || (self.pingInterval + self.pingTimeout));\n};\n\n/**\n * Pings server every `this.pingInterval` and expects response\n * within `this.pingTimeout` or closes connection.\n *\n * @api private\n */\n\nSocket.prototype.setPing = function () {\n  var self = this;\n  clearTimeout(self.pingIntervalTimer);\n  self.pingIntervalTimer = setTimeout(function () {\n    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n    self.ping();\n    self.onHeartbeat(self.pingTimeout);\n  }, self.pingInterval);\n};\n\n/**\n* Sends a ping packet.\n*\n* @api private\n*/\n\nSocket.prototype.ping = function () {\n  var self = this;\n  this.sendPacket('ping', function () {\n    self.emit('ping');\n  });\n};\n\n/**\n * Called on `drain` event\n *\n * @api private\n */\n\nSocket.prototype.onDrain = function () {\n  this.writeBuffer.splice(0, this.prevBufferLen);\n\n  // setting prevBufferLen = 0 is very important\n  // for example, when upgrading, upgrade packet is sent over,\n  // and a nonzero prevBufferLen could cause problems on `drain`\n  this.prevBufferLen = 0;\n\n  if (0 === this.writeBuffer.length) {\n    this.emit('drain');\n  } else {\n    this.flush();\n  }\n};\n\n/**\n * Flush write buffers.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' !== this.readyState && this.transport.writable &&\n    !this.upgrading && this.writeBuffer.length) {\n    debug('flushing %d packets in socket', this.writeBuffer.length);\n    this.transport.send(this.writeBuffer);\n    // keep track of current length of writeBuffer\n    // splice writeBuffer and callbackBuffer on `drain`\n    this.prevBufferLen = this.writeBuffer.length;\n    this.emit('flush');\n  }\n};\n\n/**\n * Sends a message.\n *\n * @param {String} message.\n * @param {Function} callback function.\n * @param {Object} options.\n * @return {Socket} for chaining.\n * @api public\n */\n\nSocket.prototype.write =\nSocket.prototype.send = function (msg, options, fn) {\n  this.sendPacket('message', msg, options, fn);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type.\n * @param {String} data.\n * @param {Object} options.\n * @param {Function} callback function.\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, options, fn) {\n  if ('function' === typeof data) {\n    fn = data;\n    data = undefined;\n  }\n\n  if ('function' === typeof options) {\n    fn = options;\n    options = null;\n  }\n\n  if ('closing' === this.readyState || 'closed' === this.readyState) {\n    return;\n  }\n\n  options = options || {};\n  options.compress = false !== options.compress;\n\n  var packet = {\n    type: type,\n    data: data,\n    options: options\n  };\n  this.emit('packetCreate', packet);\n  this.writeBuffer.push(packet);\n  if (fn) this.once('flush', fn);\n  this.flush();\n};\n\n/**\n * Closes the connection.\n *\n * @api private\n */\n\nSocket.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.readyState = 'closing';\n\n    var self = this;\n\n    if (this.writeBuffer.length) {\n      this.once('drain', function () {\n        if (this.upgrading) {\n          waitForUpgrade();\n        } else {\n          close();\n        }\n      });\n    } else if (this.upgrading) {\n      waitForUpgrade();\n    } else {\n      close();\n    }\n  }\n\n  function close () {\n    self.onClose('forced close');\n    debug('socket closing - telling transport to close');\n    self.transport.close();\n  }\n\n  function cleanupAndClose () {\n    self.removeListener('upgrade', cleanupAndClose);\n    self.removeListener('upgradeError', cleanupAndClose);\n    close();\n  }\n\n  function waitForUpgrade () {\n    // wait for upgrade to finish since we can't send packets while pausing a transport\n    self.once('upgrade', cleanupAndClose);\n    self.once('upgradeError', cleanupAndClose);\n  }\n\n  return this;\n};\n\n/**\n * Called upon transport error\n *\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('socket error %j', err);\n  Socket.priorWebsocketSuccess = false;\n  this.emit('error', err);\n  this.onClose('transport error', err);\n};\n\n/**\n * Called upon transport close.\n *\n * @api private\n */\n\nSocket.prototype.onClose = function (reason, desc) {\n  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {\n    debug('socket close with reason: \"%s\"', reason);\n    var self = this;\n\n    // clear timers\n    clearTimeout(this.pingIntervalTimer);\n    clearTimeout(this.pingTimeoutTimer);\n\n    // stop event from firing again for transport\n    this.transport.removeAllListeners('close');\n\n    // ensure transport won't stay open\n    this.transport.close();\n\n    // ignore further transport communication\n    this.transport.removeAllListeners();\n\n    // set ready state\n    this.readyState = 'closed';\n\n    // clear session id\n    this.id = null;\n\n    // emit close event\n    this.emit('close', reason, desc);\n\n    // clean buffers after, so users can still\n    // grab the buffers on `close` event\n    self.writeBuffer = [];\n    self.prevBufferLen = 0;\n  }\n};\n\n/**\n * Filters upgrades, returning only those matching client transports.\n *\n * @param {Array} server upgrades\n * @api private\n *\n */\n\nSocket.prototype.filterUpgrades = function (upgrades) {\n  var filteredUpgrades = [];\n  for (var i = 0, j = upgrades.length; i < j; i++) {\n    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);\n  }\n  return filteredUpgrades;\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/engine.io-client/lib/socket.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transport.js":
/*!********************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transport.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/index.js\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = Transport;\n\n/**\n * Transport abstract constructor.\n *\n * @param {Object} options.\n * @api private\n */\n\nfunction Transport (opts) {\n  this.path = opts.path;\n  this.hostname = opts.hostname;\n  this.port = opts.port;\n  this.secure = opts.secure;\n  this.query = opts.query;\n  this.timestampParam = opts.timestampParam;\n  this.timestampRequests = opts.timestampRequests;\n  this.readyState = '';\n  this.agent = opts.agent || false;\n  this.socket = opts.socket;\n  this.enablesXDR = opts.enablesXDR;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n  this.forceNode = opts.forceNode;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n  this.localAddress = opts.localAddress;\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Transport.prototype);\n\n/**\n * Emits an error.\n *\n * @param {String} str\n * @return {Transport} for chaining\n * @api public\n */\n\nTransport.prototype.onError = function (msg, desc) {\n  var err = new Error(msg);\n  err.type = 'TransportError';\n  err.description = desc;\n  this.emit('error', err);\n  return this;\n};\n\n/**\n * Opens the transport.\n *\n * @api public\n */\n\nTransport.prototype.open = function () {\n  if ('closed' === this.readyState || '' === this.readyState) {\n    this.readyState = 'opening';\n    this.doOpen();\n  }\n\n  return this;\n};\n\n/**\n * Closes the transport.\n *\n * @api private\n */\n\nTransport.prototype.close = function () {\n  if ('opening' === this.readyState || 'open' === this.readyState) {\n    this.doClose();\n    this.onClose();\n  }\n\n  return this;\n};\n\n/**\n * Sends multiple packets.\n *\n * @param {Array} packets\n * @api private\n */\n\nTransport.prototype.send = function (packets) {\n  if ('open' === this.readyState) {\n    this.write(packets);\n  } else {\n    throw new Error('Transport not open');\n  }\n};\n\n/**\n * Called upon open\n *\n * @api private\n */\n\nTransport.prototype.onOpen = function () {\n  this.readyState = 'open';\n  this.writable = true;\n  this.emit('open');\n};\n\n/**\n * Called with data.\n *\n * @param {String} data\n * @api private\n */\n\nTransport.prototype.onData = function (data) {\n  var packet = parser.decodePacket(data, this.socket.binaryType);\n  this.onPacket(packet);\n};\n\n/**\n * Called with a decoded packet.\n */\n\nTransport.prototype.onPacket = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon close.\n *\n * @api private\n */\n\nTransport.prototype.onClose = function () {\n  this.readyState = 'closed';\n  this.emit('close');\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/engine.io-client/lib/transport.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies\n */\n\nvar XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ \"./node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js\");\nvar XHR = __webpack_require__(/*! ./polling-xhr */ \"./node_modules/engine.io-client/lib/transports/polling-xhr.js\");\nvar JSONP = __webpack_require__(/*! ./polling-jsonp */ \"./node_modules/engine.io-client/lib/transports/polling-jsonp.js\");\nvar websocket = __webpack_require__(/*! ./websocket */ \"./node_modules/engine.io-client/lib/transports/websocket.js\");\n\n/**\n * Export transports.\n */\n\nexports.polling = polling;\nexports.websocket = websocket;\n\n/**\n * Polling transport polymorphic constructor.\n * Decides on xhr vs jsonp based on feature detection.\n *\n * @api private\n */\n\nfunction polling (opts) {\n  var xhr;\n  var xd = false;\n  var xs = false;\n  var jsonp = false !== opts.jsonp;\n\n  if (global.location) {\n    var isSSL = 'https:' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    xd = opts.hostname !== location.hostname || port !== opts.port;\n    xs = opts.secure !== isSSL;\n  }\n\n  opts.xdomain = xd;\n  opts.xscheme = xs;\n  xhr = new XMLHttpRequest(opts);\n\n  if ('open' in xhr && !opts.forceJSONP) {\n    return new XHR(opts);\n  } else {\n    if (!jsonp) throw new Error('JSONP disabled');\n    return new JSONP(opts);\n  }\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/engine.io-client/lib/transports/index.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-jsonp.js":
/*!***********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-jsonp.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * Module requirements.\n */\n\nvar Polling = __webpack_require__(/*! ./polling */ \"./node_modules/engine.io-client/lib/transports/polling.js\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"./node_modules/component-inherit/index.js\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = JSONPPolling;\n\n/**\n * Cached regular expressions.\n */\n\nvar rNewline = /\\n/g;\nvar rEscapedNewline = /\\\\n/g;\n\n/**\n * Global JSONP callbacks.\n */\n\nvar callbacks;\n\n/**\n * Noop.\n */\n\nfunction empty () { }\n\n/**\n * JSONP Polling constructor.\n *\n * @param {Object} opts.\n * @api public\n */\n\nfunction JSONPPolling (opts) {\n  Polling.call(this, opts);\n\n  this.query = this.query || {};\n\n  // define global callbacks array if not present\n  // we do this here (lazily) to avoid unneeded global pollution\n  if (!callbacks) {\n    // we need to consider multiple engines in the same page\n    if (!global.___eio) global.___eio = [];\n    callbacks = global.___eio;\n  }\n\n  // callback identifier\n  this.index = callbacks.length;\n\n  // add callback to jsonp global\n  var self = this;\n  callbacks.push(function (msg) {\n    self.onData(msg);\n  });\n\n  // append to query string\n  this.query.j = this.index;\n\n  // prevent spurious errors from being emitted when the window is unloaded\n  if (global.document && global.addEventListener) {\n    global.addEventListener('beforeunload', function () {\n      if (self.script) self.script.onerror = empty;\n    }, false);\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(JSONPPolling, Polling);\n\n/*\n * JSONP only supports binary as base64 encoded strings\n */\n\nJSONPPolling.prototype.supportsBinary = false;\n\n/**\n * Closes the socket.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doClose = function () {\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  if (this.form) {\n    this.form.parentNode.removeChild(this.form);\n    this.form = null;\n    this.iframe = null;\n  }\n\n  Polling.prototype.doClose.call(this);\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doPoll = function () {\n  var self = this;\n  var script = document.createElement('script');\n\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  script.async = true;\n  script.src = this.uri();\n  script.onerror = function (e) {\n    self.onError('jsonp poll error', e);\n  };\n\n  var insertAt = document.getElementsByTagName('script')[0];\n  if (insertAt) {\n    insertAt.parentNode.insertBefore(script, insertAt);\n  } else {\n    (document.head || document.body).appendChild(script);\n  }\n  this.script = script;\n\n  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);\n\n  if (isUAgecko) {\n    setTimeout(function () {\n      var iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      document.body.removeChild(iframe);\n    }, 100);\n  }\n};\n\n/**\n * Writes with a hidden iframe.\n *\n * @param {String} data to send\n * @param {Function} called upon flush.\n * @api private\n */\n\nJSONPPolling.prototype.doWrite = function (data, fn) {\n  var self = this;\n\n  if (!this.form) {\n    var form = document.createElement('form');\n    var area = document.createElement('textarea');\n    var id = this.iframeId = 'eio_iframe_' + this.index;\n    var iframe;\n\n    form.className = 'socketio';\n    form.style.position = 'absolute';\n    form.style.top = '-1000px';\n    form.style.left = '-1000px';\n    form.target = id;\n    form.method = 'POST';\n    form.setAttribute('accept-charset', 'utf-8');\n    area.name = 'd';\n    form.appendChild(area);\n    document.body.appendChild(form);\n\n    this.form = form;\n    this.area = area;\n  }\n\n  this.form.action = this.uri();\n\n  function complete () {\n    initIframe();\n    fn();\n  }\n\n  function initIframe () {\n    if (self.iframe) {\n      try {\n        self.form.removeChild(self.iframe);\n      } catch (e) {\n        self.onError('jsonp polling iframe removal error', e);\n      }\n    }\n\n    try {\n      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n      var html = '<iframe src=\"javascript:0\" name=\"' + self.iframeId + '\">';\n      iframe = document.createElement(html);\n    } catch (e) {\n      iframe = document.createElement('iframe');\n      iframe.name = self.iframeId;\n      iframe.src = 'javascript:0';\n    }\n\n    iframe.id = self.iframeId;\n\n    self.form.appendChild(iframe);\n    self.iframe = iframe;\n  }\n\n  initIframe();\n\n  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side\n  data = data.replace(rEscapedNewline, '\\\\\\n');\n  this.area.value = data.replace(rNewline, '\\\\n');\n\n  try {\n    this.form.submit();\n  } catch (e) {}\n\n  if (this.iframe.attachEvent) {\n    this.iframe.onreadystatechange = function () {\n      if (self.iframe.readyState === 'complete') {\n        complete();\n      }\n    };\n  } else {\n    this.iframe.onload = complete;\n  }\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/engine.io-client/lib/transports/polling-jsonp.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling-xhr.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling-xhr.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module requirements.\n */\n\nvar XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ \"./node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js\");\nvar Polling = __webpack_require__(/*! ./polling */ \"./node_modules/engine.io-client/lib/transports/polling.js\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"./node_modules/component-inherit/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('engine.io-client:polling-xhr');\n\n/**\n * Module exports.\n */\n\nmodule.exports = XHR;\nmodule.exports.Request = Request;\n\n/**\n * Empty function\n */\n\nfunction empty () {}\n\n/**\n * XHR Polling constructor.\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction XHR (opts) {\n  Polling.call(this, opts);\n  this.requestTimeout = opts.requestTimeout;\n  this.extraHeaders = opts.extraHeaders;\n\n  if (global.location) {\n    var isSSL = 'https:' === location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (!port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    this.xd = opts.hostname !== global.location.hostname ||\n      port !== opts.port;\n    this.xs = opts.secure !== isSSL;\n  }\n}\n\n/**\n * Inherits from Polling.\n */\n\ninherit(XHR, Polling);\n\n/**\n * XHR supports binary\n */\n\nXHR.prototype.supportsBinary = true;\n\n/**\n * Creates a request.\n *\n * @param {String} method\n * @api private\n */\n\nXHR.prototype.request = function (opts) {\n  opts = opts || {};\n  opts.uri = this.uri();\n  opts.xd = this.xd;\n  opts.xs = this.xs;\n  opts.agent = this.agent || false;\n  opts.supportsBinary = this.supportsBinary;\n  opts.enablesXDR = this.enablesXDR;\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  opts.requestTimeout = this.requestTimeout;\n\n  // other options for Node.js client\n  opts.extraHeaders = this.extraHeaders;\n\n  return new Request(opts);\n};\n\n/**\n * Sends data.\n *\n * @param {String} data to send.\n * @param {Function} called upon flush.\n * @api private\n */\n\nXHR.prototype.doWrite = function (data, fn) {\n  var isBinary = typeof data !== 'string' && data !== undefined;\n  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });\n  var self = this;\n  req.on('success', fn);\n  req.on('error', function (err) {\n    self.onError('xhr post error', err);\n  });\n  this.sendXhr = req;\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nXHR.prototype.doPoll = function () {\n  debug('xhr poll');\n  var req = this.request();\n  var self = this;\n  req.on('data', function (data) {\n    self.onData(data);\n  });\n  req.on('error', function (err) {\n    self.onError('xhr poll error', err);\n  });\n  this.pollXhr = req;\n};\n\n/**\n * Request constructor\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Request (opts) {\n  this.method = opts.method || 'GET';\n  this.uri = opts.uri;\n  this.xd = !!opts.xd;\n  this.xs = !!opts.xs;\n  this.async = false !== opts.async;\n  this.data = undefined !== opts.data ? opts.data : null;\n  this.agent = opts.agent;\n  this.isBinary = opts.isBinary;\n  this.supportsBinary = opts.supportsBinary;\n  this.enablesXDR = opts.enablesXDR;\n  this.requestTimeout = opts.requestTimeout;\n\n  // SSL options for Node.js client\n  this.pfx = opts.pfx;\n  this.key = opts.key;\n  this.passphrase = opts.passphrase;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.ciphers = opts.ciphers;\n  this.rejectUnauthorized = opts.rejectUnauthorized;\n\n  // other options for Node.js client\n  this.extraHeaders = opts.extraHeaders;\n\n  this.create();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Creates the XHR object and sends the request.\n *\n * @api private\n */\n\nRequest.prototype.create = function () {\n  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n\n  var xhr = this.xhr = new XMLHttpRequest(opts);\n  var self = this;\n\n  try {\n    debug('xhr open %s: %s', this.method, this.uri);\n    xhr.open(this.method, this.uri, this.async);\n    try {\n      if (this.extraHeaders) {\n        xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n        for (var i in this.extraHeaders) {\n          if (this.extraHeaders.hasOwnProperty(i)) {\n            xhr.setRequestHeader(i, this.extraHeaders[i]);\n          }\n        }\n      }\n    } catch (e) {}\n\n    if ('POST' === this.method) {\n      try {\n        if (this.isBinary) {\n          xhr.setRequestHeader('Content-type', 'application/octet-stream');\n        } else {\n          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n        }\n      } catch (e) {}\n    }\n\n    try {\n      xhr.setRequestHeader('Accept', '*/*');\n    } catch (e) {}\n\n    // ie6 check\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    if (this.requestTimeout) {\n      xhr.timeout = this.requestTimeout;\n    }\n\n    if (this.hasXDR()) {\n      xhr.onload = function () {\n        self.onLoad();\n      };\n      xhr.onerror = function () {\n        self.onError(xhr.responseText);\n      };\n    } else {\n      xhr.onreadystatechange = function () {\n        if (xhr.readyState === 2) {\n          try {\n            var contentType = xhr.getResponseHeader('Content-Type');\n            if (self.supportsBinary && contentType === 'application/octet-stream') {\n              xhr.responseType = 'arraybuffer';\n            }\n          } catch (e) {}\n        }\n        if (4 !== xhr.readyState) return;\n        if (200 === xhr.status || 1223 === xhr.status) {\n          self.onLoad();\n        } else {\n          // make sure the `error` event handler that's user-set\n          // does not throw in the same tick and gets caught here\n          setTimeout(function () {\n            self.onError(xhr.status);\n          }, 0);\n        }\n      };\n    }\n\n    debug('xhr data %s', this.data);\n    xhr.send(this.data);\n  } catch (e) {\n    // Need to defer since .create() is called directly fhrom the constructor\n    // and thus the 'error' event can only be only bound *after* this exception\n    // occurs.  Therefore, also, we cannot throw here at all.\n    setTimeout(function () {\n      self.onError(e);\n    }, 0);\n    return;\n  }\n\n  if (global.document) {\n    this.index = Request.requestsCount++;\n    Request.requests[this.index] = this;\n  }\n};\n\n/**\n * Called upon successful response.\n *\n * @api private\n */\n\nRequest.prototype.onSuccess = function () {\n  this.emit('success');\n  this.cleanup();\n};\n\n/**\n * Called if we have data.\n *\n * @api private\n */\n\nRequest.prototype.onData = function (data) {\n  this.emit('data', data);\n  this.onSuccess();\n};\n\n/**\n * Called upon error.\n *\n * @api private\n */\n\nRequest.prototype.onError = function (err) {\n  this.emit('error', err);\n  this.cleanup(true);\n};\n\n/**\n * Cleans up house.\n *\n * @api private\n */\n\nRequest.prototype.cleanup = function (fromError) {\n  if ('undefined' === typeof this.xhr || null === this.xhr) {\n    return;\n  }\n  // xmlhttprequest\n  if (this.hasXDR()) {\n    this.xhr.onload = this.xhr.onerror = empty;\n  } else {\n    this.xhr.onreadystatechange = empty;\n  }\n\n  if (fromError) {\n    try {\n      this.xhr.abort();\n    } catch (e) {}\n  }\n\n  if (global.document) {\n    delete Request.requests[this.index];\n  }\n\n  this.xhr = null;\n};\n\n/**\n * Called upon load.\n *\n * @api private\n */\n\nRequest.prototype.onLoad = function () {\n  var data;\n  try {\n    var contentType;\n    try {\n      contentType = this.xhr.getResponseHeader('Content-Type');\n    } catch (e) {}\n    if (contentType === 'application/octet-stream') {\n      data = this.xhr.response || this.xhr.responseText;\n    } else {\n      data = this.xhr.responseText;\n    }\n  } catch (e) {\n    this.onError(e);\n  }\n  if (null != data) {\n    this.onData(data);\n  }\n};\n\n/**\n * Check if it has XDomainRequest.\n *\n * @api private\n */\n\nRequest.prototype.hasXDR = function () {\n  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;\n};\n\n/**\n * Aborts the request.\n *\n * @api public\n */\n\nRequest.prototype.abort = function () {\n  this.cleanup();\n};\n\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\n\nRequest.requestsCount = 0;\nRequest.requests = {};\n\nif (global.document) {\n  if (global.attachEvent) {\n    global.attachEvent('onunload', unloadHandler);\n  } else if (global.addEventListener) {\n    global.addEventListener('beforeunload', unloadHandler, false);\n  }\n}\n\nfunction unloadHandler () {\n  for (var i in Request.requests) {\n    if (Request.requests.hasOwnProperty(i)) {\n      Request.requests[i].abort();\n    }\n  }\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/engine.io-client/lib/transports/polling-xhr.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/polling.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/polling.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar Transport = __webpack_require__(/*! ../transport */ \"./node_modules/engine.io-client/lib/transport.js\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"./node_modules/parseqs/index.js\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/index.js\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"./node_modules/component-inherit/index.js\");\nvar yeast = __webpack_require__(/*! yeast */ \"./node_modules/yeast/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('engine.io-client:polling');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Polling;\n\n/**\n * Is XHR2 supported?\n */\n\nvar hasXHR2 = (function () {\n  var XMLHttpRequest = __webpack_require__(/*! xmlhttprequest-ssl */ \"./node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js\");\n  var xhr = new XMLHttpRequest({ xdomain: false });\n  return null != xhr.responseType;\n})();\n\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\nfunction Polling (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (!hasXHR2 || forceBase64) {\n    this.supportsBinary = false;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(Polling, Transport);\n\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function () {\n  this.poll();\n};\n\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\nPolling.prototype.pause = function (onPause) {\n  var self = this;\n\n  this.readyState = 'pausing';\n\n  function pause () {\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function () {\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function () {\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\nPolling.prototype.poll = function () {\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\nPolling.prototype.onData = function (data) {\n  var self = this;\n  debug('polling got data %s', data);\n  var callback = function (packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' === self.readyState) {\n      self.onOpen();\n    }\n\n    // if its a close packet, we close the ongoing requests\n    if ('close' === packet.type) {\n      self.onClose();\n      return false;\n    }\n\n    // otherwise bypass onData and handle the message\n    self.onPacket(packet);\n  };\n\n  // decode payload\n  parser.decodePayload(data, this.socket.binaryType, callback);\n\n  // if an event did not trigger closing\n  if ('closed' !== this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' === this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\nPolling.prototype.doClose = function () {\n  var self = this;\n\n  function close () {\n    debug('writing close packet');\n    self.write([{ type: 'close' }]);\n  }\n\n  if ('open' === this.readyState) {\n    debug('transport open - closing');\n    close();\n  } else {\n    // in case we're trying to close while\n    // handshaking is in progress (GH-164)\n    debug('transport not open - deferring close');\n    this.once('open', close);\n  }\n};\n\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\nPolling.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n  var callbackfn = function () {\n    self.writable = true;\n    self.emit('drain');\n  };\n\n  parser.encodePayload(packets, this.supportsBinary, function (data) {\n    self.doWrite(data, callbackfn);\n  });\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nPolling.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = '';\n\n  // cache busting is forced\n  if (false !== this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  if (!this.supportsBinary && !query.sid) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // avoid port if default for schema\n  if (this.port && (('https' === schema && Number(this.port) !== 443) ||\n     ('http' === schema && Number(this.port) !== 80))) {\n    port = ':' + this.port;\n  }\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/engine.io-client/lib/transports/polling.js?");

/***/ }),

/***/ "./node_modules/engine.io-client/lib/transports/websocket.js":
/*!*******************************************************************!*\
  !*** ./node_modules/engine.io-client/lib/transports/websocket.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar Transport = __webpack_require__(/*! ../transport */ \"./node_modules/engine.io-client/lib/transport.js\");\nvar parser = __webpack_require__(/*! engine.io-parser */ \"./node_modules/engine.io-parser/lib/index.js\");\nvar parseqs = __webpack_require__(/*! parseqs */ \"./node_modules/parseqs/index.js\");\nvar inherit = __webpack_require__(/*! component-inherit */ \"./node_modules/component-inherit/index.js\");\nvar yeast = __webpack_require__(/*! yeast */ \"./node_modules/yeast/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('engine.io-client:websocket');\nvar BrowserWebSocket = global.WebSocket || global.MozWebSocket;\nvar NodeWebSocket;\nif (typeof window === 'undefined') {\n  try {\n    NodeWebSocket = __webpack_require__(/*! ws */ \"./node_modules/ws/index.js\");\n  } catch (e) { }\n}\n\n/**\n * Get either the `WebSocket` or `MozWebSocket` globals\n * in the browser or try to resolve WebSocket-compatible\n * interface exposed by `ws` for Node-like environment.\n */\n\nvar WebSocket = BrowserWebSocket;\nif (!WebSocket && typeof window === 'undefined') {\n  WebSocket = NodeWebSocket;\n}\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS (opts) {\n  var forceBase64 = (opts && opts.forceBase64);\n  if (forceBase64) {\n    this.supportsBinary = false;\n  }\n  this.perMessageDeflate = opts.perMessageDeflate;\n  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;\n  this.protocols = opts.protocols;\n  if (!this.usingBrowserWebSocket) {\n    WebSocket = NodeWebSocket;\n  }\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\ninherit(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/*\n * WebSockets support binary\n */\n\nWS.prototype.supportsBinary = true;\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function () {\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var uri = this.uri();\n  var protocols = this.protocols;\n  var opts = {\n    agent: this.agent,\n    perMessageDeflate: this.perMessageDeflate\n  };\n\n  // SSL options for Node.js client\n  opts.pfx = this.pfx;\n  opts.key = this.key;\n  opts.passphrase = this.passphrase;\n  opts.cert = this.cert;\n  opts.ca = this.ca;\n  opts.ciphers = this.ciphers;\n  opts.rejectUnauthorized = this.rejectUnauthorized;\n  if (this.extraHeaders) {\n    opts.headers = this.extraHeaders;\n  }\n  if (this.localAddress) {\n    opts.localAddress = this.localAddress;\n  }\n\n  try {\n    this.ws = this.usingBrowserWebSocket ? (protocols ? new WebSocket(uri, protocols) : new WebSocket(uri)) : new WebSocket(uri, protocols, opts);\n  } catch (err) {\n    return this.emit('error', err);\n  }\n\n  if (this.ws.binaryType === undefined) {\n    this.supportsBinary = false;\n  }\n\n  if (this.ws.supports && this.ws.supports.binary) {\n    this.supportsBinary = true;\n    this.ws.binaryType = 'nodebuffer';\n  } else {\n    this.ws.binaryType = 'arraybuffer';\n  }\n\n  this.addEventListeners();\n};\n\n/**\n * Adds event listeners to the socket\n *\n * @api private\n */\n\nWS.prototype.addEventListeners = function () {\n  var self = this;\n\n  this.ws.onopen = function () {\n    self.onOpen();\n  };\n  this.ws.onclose = function () {\n    self.onClose();\n  };\n  this.ws.onmessage = function (ev) {\n    self.onData(ev.data);\n  };\n  this.ws.onerror = function (e) {\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function (packets) {\n  var self = this;\n  this.writable = false;\n\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  var total = packets.length;\n  for (var i = 0, l = total; i < l; i++) {\n    (function (packet) {\n      parser.encodePacket(packet, self.supportsBinary, function (data) {\n        if (!self.usingBrowserWebSocket) {\n          // always create a new object (GH-437)\n          var opts = {};\n          if (packet.options) {\n            opts.compress = packet.options.compress;\n          }\n\n          if (self.perMessageDeflate) {\n            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;\n            if (len < self.perMessageDeflate.threshold) {\n              opts.compress = false;\n            }\n          }\n        }\n\n        // Sometimes the websocket has already been closed but the browser didn't\n        // have a chance of informing us about it yet, in that case send will\n        // throw an error\n        try {\n          if (self.usingBrowserWebSocket) {\n            // TypeError is thrown when passing the second argument on Safari\n            self.ws.send(data);\n          } else {\n            self.ws.send(data, opts);\n          }\n        } catch (e) {\n          debug('websocket closed before onclose event');\n        }\n\n        --total || done();\n      });\n    })(packets[i]);\n  }\n\n  function done () {\n    self.emit('flush');\n\n    // fake drain\n    // defer to next tick to allow Socket to clear writeBuffer\n    setTimeout(function () {\n      self.writable = true;\n      self.emit('drain');\n    }, 0);\n  }\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function () {\n  Transport.prototype.onClose.call(this);\n};\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function () {\n  if (typeof this.ws !== 'undefined') {\n    this.ws.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function () {\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||\n    ('ws' === schema && Number(this.port) !== 80))) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = yeast();\n  }\n\n  // communicate binary support capabilities\n  if (!this.supportsBinary) {\n    query.b64 = 1;\n  }\n\n  query = parseqs.encode(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  var ipv6 = this.hostname.indexOf(':') !== -1;\n  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function () {\n  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/engine.io-client/lib/transports/websocket.js?");

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"./node_modules/engine.io-parser/lib/utf8.js\");\nvar hasBinary = __webpack_require__(/*! has-binary2 */ \"./node_modules/has-binary2/index.js\");\nvar after = __webpack_require__(/*! after */ \"./node_modules/after/index.js\");\nvar keys = __webpack_require__(/*! ./keys */ \"./node_modules/engine.io-parser/lib/keys.js\");\n\n/**\n * Current protocol version.\n */\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  if (typeof utf8encode === 'function') {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  if (Buffer.isBuffer(packet.data)) {\n    return encodeBuffer(packet, supportsBinary, callback);\n  } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {\n    packet.data = arrayBufferToBuffer(packet.data);\n    return encodeBuffer(packet, supportsBinary, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n};\n\n/**\n * Encode Buffer data\n */\n\nfunction encodeBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var typeBuffer = new Buffer(1);\n  typeBuffer[0] = packets[packet.type];\n  return callback(Buffer.concat([typeBuffer, data]));\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback){\n  if (!Buffer.isBuffer(packet.data)) {\n    packet.data = arrayBufferToBuffer(packet.data);\n  }\n\n  var message = 'b' + packets[packet.type];\n  message += packet.data.toString('base64');\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Data also available as an ArrayBuffer if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n\n  var type;\n\n  // String data\n  if (typeof data === 'string') {\n\n    type = data.charAt(0);\n\n    if (type === 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n      if (data === false) {\n        return err;\n      }\n    }\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  // Binary data\n  if (binaryType === 'arraybuffer') {\n    // wrap Buffer/ArrayBuffer data into an Uint8Array\n    var intArray = new Uint8Array(data);\n    type = intArray[0];\n    return { type: packetslist[type], data: intArray.buffer.slice(1) };\n  }\n\n  if (data instanceof ArrayBuffer) {\n    data = arrayBufferToBuffer(data);\n  }\n  type = data[0];\n  return { type: packetslist[type], data: data.slice(1) };\n};\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data, { strict: false });\n  } catch (e) {\n    return false;\n  }\n  return data;\n}\n\n/**\n * Decodes a packet encoded in a base64 string.\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  var data = new Buffer(msg.substr(1), 'base64');\n  if (binaryType === 'arraybuffer') {\n    var abv = new Uint8Array(data.length);\n    for (var i = 0; i < abv.length; i++){\n      abv[i] = data[i];\n    }\n    data = abv.buffer;\n  }\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  if (supportsBinary && hasBinary(packets)) {\n    return exports.encodePayloadAsBinary(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, supportsBinary, false, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\nfunction setLengthHeader(message) {\n  return message.length + ':' + message;\n}\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  for (var i = 0; i < ary.length; i++) {\n    each(ary[i], function(error, msg) {\n      result[i] = msg;\n      next(error, result);\n    });\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data !== 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  if (data === '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = '', n, msg, packet;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (chr !== ':') {\n      length += chr;\n      continue;\n    }\n\n    if (length === '' || (length != (n = Number(length)))) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    msg = data.substr(i + 1, n);\n\n    if (length != msg.length) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    if (msg.length) {\n      packet = exports.decodePacket(msg, binaryType, false);\n\n      if (err.type === packet.type && err.data === packet.data) {\n        // parser error in individual packet - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      var more = callback(packet, i + n, l);\n      if (false === more) return;\n    }\n\n    // advance cursor\n    i += n;\n    length = '';\n  }\n\n  if (length !== '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n *\n * Converts a buffer to a utf8.js encoded string\n *\n * @api private\n */\n\nfunction bufferToString(buffer) {\n  var str = '';\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    str += String.fromCharCode(buffer[i]);\n  }\n  return str;\n}\n\n/**\n *\n * Converts a utf8.js encoded string to a buffer\n *\n * @api private\n */\n\nfunction stringToBuffer(string) {\n  var buf = new Buffer(string.length);\n  for (var i = 0, l = string.length; i < l; i++) {\n    buf.writeUInt8(string.charCodeAt(i), i);\n  }\n  return buf;\n}\n\n/**\n *\n * Converts an ArrayBuffer to a Buffer\n *\n * @api private\n */\n\nfunction arrayBufferToBuffer(data) {\n  // data is either an ArrayBuffer or ArrayBufferView.\n  var array = new Uint8Array(data.buffer || data);\n  var length = data.byteLength || data.length;\n  var offset = data.byteOffset || 0;\n  var buffer = new Buffer(length);\n\n  for (var i = 0; i < length; i++) {\n    buffer[i] = array[offset + i];\n  }\n  return buffer;\n}\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {Buffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsBinary = function (packets, callback) {\n  if (!packets.length) {\n    return callback(new Buffer(0));\n  }\n\n  map(packets, encodeOneBinaryPacket, function(err, results) {\n    return callback(Buffer.concat(results));\n  });\n};\n\nfunction encodeOneBinaryPacket(p, doneCallback) {\n\n  function onBinaryPacketEncode(packet) {\n\n    var encodingLength = '' + packet.length;\n    var sizeBuffer;\n\n    if (typeof packet === 'string') {\n      sizeBuffer = new Buffer(encodingLength.length + 2);\n      sizeBuffer[0] = 0; // is a string (not true binary = 0)\n      for (var i = 0; i < encodingLength.length; i++) {\n        sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n      }\n      sizeBuffer[sizeBuffer.length - 1] = 255;\n      return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));\n    }\n\n    sizeBuffer = new Buffer(encodingLength.length + 2);\n    sizeBuffer[0] = 1; // is binary (true binary = 1)\n    for (var i = 0; i < encodingLength.length; i++) {\n      sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);\n    }\n    sizeBuffer[sizeBuffer.length - 1] = 255;\n\n    doneCallback(null, Buffer.concat([sizeBuffer, packet]));\n  }\n\n  exports.encodePacket(p, true, true, onBinaryPacketEncode);\n\n}\n\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n\n * @param {Buffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n  var i;\n\n  while (bufferTail.length > 0) {\n    var strLen = '';\n    var isString = bufferTail[0] === 0;\n    for (i = 1; ; i++) {\n      if (bufferTail[i] === 255)  break;\n      // 310 = char length of Number.MAX_VALUE\n      if (strLen.length > 310) {\n        return callback(err, 0, 1);\n      }\n      strLen += '' + bufferTail[i];\n    }\n    bufferTail = bufferTail.slice(strLen.length + 1);\n\n    var msgLength = parseInt(strLen, 10);\n\n    var msg = bufferTail.slice(1, msgLength + 1);\n    if (isString) msg = bufferToString(msg);\n    buffers.push(msg);\n    bufferTail = bufferTail.slice(msgLength + 1);\n  }\n\n  var total = buffers.length;\n  for (i = 0; i < total; i++) {\n    var buffer = buffers[i];\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  }\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/engine.io-parser/lib/index.js?");

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/keys.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/keys.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * Gets the keys for an object.\n *\n * @return {Array} keys\n * @api private\n */\n\nmodule.exports = Object.keys || function keys (obj){\n  var arr = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/engine.io-parser/lib/keys.js?");

/***/ }),

/***/ "./node_modules/engine.io-parser/lib/utf8.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io-parser/lib/utf8.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/utf8js v2.1.2 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2decode(string) {\n\t\tvar output = [];\n\t\tvar counter = 0;\n\t\tvar length = string.length;\n\t\tvar value;\n\t\tvar extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2encode(array) {\n\t\tvar length = array.length;\n\t\tvar index = -1;\n\t\tvar value;\n\t\tvar output = '';\n\t\twhile (++index < length) {\n\t\t\tvalue = array[index];\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t}\n\t\treturn output;\n\t}\n\n\tfunction checkScalarValue(codePoint, strict) {\n\t\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\t\tif (strict) {\n\t\t\t\tthrow Error(\n\t\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t\t' is not a scalar value'\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction createByte(codePoint, shift) {\n\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t}\n\n\tfunction encodeCodePoint(codePoint, strict) {\n\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\treturn stringFromCharCode(codePoint);\n\t\t}\n\t\tvar symbol = '';\n\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t}\n\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\tif (!checkScalarValue(codePoint, strict)) {\n\t\t\t\tcodePoint = 0xFFFD;\n\t\t\t}\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\treturn symbol;\n\t}\n\n\tfunction utf8encode(string, opts) {\n\t\topts = opts || {};\n\t\tvar strict = false !== opts.strict;\n\n\t\tvar codePoints = ucs2decode(string);\n\t\tvar length = codePoints.length;\n\t\tvar index = -1;\n\t\tvar codePoint;\n\t\tvar byteString = '';\n\t\twhile (++index < length) {\n\t\t\tcodePoint = codePoints[index];\n\t\t\tbyteString += encodeCodePoint(codePoint, strict);\n\t\t}\n\t\treturn byteString;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction readContinuationByte() {\n\t\tif (byteIndex >= byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\treturn continuationByte & 0x3F;\n\t\t}\n\n\t\t// If we end up here, it’s not a continuation byte\n\t\tthrow Error('Invalid continuation byte');\n\t}\n\n\tfunction decodeSymbol(strict) {\n\t\tvar byte1;\n\t\tvar byte2;\n\t\tvar byte3;\n\t\tvar byte4;\n\t\tvar codePoint;\n\n\t\tif (byteIndex > byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tif (byteIndex == byteCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Read first byte\n\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\t// 1-byte sequence (no continuation bytes)\n\t\tif ((byte1 & 0x80) == 0) {\n\t\t\treturn byte1;\n\t\t}\n\n\t\t// 2-byte sequence\n\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\tif (codePoint >= 0x80) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\treturn checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 4-byte sequence\n\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tbyte4 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\treturn codePoint;\n\t\t\t}\n\t\t}\n\n\t\tthrow Error('Invalid UTF-8 detected');\n\t}\n\n\tvar byteArray;\n\tvar byteCount;\n\tvar byteIndex;\n\tfunction utf8decode(byteString, opts) {\n\t\topts = opts || {};\n\t\tvar strict = false !== opts.strict;\n\n\t\tbyteArray = ucs2decode(byteString);\n\t\tbyteCount = byteArray.length;\n\t\tbyteIndex = 0;\n\t\tvar codePoints = [];\n\t\tvar tmp;\n\t\twhile ((tmp = decodeSymbol(strict)) !== false) {\n\t\t\tcodePoints.push(tmp);\n\t\t}\n\t\treturn ucs2encode(codePoints);\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar utf8 = {\n\t\t'version': '2.1.2',\n\t\t'encode': utf8encode,\n\t\t'decode': utf8decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttrue\n\t) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\t\treturn utf8;\n\t\t}).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\telse { var key, hasOwnProperty, object; }\n\n}(this));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/engine.io-parser/lib/utf8.js?");

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/j2x.js":
/*!*************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/j2x.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n//parse Empty Node as self closing node\n\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attrNodeName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    cdataTagName: false,\n    cdataPositionChar: \"\\\\c\",\n    format: false,\n    indentBy: \"  \",\n    supressEmptyNode: false,\n    tagValueProcessor: a => a,\n    attrValueProcessor: a => a\n};\n\nfunction Parser(options) {\n    this.options = Object.assign({}, defaultOptions, options);\n    if (this.options.ignoreAttributes || this.options.attrNodeName) {\n        this.isAttribute = function(/*a*/) { return false;};\n    } else {\n        this.attrPrefixLen = this.options.attributeNamePrefix.length;\n        this.isAttribute = isAttribute;\n    }\n    if (this.options.cdataTagName) {\n        this.isCDATA = isCDATA;\n    } else {\n        this.isCDATA = function(/*a*/) { return false;};\n    }\n    this.replaceCDATAstr = replaceCDATAstr;\n    this.replaceCDATAarr = replaceCDATAarr;\n\n    if (this.options.format) {\n        this.indentate = indentate;\n        this.tagEndChar = \">\\n\";\n        this.newLine = \"\\n\";\n    } else {\n        this.indentate = function() { return \"\";};\n        this.tagEndChar = \">\";\n        this.newLine = \"\";\n    }\n\n    if (this.options.supressEmptyNode) {\n        this.buildTextNode = buildEmptyTextNode;\n        this.buildObjNode = buildEmptyObjNode;\n    } else {\n        this.buildTextNode = buildTextValNode;\n        this.buildObjNode = buildObjectNode;\n    }\n\n    this.buildTextValNode = buildTextValNode;\n    this.buildObjectNode = buildObjectNode;\n\n}\n\nParser.prototype.parse = function(jObj) {\n    return this.j2x(jObj, 0).val;\n};\n\nParser.prototype.j2x = function(jObj, level) {\n    let attrStr = \"\";\n    let val = \"\";\n    const keys = Object.keys(jObj);\n    const len = keys.length;\n    for (let i = 0; i < len; i++) {\n        const key = keys[i];\n        if (typeof jObj[key] === \"undefined\") {\n            // supress undefined node\n        }\n        else if (typeof jObj[key] !== \"object\") {//premitive type\n            const attr = this.isAttribute(key);\n            if (attr) {\n                attrStr += \" \" + attr + \"=\\\"\" +  this.options.attrValueProcessor(\"\" + jObj[key]) + \"\\\"\";\n            } else if (this.isCDATA(key)) {\n                if (jObj[this.options.textNodeName]) {\n                    val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n                } else {\n                    val += this.replaceCDATAstr(\"\", jObj[key]);\n                }\n            } else {//tag value\n                if (key === this.options.textNodeName) {\n                    if (jObj[this.options.cdataTagName]) {\n                        //value will added while processing cdata\n                    } else {\n                        val +=  this.options.tagValueProcessor(\"\" + jObj[key]);\n                    }\n                } else {\n                    val += this.buildTextNode(jObj[key], key, \"\", level);\n                }\n            }\n        } else if (Array.isArray(jObj[key])) {//repeated nodes\n            if (this.isCDATA(key)) {\n                if (jObj[this.options.textNodeName]) {\n                    val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n                } else {\n                    val += this.replaceCDATAarr(\"\", jObj[key]);\n                }\n            } else {//nested nodes\n                const arrLen = jObj[key].length;\n                for (let j = 0; j < arrLen; j++) {\n                    const item = jObj[key][j];\n                    if (typeof item === \"undefined\") {\n                        // supress undefined node\n                    }\n                    else if (typeof item === \"object\") {\n                        const result = this.j2x(item, level + 1);\n                        val += this.buildObjNode(result.val, key, result.attrStr, level);\n                    } else {\n                        val += this.buildTextNode(item, key, \"\", level);\n                    }\n                }\n            }\n        } else {\n            if (this.options.attrNodeName && key === this.options.attrNodeName) {\n                const Ks = Object.keys(jObj[key]);\n                const L = Ks.length;\n                for (let j = 0; j < L; j++) {\n                    attrStr += \" \" + Ks[j] + \"=\\\"\" + this.options.tagValueProcessor(\"\" + jObj[key][Ks[j]]) + \"\\\"\";\n                }\n            } else {\n                const result = this.j2x(jObj[key], level + 1);\n                val += this.buildObjNode(result.val, key, result.attrStr, level);\n            }\n        }\n    }\n    return {attrStr: attrStr, val: val};\n};\n\nfunction replaceCDATAstr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata + \"]]>\";\n    } else {\n        return str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata + \"]]>\");\n    }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata.join(\"]]><![CDATA[\") + \"]]>\";\n    } else {\n        for (const v in cdata) {\n            str = str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata[v] + \"]]>\");\n        }\n        return str;\n    }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n    return this.indentate(level)\n           + \"<\" + key + attrStr\n           + this.tagEndChar\n           + val\n           //+ this.newLine\n           + this.indentate(level)\n           + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildObjectNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level)\n               + \"<\" + key + attrStr\n               + \"/\"\n               + this.tagEndChar;\n        //+ this.newLine\n    }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n    return this.indentate(level) + \"<\" + key + attrStr + \">\" + this.options.tagValueProcessor(\"\" + val) + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildTextValNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level) + \"<\" + key + attrStr + \"/\" + this.tagEndChar;\n    }\n}\n\nfunction indentate(level) {\n    return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name/*, options*/) {\n    if (name.startsWith(this.options.attributeNamePrefix)) {\n        return name.substr(this.attrPrefixLen);\n    } else {\n        return false;\n    }\n}\n\nfunction isCDATA(name) {\n    return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = Parser;\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/fast-xml-parser/src/j2x.js?");

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/n2j.js":
/*!*************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/n2j.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/fast-xml-parser/src/util.js\");\n\nconst convertToJson =function(node, options) {\n    const jObj = {};\n\n    if ((!node.child  ||  util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n        return util.isExist(node.val) ? node.val : \"\";\n    } else {\n        if (util.isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj[options.textNodeName] = node.val;\n            }\n        }\n    }\n\n    util.merge(jObj, node.attrsMap);\n\n    const keys = Object.keys(node.child);\n    for (let index = 0; index < keys.length; index++) {\n        var tagname = keys[index];\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj[tagname] = [];\n            for (var tag in node.child[tagname]) {\n                jObj[tagname].push(convertToJson(node.child[tagname][tag], options));\n            }\n        } else {\n            jObj[tagname] = convertToJson(node.child[tagname][0], options);\n        }\n    }\n    \n    //add value\n    return jObj;\n};\n\nexports.convertToJson = convertToJson;\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/fast-xml-parser/src/n2j.js?");

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/n2j_str.js":
/*!*****************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/n2j_str.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/fast-xml-parser/src/util.js\");\nconst xmlToNodeobj = __webpack_require__(/*! ./x2j */ \"./node_modules/fast-xml-parser/src/x2j.js\");\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n    options = Object.assign({}, xmlToNodeobj.defaultOptions, options);\n\n    options.indentBy = options.indentBy || \"\";\n    return _cToJsonStr(node, options,0);\n}\n\nconst _cToJsonStr = function(node, options,level) {\n    let jObj = \"{\";\n\n    //traver through all the children\n    const keys = Object.keys(node.child);\n    \n    for (let index = 0; index < keys.length; index++) {\n        var tagname = keys[index];\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj  += \"\\\"\" + tagname + \"\\\" : [ \";\n            for (var tag in node.child[tagname]) {\n                jObj += _cToJsonStr(node.child[tagname][tag], options) + \" , \";\n            }\n            jObj = jObj.substr(0,jObj.length-1) + \" ] \"; //remove extra comma in last\n        } else {\n            jObj += \"\\\"\" +tagname + \"\\\" : \" + _cToJsonStr(node.child[tagname][0], options) + \" ,\";\n        }\n    }\n    util.merge(jObj, node.attrsMap);\n    //add attrsMap as new children\n    if (util.isEmptyObject(jObj)) {\n        return util.isExist(node.val) ? node.val : \"\";\n    } else {\n        if (util.isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj += \"\\\"\" + options.textNodeName +\"\\\" : \" + stringval(node.val);\n            }\n        }\n    }\n    //add value\n    if(jObj[jObj.length-1] === \",\"){\n        jObj = jObj.substr(0,jObj.length-2);\n    }\n    return jObj + \"}\";\n};\n\nfunction stringval(v){\n    if(v === true || v === false || !isNaN(v)){\n        return v;\n    }else{\n        return \"\\\"\" + v + \"\\\"\";\n    }\n}\n\nfunction indentate(options, level) {\n    return options.indentBy.repeat(level);\n}\n\nexports.convertToJsonString = convertToJsonString;\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/fast-xml-parser/src/n2j_str.js?");

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/nimndata.js":
/*!******************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/nimndata.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst char = function(a) {\n    return String.fromCharCode(a);\n};\n\nconst chars = {\n    nilChar: char(254),\n    missingChar: char(200),\n    nilPremitive: char(176),\n    missingPremitive: char(201),\n    emptyChar: char(177),\n    emptyValue: char(178),\n    boundryChar: char(186),\n    arrayEnd: char(197),\n    objStart: char(198),\n    arrStart: char(199)\n};\n\nconst charsArr = [\n    chars.nilChar,\n    chars.nilPremitive,\n    chars.missingChar,\n    chars.missingPremitive,\n    chars.boundryChar,\n    chars.emptyChar,\n    chars.arrayEnd,\n    chars.objStart,\n    chars.arrStart\n];\n\nconst _e = function(node, e_schema, options) {\n    if (typeof e_schema === \"string\") {//premitive\n        if (node && node[0] && node[0].val !== undefined) {\n            return getValue(node[0].val, e_schema);\n        } else {\n            return getValue(node, e_schema);\n        }\n    } else {\n        const hasValidData = hasData(node);\n        if (hasValidData === true) {\n            let str = \"\";\n            if (Array.isArray(e_schema)) {\n                //attributes can't be repeated. hence check in children tags only\n                str += chars.arrStart;\n                const itemSchema = e_schema[0];\n                //var itemSchemaType = itemSchema;\n                const arr_len = node.length;\n\n                if (typeof itemSchema === \"string\") {\n                    for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n                        const r = getValue(node[arr_i].val, itemSchema);\n                        str = processValue(str, r);\n                    }\n                } else {\n                    for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n                        const r = _e(node[arr_i], itemSchema, options);\n                        str = processValue(str, r);\n                    }\n                }\n                str += chars.arrayEnd;//indicates that next item is not array item\n            } else {//object\n                str += chars.objStart;\n                const keys = Object.keys(e_schema);\n                if (Array.isArray(node)) {\n                    node = node[0];\n                }\n                for (let i in keys) {\n                    const key = keys[i];\n                    //a property defined in schema can be present either in attrsMap or children tags\n                    //options.textNodeName will not present in both maps, take it's value from val\n                    //options.attrNodeName will be present in attrsMap\n                    let r;\n                    if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n                        r = _e(node.attrsMap[key], e_schema[key], options);\n                    } else if (key === options.textNodeName) {\n                        r = _e(node.val, e_schema[key], options);\n                    } else {\n                        r = _e(node.child[key], e_schema[key], options);\n                    }\n                    str = processValue(str, r);\n                }\n            }\n            return str;\n        } else {\n            return hasValidData;\n        }\n    }\n};\n\nconst getValue = function(a/*, type*/) {\n    switch (a) {\n        case undefined:\n            return chars.missingPremitive;\n        case null:\n            return chars.nilPremitive;\n        case \"\":\n            return chars.emptyValue;\n        default:\n            return a;\n    }\n};\n\nconst processValue = function(str, r) {\n    if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n        str += chars.boundryChar;\n    }\n    return str + r;\n};\n\nconst isAppChar = function(ch) {\n    return charsArr.indexOf(ch) !== -1;\n};\n\nfunction hasData(jObj) {\n    if (jObj === undefined) {\n        return chars.missingChar;\n    } else if (jObj === null) {\n        return chars.nilChar;\n    } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {\n        return chars.emptyChar;\n    } else {\n        return true;\n    }\n}\n\nconst defaultOptions = __webpack_require__(/*! ./x2j */ \"./node_modules/fast-xml-parser/src/x2j.js\").defaultOptions;\nconst convert2nimn = function(node, e_schema, options) {\n    options = Object.assign({}, defaultOptions, options);\n    return _e(node, e_schema, options);\n};\n\nexports.convert2nimn = convert2nimn;\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/fast-xml-parser/src/nimndata.js?");

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/parser.js":
/*!****************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/parser.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst nodeToJson = __webpack_require__(/*! ./n2j */ \"./node_modules/fast-xml-parser/src/n2j.js\");\nconst xmlToNodeobj = __webpack_require__(/*! ./x2j */ \"./node_modules/fast-xml-parser/src/x2j.js\");\n\nexports.parse = function(xmlData, options) {\n    options = Object.assign({}, xmlToNodeobj.defaultOptions, options);\n    return nodeToJson.convertToJson(xmlToNodeobj.getTraversalObj(xmlData, options), options);\n};\nexports.convertTonimn = __webpack_require__(/*! ../src/nimndata */ \"./node_modules/fast-xml-parser/src/nimndata.js\").convert2nimn;\nexports.getTraversalObj = xmlToNodeobj.getTraversalObj;\nexports.convertToJson = nodeToJson.convertToJson;\nexports.convertToJsonString = __webpack_require__(/*! ./n2j_str */ \"./node_modules/fast-xml-parser/src/n2j_str.js\").convertToJsonString;\nexports.validate = __webpack_require__(/*! ./validator */ \"./node_modules/fast-xml-parser/src/validator.js\").validate;\nexports.j2xParser = __webpack_require__(/*! ./j2x */ \"./node_modules/fast-xml-parser/src/j2x.js\");\nexports.parseToNimn = function (xmlData,schema,options){\n    return exports.convertTonimn(exports.getTraversalObj(xmlData,options), schema, options);\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/fast-xml-parser/src/parser.js?");

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/util.js":
/*!**************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/util.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst getAllMatches = function(string, regex) {\n    const matches = [];\n    let match = regex.exec(string);\n    while (match) {\n        const allmatches = [];\n        const len = match.length;\n        for (let index = 0; index < len; index++) {\n            allmatches.push(match[index]);\n        }\n        matches.push(allmatches);\n        match = regex.exec(string);\n    }\n    return matches;\n};\n\nconst doesMatch = function(string, regex) {\n    const match = regex.exec(string);\n    return !(match === null || typeof match === \"undefined\");\n};\n\nconst doesNotMatch = function(string, regex) {\n    return !doesMatch(string, regex);\n};\n\nexports.isExist = function(v) {\n    return typeof v !== \"undefined\";\n};\n\nexports.isEmptyObject = function(obj) {\n    return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a) {\n    if (a) {\n        const keys = Object.keys(a); // will return an array of own properties\n        const len = keys.length; //don't make it inline\n        for (let i = 0; i < len; i++) {\n            target[keys[i]] = a[keys[i]];\n        }\n    }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n    if (exports.isExist(v)) {\n        return v;\n    } else {\n        return \"\";\n    }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.doesMatch = doesMatch;\nexports.doesNotMatch = doesNotMatch;\nexports.getAllMatches = getAllMatches;\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/fast-xml-parser/src/util.js?");

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/validator.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/validator.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/fast-xml-parser/src/util.js\");\n\nconst defaultOptions = {\n    allowBooleanAttributes: false         //A tag can have attributes without any value\n};\n\nconst buildOptions = function(options) {\n    if (!options) {\n        options = {};\n    }\n    const props = [\"allowBooleanAttributes\"];\n    for (let i = 0; i < props.length; i++) {\n        if (options[props[i]] === undefined) {\n            options[props[i]] = defaultOptions[props[i]];\n        }\n    }\n    return options;\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function(xmlData, options) {\n    options = buildOptions(options);\n\n    //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n    //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n    //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n\n    const tags = [];\n    let tagFound = false;\n    for (let i = 0; i < xmlData.length; i++) {\n\n        if (xmlData[i] === \"<\") {//starting of tag\n            //read until you reach to '>' avoiding any '>' in attribute value\n\n            i++;\n            if (xmlData[i] === \"?\") {\n                i = readPI(xmlData, ++i);\n                if (i.err) {\n                    return i;\n                }\n            } else if (xmlData[i] === \"!\") {\n                i = readCommentAndCDATA(xmlData, i);\n                continue;\n            } else {\n                let closingTag = false;\n                if (xmlData[i] === \"/\") {//closing tag\n                    closingTag = true;\n                    i++;\n                }\n                //read tagname\n                let tagName = \"\";\n                for (; i < xmlData.length &&\n                       xmlData[i] !== \">\" &&\n                       xmlData[i] !== \" \" &&\n                       xmlData[i] !== \"\\t\"; i++) {\n\n                    tagName += xmlData[i];\n                }\n                tagName = tagName.trim();\n                //console.log(tagName);\n\n                if (tagName[tagName.length - 1] === \"/\") {//self closing tag without attributes\n                    tagName = tagName.substring(0, tagName.length - 1);\n                    continue;\n                }\n                if (!validateTagName(tagName)) {\n                    return {err: {code: \"InvalidTag\", msg: \"Tag \" + tagName + \" is an invalid name.\"}};\n                }\n\n                const result = readAttributeStr(xmlData, i);\n                if (result === false) {\n                    return {err: {code: \"InvalidAttr\", msg: \"Attributes for \" + tagName + \" have open quote\"}};\n                }\n                let attrStr = result.value;\n                i = result.index;\n\n                if (attrStr[attrStr.length - 1] === \"/\") {//self closing tag\n                    attrStr = attrStr.substring(0, attrStr.length - 1);\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid === true) {\n                        tagFound = true;\n                        continue;\n                    } else {\n                        return isValid;\n                    }\n                } else if (closingTag) {\n                    if (attrStr.trim().length > 0) {\n                        return {err: {code: \"InvalidTag\", msg: \"closing tag \" + tagName + \" can't have attributes or invalid starting.\"}};\n                    } else {\n                        const otg = tags.pop();\n                        if (tagName !== otg) {\n                            return {err: {code: \"InvalidTag\", msg: \"closing tag \" + otg + \" is expected inplace of \" + tagName + \".\"}};\n                        }\n                    }\n                } else {\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid !== true) {\n                        return isValid;\n                    }\n                    tags.push(tagName);\n                    tagFound = true;\n                }\n\n                //skip tag text value\n                //It may include comments and CDATA value\n                for (i++; i < xmlData.length; i++) {\n                    if (xmlData[i] === \"<\") {\n                        if (xmlData[i + 1] === \"!\") {//comment or CADATA\n                            i++;\n                            i = readCommentAndCDATA(xmlData, i);\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                }//end of reading tag text value\n                if (xmlData[i] === \"<\") {\n                    i--;\n                }\n            }\n        } else {\n            if (xmlData[i] === \" \" || xmlData[i] === \"\\t\" || xmlData[i] === \"\\n\" || xmlData[i] === \"\\r\") {\n                continue;\n            }\n            return {err: {code: \"InvalidChar\", msg: \"char \" + xmlData[i] + \" is not expected .\"}};\n        }\n    }\n\n    if (!tagFound) {\n        return {err: {code: \"InvalidXml\", msg: \"Start tag expected.\"}};\n    } else if (tags.length > 0) {\n        return {err: {code: \"InvalidXml\", msg: \"Invalid \" + JSON.stringify(tags, null, 4).replace(/\\r?\\n/g, \"\") + \" found.\"}};\n    }\n\n    return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n    var start = i;\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] == \"?\" || xmlData[i] == \" \") {//tagname\n            var tagname = xmlData.substr(start, i - start);\n            if (i > 5 && tagname === \"xml\") {\n                return {err: {code: \"InvalidXml\", msg: \"XML declaration allowed only at the start of the document.\"}};\n            } else if (xmlData[i] == \"?\" && xmlData[i + 1] == \">\") {\n                //check if valid attribut string\n                i++;\n                break;\n            } else {\n                continue;\n            }\n        }\n    }\n    return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n    if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {//comment\n        for (i += 3; i < xmlData.length; i++) {\n            if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    } else if (xmlData.length > i + 8 &&\n               xmlData[i + 1] === \"D\" &&\n               xmlData[i + 2] === \"O\" &&\n               xmlData[i + 3] === \"C\" &&\n               xmlData[i + 4] === \"T\" &&\n               xmlData[i + 5] === \"Y\" &&\n               xmlData[i + 6] === \"P\" &&\n               xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"<\") {angleBracketsCount++;}\n            else if (xmlData[i] === \">\") {\n                angleBracketsCount--;\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            }\n        }\n    } else if (xmlData.length > i + 9 &&\n               xmlData[i + 1] === \"[\" &&\n               xmlData[i + 2] === \"C\" &&\n               xmlData[i + 3] === \"D\" &&\n               xmlData[i + 4] === \"A\" &&\n               xmlData[i + 5] === \"T\" &&\n               xmlData[i + 6] === \"A\" &&\n               xmlData[i + 7] === \"[\") {\n\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    }\n\n    return i;\n}\n\nvar doubleQuote = \"\\\"\";\nvar singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n    let attrStr = \"\";\n    let startChar = \"\";\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n            if (startChar === \"\") {\n                startChar = xmlData[i];\n            } else if (startChar !== xmlData[i]) {\n                //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n                continue;\n            } else {\n                startChar = \"\";\n            }\n        } else if (xmlData[i] === \">\") {\n            if (startChar === \"\") {\n                break;\n            }\n        }\n        attrStr += xmlData[i];\n    }\n    if (startChar !== \"\") {\n        return false;\n    }\n\n    return {value: attrStr, index: i};\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\", \"g\");\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n    //console.log(\"start:\"+attrStr+\":end\");\n\n    //if(attrStr.trim().length === 0) return true; //empty string\n\n    const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n    const attrNames = [];\n\n    for (let i = 0; i < matches.length; i++) {\n        //console.log(matches[i]);\n\n        if (matches[i][1].length === 0) {//nospace before attribute name: a=\"sd\"b=\"saf\"\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + matches[i][2] + \" has no space in starting.\"}};\n        } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {//independent attribute: ab\n            return {err: {code: \"InvalidAttr\", msg: \"boolean attribute \" + matches[i][2] + \" is not allowed.\"}};\n        }\n        /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n        const attrName = matches[i][2];\n        if (!validateAttrName(attrName)) {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is an invalid name.\"}};\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {//check for duplicate attribute.\n            attrNames[attrName] = 1;\n        } else {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is repeated.\"}};\n        }\n    }\n\n    return true;\n\n}\n\nconst validAttrRegxp = /^[_a-zA-Z][\\w\\-.:]*$/;\n\nfunction validateAttrName(attrName) {\n    return util.doesMatch(attrName, validAttrRegxp);\n}\n\n//const startsWithXML = new RegExp(\"^[Xx][Mm][Ll]\");\nconst startsWith = /^([a-zA-Z]|_)[\\w.\\-_:]*/;\n\nfunction validateTagName(tagname) {\n    /*if(util.doesMatch(tagname,startsWithXML)) return false;\n    else*/\n    return !util.doesNotMatch(tagname, startsWith);\n}\n\n\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/fast-xml-parser/src/validator.js?");

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/x2j.js":
/*!*************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/x2j.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ./util */ \"./node_modules/fast-xml-parser/src/util.js\");\nconst xmlNode = __webpack_require__(/*! ./xmlNode */ \"./node_modules/fast-xml-parser/src/xmlNode.js\");\nconst TagType = {\"OPENING\": 1, \"CLOSING\": 2, \"SELF\": 3, \"CDATA\": 4};\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//treat cdata as a tag\n\nconst defaultOptions = {\n    attributeNamePrefix:    \"@_\",\n    attrNodeName:           false,\n    textNodeName:           \"#text\",\n    ignoreAttributes:       true,\n    ignoreNameSpace:        false,\n    allowBooleanAttributes: false,         //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseNodeValue:         true,\n    parseAttributeValue:    false,\n    arrayMode:              false,\n    trimValues:             true,                                //Trim string values of tag and attributes\n    cdataTagName:           false,\n    cdataPositionChar:      \"\\\\c\",\n    tagValueProcessor: a => a,\n    attrValueProcessor: a => a\n    //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst getTraversalObj = function(xmlData, options) {\n    //options = buildOptions(options);\n    options = Object.assign({}, defaultOptions, options);\n    //xmlData = xmlData.replace(/\\r?\\n/g, \" \");//make it single line\n    xmlData = xmlData.replace(/<!--[\\s\\S]*?-->/g, \"\");//Remove  comments\n\n    const xmlObj = new xmlNode(\"!xml\");\n    let currentNode = xmlObj;\n\n    const tagsRegx = /<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|(([\\w:\\-._]*:)?([\\w:\\-._]+))([^>]*)>|((\\/)(([\\w:\\-._]*:)?([\\w:\\-._]+))>))([^<]*)/g;\n    let tag = tagsRegx.exec(xmlData);\n    let nextTag = tagsRegx.exec(xmlData);\n    while (tag) {\n        const tagType = checkForTagType(tag);\n\n        if (tagType === TagType.CLOSING) {\n            //add parsed data to parent node\n            if (currentNode.parent && tag[14]) {\n                currentNode.parent.val = util.getValue(currentNode.parent.val) + \"\" + processTagValue(tag[14], options);\n            }\n\n            currentNode = currentNode.parent;\n        } else if (tagType === TagType.CDATA) {\n            if (options.cdataTagName) {\n                //add cdata node\n                const childNode = new xmlNode(options.cdataTagName, currentNode, tag[3]);\n                childNode.attrsMap = buildAttributesMap(tag[8], options);\n                currentNode.addChild(childNode);\n                //for backtracking\n                currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n                //add rest value to parent node\n                if (tag[14]) {\n                    currentNode.val += processTagValue(tag[14], options);\n                }\n            } else {\n                currentNode.val = (currentNode.val || \"\") + (tag[3] || \"\") + processTagValue(tag[14], options);\n            }\n        } else if (tagType === TagType.SELF) {\n            const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, \"\");\n            if (tag[8] && tag[8].length > 1) {\n                tag[8] = tag[8].substr(0, tag[8].length - 1);\n            }\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n        } else {//TagType.OPENING\n            const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, processTagValue(tag[14], options));\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n            currentNode = childNode;\n        }\n\n        tag = nextTag;\n        nextTag = tagsRegx.exec(xmlData);\n    }\n\n    return xmlObj;\n};\n\nfunction processTagValue(val, options) {\n    if (val) {\n        if (options.trimValues) {\n            val = val.trim();\n        }\n        val = options.tagValueProcessor(val);\n        val = parseValue(val, options.parseNodeValue);\n    }\n\n    return val;\n}\n\nfunction checkForTagType(match) {\n    if (match[4] === \"]]>\") {\n        return TagType.CDATA;\n    } else if (match[10] === \"/\") {\n        return TagType.CLOSING;\n    } else if (typeof match[8] !== \"undefined\" && match[8].substr(match[8].length - 1) === \"/\") {\n        return TagType.SELF;\n    } else {\n        return TagType.OPENING;\n    }\n}\n\nfunction resolveNameSpace(tagname, options) {\n    if (options.ignoreNameSpace) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n            return \"\";\n        }\n        if (tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n\nfunction parseValue(val, shouldParse) {\n    if (shouldParse && typeof val === \"string\") {\n        if (val.trim() === \"\" || isNaN(val)) {\n            val = val === \"true\" ? true : val === \"false\" ? false : val;\n        } else {\n            if (val.indexOf(\".\") !== -1) {\n                val = Number.parseFloat(val);\n            } else {\n                val = Number.parseInt(val, 10);\n            }\n        }\n        return val;\n    } else {\n        if (util.isExist(val)) {\n            return val;\n        } else {\n            return \"\";\n        }\n    }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])(.*?)\\\\3)?\", \"g\");\n\nfunction buildAttributesMap(attrStr, options) {\n    if (!options.ignoreAttributes && typeof attrStr === \"string\") {\n        attrStr = attrStr.replace(/\\r?\\n/g, \" \");\n        //attrStr = attrStr || attrStr.trim();\n\n        const matches = util.getAllMatches(attrStr, attrsRegx);\n        const len = matches.length; //don't make it inline\n        const attrs = {};\n        for (let i = 0; i < len; i++) {\n            const attrName = resolveNameSpace(matches[i][1], options);\n            if (attrName.length) {\n                if (matches[i][4] !== undefined) {\n                    if (options.trimValues) {\n                        matches[i][4] = matches[i][4].trim();\n                    }\n                    matches[i][4] = options.attrValueProcessor(matches[i][4]);\n                    attrs[options.attributeNamePrefix + attrName] = parseValue(matches[i][4], options.parseAttributeValue);\n                } else if (options.allowBooleanAttributes) {\n                    attrs[options.attributeNamePrefix + attrName] = true;\n                }\n\n            }\n        }\n        if (!Object.keys(attrs).length) {\n            return;\n        }\n        if (options.attrNodeName) {\n            const attrCollection = {};\n            attrCollection[options.attrNodeName] = attrs;\n            return attrCollection;\n        }\n        return attrs;\n    }\n}\n\nexports.getTraversalObj = getTraversalObj;\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/fast-xml-parser/src/x2j.js?");

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlNode.js":
/*!*****************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlNode.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function(tagname, parent, val) {\n    this.tagname = tagname;\n    this.parent = parent;\n    this.child = {};//child tags\n    this.attrsMap = {};//attributes map\n    this.val = val;//text only\n    this.addChild = function(child) {\n        if (this.child[child.tagname]) {//already presents\n            this.child[child.tagname].push(child);\n        } else {\n            this.child[child.tagname] = [child];\n        }\n    };\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/fast-xml-parser/src/xmlNode.js?");

/***/ }),

/***/ "./node_modules/fecha/fecha.js":
/*!*************************************!*\
  !*** ./node_modules/fecha/fecha.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;(function (main) {\n  'use strict';\n\n  /**\n   * Parse or format dates\n   * @class fecha\n   */\n  var fecha = {};\n  var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|([HhMsDm])\\1?|[aA]|\"[^\"]*\"|'[^']*'/g;\n  var twoDigits = /\\d\\d?/;\n  var threeDigits = /\\d{3}/;\n  var fourDigits = /\\d{4}/;\n  var word = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i;\n  var literal = /\\[([^]*?)\\]/gm;\n  var noop = function () {\n  };\n\n  function shorten(arr, sLen) {\n    var newArr = [];\n    for (var i = 0, len = arr.length; i < len; i++) {\n      newArr.push(arr[i].substr(0, sLen));\n    }\n    return newArr;\n  }\n\n  function monthUpdate(arrName) {\n    return function (d, v, i18n) {\n      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());\n      if (~index) {\n        d.month = index;\n      }\n    };\n  }\n\n  function pad(val, len) {\n    val = String(val);\n    len = len || 2;\n    while (val.length < len) {\n      val = '0' + val;\n    }\n    return val;\n  }\n\n  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n  var monthNamesShort = shorten(monthNames, 3);\n  var dayNamesShort = shorten(dayNames, 3);\n  fecha.i18n = {\n    dayNamesShort: dayNamesShort,\n    dayNames: dayNames,\n    monthNamesShort: monthNamesShort,\n    monthNames: monthNames,\n    amPm: ['am', 'pm'],\n    DoFn: function DoFn(D) {\n      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];\n    }\n  };\n\n  var formatFlags = {\n    D: function(dateObj) {\n      return dateObj.getDate();\n    },\n    DD: function(dateObj) {\n      return pad(dateObj.getDate());\n    },\n    Do: function(dateObj, i18n) {\n      return i18n.DoFn(dateObj.getDate());\n    },\n    d: function(dateObj) {\n      return dateObj.getDay();\n    },\n    dd: function(dateObj) {\n      return pad(dateObj.getDay());\n    },\n    ddd: function(dateObj, i18n) {\n      return i18n.dayNamesShort[dateObj.getDay()];\n    },\n    dddd: function(dateObj, i18n) {\n      return i18n.dayNames[dateObj.getDay()];\n    },\n    M: function(dateObj) {\n      return dateObj.getMonth() + 1;\n    },\n    MM: function(dateObj) {\n      return pad(dateObj.getMonth() + 1);\n    },\n    MMM: function(dateObj, i18n) {\n      return i18n.monthNamesShort[dateObj.getMonth()];\n    },\n    MMMM: function(dateObj, i18n) {\n      return i18n.monthNames[dateObj.getMonth()];\n    },\n    YY: function(dateObj) {\n      return String(dateObj.getFullYear()).substr(2);\n    },\n    YYYY: function(dateObj) {\n      return pad(dateObj.getFullYear(), 4);\n    },\n    h: function(dateObj) {\n      return dateObj.getHours() % 12 || 12;\n    },\n    hh: function(dateObj) {\n      return pad(dateObj.getHours() % 12 || 12);\n    },\n    H: function(dateObj) {\n      return dateObj.getHours();\n    },\n    HH: function(dateObj) {\n      return pad(dateObj.getHours());\n    },\n    m: function(dateObj) {\n      return dateObj.getMinutes();\n    },\n    mm: function(dateObj) {\n      return pad(dateObj.getMinutes());\n    },\n    s: function(dateObj) {\n      return dateObj.getSeconds();\n    },\n    ss: function(dateObj) {\n      return pad(dateObj.getSeconds());\n    },\n    S: function(dateObj) {\n      return Math.round(dateObj.getMilliseconds() / 100);\n    },\n    SS: function(dateObj) {\n      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);\n    },\n    SSS: function(dateObj) {\n      return pad(dateObj.getMilliseconds(), 3);\n    },\n    a: function(dateObj, i18n) {\n      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];\n    },\n    A: function(dateObj, i18n) {\n      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();\n    },\n    ZZ: function(dateObj) {\n      var o = dateObj.getTimezoneOffset();\n      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);\n    }\n  };\n\n  var parseFlags = {\n    D: [twoDigits, function (d, v) {\n      d.day = v;\n    }],\n    Do: [new RegExp(twoDigits.source + word.source), function (d, v) {\n      d.day = parseInt(v, 10);\n    }],\n    M: [twoDigits, function (d, v) {\n      d.month = v - 1;\n    }],\n    YY: [twoDigits, function (d, v) {\n      var da = new Date(), cent = +('' + da.getFullYear()).substr(0, 2);\n      d.year = '' + (v > 68 ? cent - 1 : cent) + v;\n    }],\n    h: [twoDigits, function (d, v) {\n      d.hour = v;\n    }],\n    m: [twoDigits, function (d, v) {\n      d.minute = v;\n    }],\n    s: [twoDigits, function (d, v) {\n      d.second = v;\n    }],\n    YYYY: [fourDigits, function (d, v) {\n      d.year = v;\n    }],\n    S: [/\\d/, function (d, v) {\n      d.millisecond = v * 100;\n    }],\n    SS: [/\\d{2}/, function (d, v) {\n      d.millisecond = v * 10;\n    }],\n    SSS: [threeDigits, function (d, v) {\n      d.millisecond = v;\n    }],\n    d: [twoDigits, noop],\n    ddd: [word, noop],\n    MMM: [word, monthUpdate('monthNamesShort')],\n    MMMM: [word, monthUpdate('monthNames')],\n    a: [word, function (d, v, i18n) {\n      var val = v.toLowerCase();\n      if (val === i18n.amPm[0]) {\n        d.isPm = false;\n      } else if (val === i18n.amPm[1]) {\n        d.isPm = true;\n      }\n    }],\n    ZZ: [/([\\+\\-]\\d\\d:?\\d\\d|Z)/, function (d, v) {\n      if (v === 'Z') v = '+00:00';\n      var parts = (v + '').match(/([\\+\\-]|\\d\\d)/gi), minutes;\n\n      if (parts) {\n        minutes = +(parts[1] * 60) + parseInt(parts[2], 10);\n        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;\n      }\n    }]\n  };\n  parseFlags.dd = parseFlags.d;\n  parseFlags.dddd = parseFlags.ddd;\n  parseFlags.DD = parseFlags.D;\n  parseFlags.mm = parseFlags.m;\n  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;\n  parseFlags.MM = parseFlags.M;\n  parseFlags.ss = parseFlags.s;\n  parseFlags.A = parseFlags.a;\n\n\n  // Some common format strings\n  fecha.masks = {\n    default: 'ddd MMM DD YYYY HH:mm:ss',\n    shortDate: 'M/D/YY',\n    mediumDate: 'MMM D, YYYY',\n    longDate: 'MMMM D, YYYY',\n    fullDate: 'dddd, MMMM D, YYYY',\n    shortTime: 'HH:mm',\n    mediumTime: 'HH:mm:ss',\n    longTime: 'HH:mm:ss.SSS'\n  };\n\n  /***\n   * Format a date\n   * @method format\n   * @param {Date|number} dateObj\n   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'\n   */\n  fecha.format = function (dateObj, mask, i18nSettings) {\n    var i18n = i18nSettings || fecha.i18n;\n\n    if (typeof dateObj === 'number') {\n      dateObj = new Date(dateObj);\n    }\n\n    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {\n      throw new Error('Invalid Date in fecha.format');\n    }\n\n    mask = fecha.masks[mask] || mask || fecha.masks['default'];\n\n    var literals = [];\n\n    // Make literals inactive by replacing them with ??\n    mask = mask.replace(literal, function($0, $1) {\n      literals.push($1);\n      return '??';\n    });\n    // Apply formatting rules\n    mask = mask.replace(token, function ($0) {\n      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);\n    });\n    // Inline literal values back into the formatted value\n    return mask.replace(/\\?\\?/g, function() {\n      return literals.shift();\n    });\n  };\n\n  /**\n   * Parse a date string into an object, changes - into /\n   * @method parse\n   * @param {string} dateStr Date string\n   * @param {string} format Date parse format\n   * @returns {Date|boolean}\n   */\n  fecha.parse = function (dateStr, format, i18nSettings) {\n    var i18n = i18nSettings || fecha.i18n;\n\n    if (typeof format !== 'string') {\n      throw new Error('Invalid format in fecha.parse');\n    }\n\n    format = fecha.masks[format] || format;\n\n    // Avoid regular expression denial of service, fail early for really long strings\n    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS\n    if (dateStr.length > 1000) {\n      return false;\n    }\n\n    var isValid = true;\n    var dateInfo = {};\n    format.replace(token, function ($0) {\n      if (parseFlags[$0]) {\n        var info = parseFlags[$0];\n        var index = dateStr.search(info[0]);\n        if (!~index) {\n          isValid = false;\n        } else {\n          dateStr.replace(info[0], function (result) {\n            info[1](dateInfo, result, i18n);\n            dateStr = dateStr.substr(index + result.length);\n            return result;\n          });\n        }\n      }\n\n      return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);\n    });\n\n    if (!isValid) {\n      return false;\n    }\n\n    var today = new Date();\n    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {\n      dateInfo.hour = +dateInfo.hour + 12;\n    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {\n      dateInfo.hour = 0;\n    }\n\n    var date;\n    if (dateInfo.timezoneOffset != null) {\n      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;\n      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1,\n        dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));\n    } else {\n      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1,\n        dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);\n    }\n    return date;\n  };\n\n  /* istanbul ignore next */\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = fecha;\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return fecha;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/fecha/fecha.js?");

/***/ }),

/***/ "./node_modules/has-binary2/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-binary2/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* global Blob File */\n\n/*\n * Module requirements.\n */\n\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/has-binary2/node_modules/isarray/index.js\");\n\nvar toString = Object.prototype.toString;\nvar withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';\nvar withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';\n\n/**\n * Module exports.\n */\n\nmodule.exports = hasBinary;\n\n/**\n * Checks for binary data.\n *\n * Supports Buffer, ArrayBuffer, Blob and File.\n *\n * @param {Object} anything\n * @api public\n */\n\nfunction hasBinary (obj) {\n  if (!obj || typeof obj !== 'object') {\n    return false;\n  }\n\n  if (isArray(obj)) {\n    for (var i = 0, l = obj.length; i < l; i++) {\n      if (hasBinary(obj[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  if ((typeof global.Buffer === 'function' && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||\n     (typeof global.ArrayBuffer === 'function' && obj instanceof ArrayBuffer) ||\n     (withNativeBlob && obj instanceof Blob) ||\n     (withNativeFile && obj instanceof File)\n    ) {\n    return true;\n  }\n\n  // see: https://github.com/Automattic/has-binary/pull/4\n  if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {\n    return hasBinary(obj.toJSON(), true);\n  }\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/has-binary2/index.js?");

/***/ }),

/***/ "./node_modules/has-binary2/node_modules/isarray/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/has-binary2/node_modules/isarray/index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/has-binary2/node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/has-flag/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-flag/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = (flag, argv) => {\n\targv = argv || process.argv;\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst pos = argv.indexOf(prefix + flag);\n\tconst terminatorPos = argv.indexOf('--');\n\treturn pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/has-flag/index.js?");

/***/ }),

/***/ "./node_modules/indexof/index.js":
/*!***************************************!*\
  !*** ./node_modules/indexof/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/indexof/index.js?");

/***/ }),

/***/ "./node_modules/js-base64/base64.js":
/*!******************************************!*\
  !*** ./node_modules/js-base64/base64.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *  base64.js\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n */\n;(function (global, factory) {\n     true\n        ? module.exports = factory(global)\n        : undefined\n}((\n    typeof self !== 'undefined' ? self\n        : typeof window !== 'undefined' ? window\n        : typeof global !== 'undefined' ? global\n: this\n), function(global) {\n    'use strict';\n    // existing version for noConflict()\n    var _Base64 = global.Base64;\n    var version = \"2.4.3\";\n    // if node.js, we use Buffer\n    var buffer;\n    if (typeof module !== 'undefined' && module.exports) {\n        try {\n            buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer;\n        } catch (err) {}\n    }\n    // constants\n    var b64chars\n        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    var b64tab = function(bin) {\n        var t = {};\n        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;\n        return t;\n    }(b64chars);\n    var fromCharCode = String.fromCharCode;\n    // encoder stuff\n    var cb_utob = function(c) {\n        if (c.length < 2) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c\n                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))\n                                + fromCharCode(0x80 | (cc & 0x3f)))\n                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))\n                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                   + fromCharCode(0x80 | ( cc         & 0x3f)));\n        } else {\n            var cc = 0x10000\n                + (c.charCodeAt(0) - 0xD800) * 0x400\n                + (c.charCodeAt(1) - 0xDC00);\n            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))\n                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))\n                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                    + fromCharCode(0x80 | ( cc         & 0x3f)));\n        }\n    };\n    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n    var utob = function(u) {\n        return u.replace(re_utob, cb_utob);\n    };\n    var cb_encode = function(ccc) {\n        var padlen = [0, 2, 1][ccc.length % 3],\n        ord = ccc.charCodeAt(0) << 16\n            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)\n            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),\n        chars = [\n            b64chars.charAt( ord >>> 18),\n            b64chars.charAt((ord >>> 12) & 63),\n            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),\n            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)\n        ];\n        return chars.join('');\n    };\n    var btoa = global.btoa ? function(b) {\n        return global.btoa(b);\n    } : function(b) {\n        return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n    };\n    var _encode = buffer ?\n        buffer.from && buffer.from !== Uint8Array.from ? function (u) {\n            return (u.constructor === buffer.constructor ? u : buffer.from(u))\n                .toString('base64')\n        }\n        :  function (u) {\n            return (u.constructor === buffer.constructor ? u : new  buffer(u))\n                .toString('base64')\n        }\n        : function (u) { return btoa(utob(u)) }\n    ;\n    var encode = function(u, urisafe) {\n        return !urisafe\n            ? _encode(String(u))\n            : _encode(String(u)).replace(/[+\\/]/g, function(m0) {\n                return m0 == '+' ? '-' : '_';\n            }).replace(/=/g, '');\n    };\n    var encodeURI = function(u) { return encode(u, true) };\n    // decoder stuff\n    var re_btou = new RegExp([\n        '[\\xC0-\\xDF][\\x80-\\xBF]',\n        '[\\xE0-\\xEF][\\x80-\\xBF]{2}',\n        '[\\xF0-\\xF7][\\x80-\\xBF]{3}'\n    ].join('|'), 'g');\n    var cb_btou = function(cccc) {\n        switch(cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                |    ((0x3f & cccc.charCodeAt(1)) << 12)\n                |    ((0x3f & cccc.charCodeAt(2)) <<  6)\n                |     (0x3f & cccc.charCodeAt(3)),\n            offset = cp - 0x10000;\n            return (fromCharCode((offset  >>> 10) + 0xD800)\n                    + fromCharCode((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return fromCharCode(\n                ((0x0f & cccc.charCodeAt(0)) << 12)\n                    | ((0x3f & cccc.charCodeAt(1)) << 6)\n                    |  (0x3f & cccc.charCodeAt(2))\n            );\n        default:\n            return  fromCharCode(\n                ((0x1f & cccc.charCodeAt(0)) << 6)\n                    |  (0x3f & cccc.charCodeAt(1))\n            );\n        }\n    };\n    var btou = function(b) {\n        return b.replace(re_btou, cb_btou);\n    };\n    var cb_decode = function(cccc) {\n        var len = cccc.length,\n        padlen = len % 4,\n        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)\n            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)\n            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)\n            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),\n        chars = [\n            fromCharCode( n >>> 16),\n            fromCharCode((n >>>  8) & 0xff),\n            fromCharCode( n         & 0xff)\n        ];\n        chars.length -= [0, 0, 2, 1][padlen];\n        return chars.join('');\n    };\n    var atob = global.atob ? function(a) {\n        return global.atob(a);\n    } : function(a){\n        return a.replace(/[\\s\\S]{1,4}/g, cb_decode);\n    };\n    var _decode = buffer ?\n        buffer.from && buffer.from !== Uint8Array.from ? function(a) {\n            return (a.constructor === buffer.constructor\n                    ? a : buffer.from(a, 'base64')).toString();\n        }\n        : function(a) {\n            return (a.constructor === buffer.constructor\n                    ? a : new buffer(a, 'base64')).toString();\n        }\n        : function(a) { return btou(atob(a)) };\n    var decode = function(a){\n        return _decode(\n            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })\n                .replace(/[^A-Za-z0-9\\+\\/]/g, '')\n        );\n    };\n    var noConflict = function() {\n        var Base64 = global.Base64;\n        global.Base64 = _Base64;\n        return Base64;\n    };\n    // export Base64\n    global.Base64 = {\n        VERSION: version,\n        atob: atob,\n        btoa: btoa,\n        fromBase64: decode,\n        toBase64: encode,\n        utob: utob,\n        encode: encode,\n        encodeURI: encodeURI,\n        btou: btou,\n        decode: decode,\n        noConflict: noConflict\n    };\n    // if ES5 is available, make Base64.extendString() available\n    if (typeof Object.defineProperty === 'function') {\n        var noEnum = function(v){\n            return {value:v,enumerable:false,writable:true,configurable:true};\n        };\n        global.Base64.extendString = function () {\n            Object.defineProperty(\n                String.prototype, 'fromBase64', noEnum(function () {\n                    return decode(this)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64', noEnum(function (urisafe) {\n                    return encode(this, urisafe)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64URI', noEnum(function () {\n                    return encode(this, true)\n                }));\n        };\n    }\n    //\n    // export Base64 to the namespace\n    //\n    if (global['Meteor']) { // Meteor.js\n        Base64 = global.Base64;\n    }\n    // module.exports and AMD are mutually exclusive.\n    // module.exports has precedence.\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports.Base64 = global.Base64;\n    }\n    else if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){ return global.Base64 }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    // that's it!\n    return {Base64: global.Base64}\n}));\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/js-base64/base64.js?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/parseqs/index.js":
/*!***************************************!*\
  !*** ./node_modules/parseqs/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Compiles a querystring\r\n * Returns string representation of the object\r\n *\r\n * @param {Object}\r\n * @api private\r\n */\r\n\r\nexports.encode = function (obj) {\r\n  var str = '';\r\n\r\n  for (var i in obj) {\r\n    if (obj.hasOwnProperty(i)) {\r\n      if (str.length) str += '&';\r\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\r\n    }\r\n  }\r\n\r\n  return str;\r\n};\r\n\r\n/**\r\n * Parses a simple querystring into an object\r\n *\r\n * @param {String} qs\r\n * @api private\r\n */\r\n\r\nexports.decode = function(qs){\r\n  var qry = {};\r\n  var pairs = qs.split('&');\r\n  for (var i = 0, l = pairs.length; i < l; i++) {\r\n    var pair = pairs[i].split('=');\r\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\r\n  }\r\n  return qry;\r\n};\r\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/parseqs/index.js?");

/***/ }),

/***/ "./node_modules/parseuri/index.js":
/*!****************************************!*\
  !*** ./node_modules/parseuri/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Parses an URI\r\n *\r\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\r\n * @api private\r\n */\r\n\r\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\r\n\r\nvar parts = [\r\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\r\n];\r\n\r\nmodule.exports = function parseuri(str) {\r\n    var src = str,\r\n        b = str.indexOf('['),\r\n        e = str.indexOf(']');\r\n\r\n    if (b != -1 && e != -1) {\r\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\r\n    }\r\n\r\n    var m = re.exec(str || ''),\r\n        uri = {},\r\n        i = 14;\r\n\r\n    while (i--) {\r\n        uri[parts[i]] = m[i] || '';\r\n    }\r\n\r\n    if (b != -1 && e != -1) {\r\n        uri.source = src;\r\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\r\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\r\n        uri.ipv6uri = true;\r\n    }\r\n\r\n    return uri;\r\n};\r\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/parseuri/index.js?");

/***/ }),

/***/ "./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js":
/*!******************************************************************!*\
  !*** ./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar SDPUtils = __webpack_require__(/*! sdp */ \"./node_modules/sdp/sdp.js\");\n\nfunction writeMediaSection(transceiver, caps, type, stream, dtlsRole) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : dtlsRole || 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    var trackId = transceiver.rtpSender._initialTrackId ||\n        transceiver.rtpSender.track.id;\n    transceiver.rtpSender._initialTrackId = trackId;\n    // spec.\n    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +\n        trackId + '\\r\\n';\n    sdp += 'a=' + msid;\n    // for Chrome. Legacy should no longer be required.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n\n    // RTX\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n}\n\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nfunction filterIceServers(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function(server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        console.warn('RTCIceServer.url is deprecated! Use urls instead.');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function(url) {\n        var validTurn = url.indexOf('turn:') === 0 &&\n            url.indexOf('transport=udp') !== -1 &&\n            url.indexOf('turn:[') === -1 &&\n            !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&\n            url.indexOf('?transport=udp') === -1;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n}\n\n// Determines the intersection of local and remote capabilities.\nfunction getCommonCapabilities(localCapabilities, remoteCapabilities) {\n  var commonCapabilities = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: []\n  };\n\n  var findCodecByPayloadType = function(pt, codecs) {\n    pt = parseInt(pt, 10);\n    for (var i = 0; i < codecs.length; i++) {\n      if (codecs[i].payloadType === pt ||\n          codecs[i].preferredPayloadType === pt) {\n        return codecs[i];\n      }\n    }\n  };\n\n  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {\n    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);\n    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\n    return lCodec && rCodec &&\n        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\n  };\n\n  localCapabilities.codecs.forEach(function(lCodec) {\n    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n      var rCodec = remoteCapabilities.codecs[i];\n      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\n          lCodec.clockRate === rCodec.clockRate) {\n        if (lCodec.name.toLowerCase() === 'rtx' &&\n            lCodec.parameters && rCodec.parameters.apt) {\n          // for RTX we need to find the local rtx that has a apt\n          // which points to the same local codec as the remote one.\n          if (!rtxCapabilityMatches(lCodec, rCodec,\n              localCapabilities.codecs, remoteCapabilities.codecs)) {\n            continue;\n          }\n        }\n        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy\n        // number of channels is the highest common number of channels\n        rCodec.numChannels = Math.min(lCodec.numChannels,\n            rCodec.numChannels);\n        // push rCodec so we reply with offerer payload type\n        commonCapabilities.codecs.push(rCodec);\n\n        // determine common feedback mechanisms\n        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\n          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n            if (lCodec.rtcpFeedback[j].type === fb.type &&\n                lCodec.rtcpFeedback[j].parameter === fb.parameter) {\n              return true;\n            }\n          }\n          return false;\n        });\n        // FIXME: also need to determine .parameters\n        //  see https://github.com/openpeer/ortc/issues/569\n        break;\n      }\n    }\n  });\n\n  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {\n    for (var i = 0; i < remoteCapabilities.headerExtensions.length;\n         i++) {\n      var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n      if (lHeaderExtension.uri === rHeaderExtension.uri) {\n        commonCapabilities.headerExtensions.push(rHeaderExtension);\n        break;\n      }\n    }\n  });\n\n  // FIXME: fecMechanisms\n  return commonCapabilities;\n}\n\n// is action=setLocalDescription with type allowed in signalingState\nfunction isActionAllowedInSignalingState(action, type, signalingState) {\n  return {\n    offer: {\n      setLocalDescription: ['stable', 'have-local-offer'],\n      setRemoteDescription: ['stable', 'have-remote-offer']\n    },\n    answer: {\n      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],\n      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']\n    }\n  }[type][action].indexOf(signalingState) !== -1;\n}\n\nfunction maybeAddCandidate(iceTransport, candidate) {\n  // Edge's internal representation adds some fields therefore\n  // not all fieldѕ are taken into account.\n  var alreadyAdded = iceTransport.getRemoteCandidates()\n      .find(function(remoteCandidate) {\n        return candidate.foundation === remoteCandidate.foundation &&\n            candidate.ip === remoteCandidate.ip &&\n            candidate.port === remoteCandidate.port &&\n            candidate.priority === remoteCandidate.priority &&\n            candidate.protocol === remoteCandidate.protocol &&\n            candidate.type === remoteCandidate.type;\n      });\n  if (!alreadyAdded) {\n    iceTransport.addRemoteCandidate(candidate);\n  }\n  return !alreadyAdded;\n}\n\n\nfunction makeError(name, description) {\n  var e = new Error(description);\n  e.name = name;\n  // legacy error codes from https://heycam.github.io/webidl/#idl-DOMException-error-names\n  e.code = {\n    NotSupportedError: 9,\n    InvalidStateError: 11,\n    InvalidAccessError: 15,\n    TypeError: undefined,\n    OperationError: undefined\n  }[name];\n  return e;\n}\n\nmodule.exports = function(window, edgeVersion) {\n  // https://w3c.github.io/mediacapture-main/#mediastream\n  // Helper function to add the track to the stream and\n  // dispatch the event ourselves.\n  function addTrackToStreamAndFireEvent(track, stream) {\n    stream.addTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',\n        {track: track}));\n  }\n\n  function removeTrackFromStreamAndFireEvent(track, stream) {\n    stream.removeTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',\n        {track: track}));\n  }\n\n  function fireAddTrack(pc, track, receiver, streams) {\n    var trackEvent = new Event('track');\n    trackEvent.track = track;\n    trackEvent.receiver = receiver;\n    trackEvent.transceiver = {receiver: receiver};\n    trackEvent.streams = streams;\n    window.setTimeout(function() {\n      pc._dispatchEvent('track', trackEvent);\n    });\n  }\n\n  var RTCPeerConnection = function(config) {\n    var pc = this;\n\n    var _eventTarget = document.createDocumentFragment();\n    ['addEventListener', 'removeEventListener', 'dispatchEvent']\n        .forEach(function(method) {\n          pc[method] = _eventTarget[method].bind(_eventTarget);\n        });\n\n    this.canTrickleIceCandidates = null;\n\n    this.needNegotiation = false;\n\n    this.localStreams = [];\n    this.remoteStreams = [];\n\n    this.localDescription = null;\n    this.remoteDescription = null;\n\n    this.signalingState = 'stable';\n    this.iceConnectionState = 'new';\n    this.connectionState = 'new';\n    this.iceGatheringState = 'new';\n\n    config = JSON.parse(JSON.stringify(config || {}));\n\n    this.usingBundle = config.bundlePolicy === 'max-bundle';\n    if (config.rtcpMuxPolicy === 'negotiate') {\n      throw(makeError('NotSupportedError',\n          'rtcpMuxPolicy \\'negotiate\\' is not supported'));\n    } else if (!config.rtcpMuxPolicy) {\n      config.rtcpMuxPolicy = 'require';\n    }\n\n    switch (config.iceTransportPolicy) {\n      case 'all':\n      case 'relay':\n        break;\n      default:\n        config.iceTransportPolicy = 'all';\n        break;\n    }\n\n    switch (config.bundlePolicy) {\n      case 'balanced':\n      case 'max-compat':\n      case 'max-bundle':\n        break;\n      default:\n        config.bundlePolicy = 'balanced';\n        break;\n    }\n\n    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);\n\n    this._iceGatherers = [];\n    if (config.iceCandidatePoolSize) {\n      for (var i = config.iceCandidatePoolSize; i > 0; i--) {\n        this._iceGatherers.push(new window.RTCIceGatherer({\n          iceServers: config.iceServers,\n          gatherPolicy: config.iceTransportPolicy\n        }));\n      }\n    } else {\n      config.iceCandidatePoolSize = 0;\n    }\n\n    this._config = config;\n\n    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n    // everything that is needed to describe a SDP m-line.\n    this.transceivers = [];\n\n    this._sdpSessionId = SDPUtils.generateSessionId();\n    this._sdpSessionVersion = 0;\n\n    this._dtlsRole = undefined; // role for a=setup to use in answers.\n\n    this._isClosed = false;\n  };\n\n  // set up event handlers on prototype\n  RTCPeerConnection.prototype.onicecandidate = null;\n  RTCPeerConnection.prototype.onaddstream = null;\n  RTCPeerConnection.prototype.ontrack = null;\n  RTCPeerConnection.prototype.onremovestream = null;\n  RTCPeerConnection.prototype.onsignalingstatechange = null;\n  RTCPeerConnection.prototype.oniceconnectionstatechange = null;\n  RTCPeerConnection.prototype.onconnectionstatechange = null;\n  RTCPeerConnection.prototype.onicegatheringstatechange = null;\n  RTCPeerConnection.prototype.onnegotiationneeded = null;\n  RTCPeerConnection.prototype.ondatachannel = null;\n\n  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {\n    if (this._isClosed) {\n      return;\n    }\n    this.dispatchEvent(event);\n    if (typeof this['on' + name] === 'function') {\n      this['on' + name](event);\n    }\n  };\n\n  RTCPeerConnection.prototype._emitGatheringStateChange = function() {\n    var event = new Event('icegatheringstatechange');\n    this._dispatchEvent('icegatheringstatechange', event);\n  };\n\n  RTCPeerConnection.prototype.getConfiguration = function() {\n    return this._config;\n  };\n\n  RTCPeerConnection.prototype.getLocalStreams = function() {\n    return this.localStreams;\n  };\n\n  RTCPeerConnection.prototype.getRemoteStreams = function() {\n    return this.remoteStreams;\n  };\n\n  // internal helper to create a transceiver object.\n  // (which is not yet the same as the WebRTC 1.0 transceiver)\n  RTCPeerConnection.prototype._createTransceiver = function(kind, doNotAdd) {\n    var hasBundleTransport = this.transceivers.length > 0;\n    var transceiver = {\n      track: null,\n      iceGatherer: null,\n      iceTransport: null,\n      dtlsTransport: null,\n      localCapabilities: null,\n      remoteCapabilities: null,\n      rtpSender: null,\n      rtpReceiver: null,\n      kind: kind,\n      mid: null,\n      sendEncodingParameters: null,\n      recvEncodingParameters: null,\n      stream: null,\n      associatedRemoteMediaStreams: [],\n      wantReceive: true\n    };\n    if (this.usingBundle && hasBundleTransport) {\n      transceiver.iceTransport = this.transceivers[0].iceTransport;\n      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;\n    } else {\n      var transports = this._createIceAndDtlsTransports();\n      transceiver.iceTransport = transports.iceTransport;\n      transceiver.dtlsTransport = transports.dtlsTransport;\n    }\n    if (!doNotAdd) {\n      this.transceivers.push(transceiver);\n    }\n    return transceiver;\n  };\n\n  RTCPeerConnection.prototype.addTrack = function(track, stream) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call addTrack on a closed peerconnection.');\n    }\n\n    var alreadyExists = this.transceivers.find(function(s) {\n      return s.track === track;\n    });\n\n    if (alreadyExists) {\n      throw makeError('InvalidAccessError', 'Track already exists.');\n    }\n\n    var transceiver;\n    for (var i = 0; i < this.transceivers.length; i++) {\n      if (!this.transceivers[i].track &&\n          this.transceivers[i].kind === track.kind) {\n        transceiver = this.transceivers[i];\n      }\n    }\n    if (!transceiver) {\n      transceiver = this._createTransceiver(track.kind);\n    }\n\n    this._maybeFireNegotiationNeeded();\n\n    if (this.localStreams.indexOf(stream) === -1) {\n      this.localStreams.push(stream);\n    }\n\n    transceiver.track = track;\n    transceiver.stream = stream;\n    transceiver.rtpSender = new window.RTCRtpSender(track,\n        transceiver.dtlsTransport);\n    return transceiver.rtpSender;\n  };\n\n  RTCPeerConnection.prototype.addStream = function(stream) {\n    var pc = this;\n    if (edgeVersion >= 15025) {\n      stream.getTracks().forEach(function(track) {\n        pc.addTrack(track, stream);\n      });\n    } else {\n      // Clone is necessary for local demos mostly, attaching directly\n      // to two different senders does not work (build 10547).\n      // Fixed in 15025 (or earlier)\n      var clonedStream = stream.clone();\n      stream.getTracks().forEach(function(track, idx) {\n        var clonedTrack = clonedStream.getTracks()[idx];\n        track.addEventListener('enabled', function(event) {\n          clonedTrack.enabled = event.enabled;\n        });\n      });\n      clonedStream.getTracks().forEach(function(track) {\n        pc.addTrack(track, clonedStream);\n      });\n    }\n  };\n\n  RTCPeerConnection.prototype.removeTrack = function(sender) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call removeTrack on a closed peerconnection.');\n    }\n\n    if (!(sender instanceof window.RTCRtpSender)) {\n      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +\n          'does not implement interface RTCRtpSender.');\n    }\n\n    var transceiver = this.transceivers.find(function(t) {\n      return t.rtpSender === sender;\n    });\n\n    if (!transceiver) {\n      throw makeError('InvalidAccessError',\n          'Sender was not created by this connection.');\n    }\n    var stream = transceiver.stream;\n\n    transceiver.rtpSender.stop();\n    transceiver.rtpSender = null;\n    transceiver.track = null;\n    transceiver.stream = null;\n\n    // remove the stream from the set of local streams\n    var localStreams = this.transceivers.map(function(t) {\n      return t.stream;\n    });\n    if (localStreams.indexOf(stream) === -1 &&\n        this.localStreams.indexOf(stream) > -1) {\n      this.localStreams.splice(this.localStreams.indexOf(stream), 1);\n    }\n\n    this._maybeFireNegotiationNeeded();\n  };\n\n  RTCPeerConnection.prototype.removeStream = function(stream) {\n    var pc = this;\n    stream.getTracks().forEach(function(track) {\n      var sender = pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n      if (sender) {\n        pc.removeTrack(sender);\n      }\n    });\n  };\n\n  RTCPeerConnection.prototype.getSenders = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpSender;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpSender;\n    });\n  };\n\n  RTCPeerConnection.prototype.getReceivers = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpReceiver;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpReceiver;\n    });\n  };\n\n\n  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,\n      usingBundle) {\n    var pc = this;\n    if (usingBundle && sdpMLineIndex > 0) {\n      return this.transceivers[0].iceGatherer;\n    } else if (this._iceGatherers.length) {\n      return this._iceGatherers.shift();\n    }\n    var iceGatherer = new window.RTCIceGatherer({\n      iceServers: this._config.iceServers,\n      gatherPolicy: this._config.iceTransportPolicy\n    });\n    Object.defineProperty(iceGatherer, 'state',\n        {value: 'new', writable: true}\n    );\n\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];\n    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {\n      var end = !event.candidate || Object.keys(event.candidate).length === 0;\n      // polyfill since RTCIceGatherer.state is not implemented in\n      // Edge 10547 yet.\n      iceGatherer.state = end ? 'completed' : 'gathering';\n      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {\n        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);\n      }\n    };\n    iceGatherer.addEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    return iceGatherer;\n  };\n\n  // start gathering from an RTCIceGatherer.\n  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {\n    var pc = this;\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer.onlocalcandidate) {\n      return;\n    }\n    var bufferedCandidateEvents =\n      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;\n    iceGatherer.removeEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    iceGatherer.onlocalcandidate = function(evt) {\n      if (pc.usingBundle && sdpMLineIndex > 0) {\n        // if we know that we use bundle we can drop candidates with\n        // ѕdpMLineIndex > 0. If we don't do this then our state gets\n        // confused since we dispose the extra ice gatherer.\n        return;\n      }\n      var event = new Event('icecandidate');\n      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\n\n      var cand = evt.candidate;\n      // Edge emits an empty object for RTCIceCandidateComplete‥\n      var end = !cand || Object.keys(cand).length === 0;\n      if (end) {\n        // polyfill since RTCIceGatherer.state is not implemented in\n        // Edge 10547 yet.\n        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {\n          iceGatherer.state = 'completed';\n        }\n      } else {\n        if (iceGatherer.state === 'new') {\n          iceGatherer.state = 'gathering';\n        }\n        // RTCIceCandidate doesn't have a component, needs to be added\n        cand.component = 1;\n        // also the usernameFragment. TODO: update SDP to take both variants.\n        cand.ufrag = iceGatherer.getLocalParameters().usernameFragment;\n\n        var serializedCandidate = SDPUtils.writeCandidate(cand);\n        event.candidate = Object.assign(event.candidate,\n            SDPUtils.parseCandidate(serializedCandidate));\n\n        event.candidate.candidate = serializedCandidate;\n        event.candidate.toJSON = function() {\n          return {\n            candidate: event.candidate.candidate,\n            sdpMid: event.candidate.sdpMid,\n            sdpMLineIndex: event.candidate.sdpMLineIndex,\n            usernameFragment: event.candidate.usernameFragment\n          };\n        };\n      }\n\n      // update local description.\n      var sections = SDPUtils.getMediaSections(pc.localDescription.sdp);\n      if (!end) {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=' + event.candidate.candidate + '\\r\\n';\n      } else {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=end-of-candidates\\r\\n';\n      }\n      pc.localDescription.sdp =\n          SDPUtils.getDescription(pc.localDescription.sdp) +\n          sections.join('');\n      var complete = pc.transceivers.every(function(transceiver) {\n        return transceiver.iceGatherer &&\n            transceiver.iceGatherer.state === 'completed';\n      });\n\n      if (pc.iceGatheringState !== 'gathering') {\n        pc.iceGatheringState = 'gathering';\n        pc._emitGatheringStateChange();\n      }\n\n      // Emit candidate. Also emit null candidate when all gatherers are\n      // complete.\n      if (!end) {\n        pc._dispatchEvent('icecandidate', event);\n      }\n      if (complete) {\n        pc._dispatchEvent('icecandidate', new Event('icecandidate'));\n        pc.iceGatheringState = 'complete';\n        pc._emitGatheringStateChange();\n      }\n    };\n\n    // emit already gathered candidates.\n    window.setTimeout(function() {\n      bufferedCandidateEvents.forEach(function(e) {\n        iceGatherer.onlocalcandidate(e);\n      });\n    }, 0);\n  };\n\n  // Create ICE transport and DTLS transport.\n  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {\n    var pc = this;\n    var iceTransport = new window.RTCIceTransport(null);\n    iceTransport.onicestatechange = function() {\n      pc._updateIceConnectionState();\n      pc._updateConnectionState();\n    };\n\n    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\n    dtlsTransport.ondtlsstatechange = function() {\n      pc._updateConnectionState();\n    };\n    dtlsTransport.onerror = function() {\n      // onerror does not set state to failed by itself.\n      Object.defineProperty(dtlsTransport, 'state',\n          {value: 'failed', writable: true});\n      pc._updateConnectionState();\n    };\n\n    return {\n      iceTransport: iceTransport,\n      dtlsTransport: dtlsTransport\n    };\n  };\n\n  // Destroy ICE gatherer, ICE transport and DTLS transport.\n  // Without triggering the callbacks.\n  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(\n      sdpMLineIndex) {\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer) {\n      delete iceGatherer.onlocalcandidate;\n      delete this.transceivers[sdpMLineIndex].iceGatherer;\n    }\n    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\n    if (iceTransport) {\n      delete iceTransport.onicestatechange;\n      delete this.transceivers[sdpMLineIndex].iceTransport;\n    }\n    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\n    if (dtlsTransport) {\n      delete dtlsTransport.ondtlsstatechange;\n      delete dtlsTransport.onerror;\n      delete this.transceivers[sdpMLineIndex].dtlsTransport;\n    }\n  };\n\n  // Start the RTP Sender and Receiver for a transceiver.\n  RTCPeerConnection.prototype._transceive = function(transceiver,\n      send, recv) {\n    var params = getCommonCapabilities(transceiver.localCapabilities,\n        transceiver.remoteCapabilities);\n    if (send && transceiver.rtpSender) {\n      params.encodings = transceiver.sendEncodingParameters;\n      params.rtcp = {\n        cname: SDPUtils.localCName,\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.recvEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpSender.send(params);\n    }\n    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {\n      // remove RTX field in Edge 14942\n      if (transceiver.kind === 'video'\n          && transceiver.recvEncodingParameters\n          && edgeVersion < 15019) {\n        transceiver.recvEncodingParameters.forEach(function(p) {\n          delete p.rtx;\n        });\n      }\n      if (transceiver.recvEncodingParameters.length) {\n        params.encodings = transceiver.recvEncodingParameters;\n      } else {\n        params.encodings = [{}];\n      }\n      params.rtcp = {\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.rtcpParameters.cname) {\n        params.rtcp.cname = transceiver.rtcpParameters.cname;\n      }\n      if (transceiver.sendEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpReceiver.receive(params);\n    }\n  };\n\n  RTCPeerConnection.prototype.setLocalDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setLocalDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set local ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var sections;\n    var sessionpart;\n    if (description.type === 'offer') {\n      // VERY limited support for SDP munging. Limited to:\n      // * changing the order of codecs\n      sections = SDPUtils.splitSections(description.sdp);\n      sessionpart = sections.shift();\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var caps = SDPUtils.parseRtpParameters(mediaSection);\n        pc.transceivers[sdpMLineIndex].localCapabilities = caps;\n      });\n\n      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n        pc._gather(transceiver.mid, sdpMLineIndex);\n      });\n    } else if (description.type === 'answer') {\n      sections = SDPUtils.splitSections(pc.remoteDescription.sdp);\n      sessionpart = sections.shift();\n      var isIceLite = SDPUtils.matchPrefix(sessionpart,\n          'a=ice-lite').length > 0;\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        var iceGatherer = transceiver.iceGatherer;\n        var iceTransport = transceiver.iceTransport;\n        var dtlsTransport = transceiver.dtlsTransport;\n        var localCapabilities = transceiver.localCapabilities;\n        var remoteCapabilities = transceiver.remoteCapabilities;\n\n        // treat bundle-only as not-rejected.\n        var rejected = SDPUtils.isRejected(mediaSection) &&\n            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n\n        if (!rejected && !transceiver.rejected) {\n          var remoteIceParameters = SDPUtils.getIceParameters(\n              mediaSection, sessionpart);\n          var remoteDtlsParameters = SDPUtils.getDtlsParameters(\n              mediaSection, sessionpart);\n          if (isIceLite) {\n            remoteDtlsParameters.role = 'server';\n          }\n\n          if (!pc.usingBundle || sdpMLineIndex === 0) {\n            pc._gather(transceiver.mid, sdpMLineIndex);\n            if (iceTransport.state === 'new') {\n              iceTransport.start(iceGatherer, remoteIceParameters,\n                  isIceLite ? 'controlling' : 'controlled');\n            }\n            if (dtlsTransport.state === 'new') {\n              dtlsTransport.start(remoteDtlsParameters);\n            }\n          }\n\n          // Calculate intersection of capabilities.\n          var params = getCommonCapabilities(localCapabilities,\n              remoteCapabilities);\n\n          // Start the RTCRtpSender. The RTCRtpReceiver for this\n          // transceiver has already been started in setRemoteDescription.\n          pc._transceive(transceiver,\n              params.codecs.length > 0,\n              false);\n        }\n      });\n    }\n\n    pc.localDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-local-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.setRemoteDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setRemoteDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set remote ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var streams = {};\n    pc.remoteStreams.forEach(function(stream) {\n      streams[stream.id] = stream;\n    });\n    var receiverList = [];\n    var sections = SDPUtils.splitSections(description.sdp);\n    var sessionpart = sections.shift();\n    var isIceLite = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-lite').length > 0;\n    var usingBundle = SDPUtils.matchPrefix(sessionpart,\n        'a=group:BUNDLE ').length > 0;\n    pc.usingBundle = usingBundle;\n    var iceOptions = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-options:')[0];\n    if (iceOptions) {\n      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')\n          .indexOf('trickle') >= 0;\n    } else {\n      pc.canTrickleIceCandidates = false;\n    }\n\n    sections.forEach(function(mediaSection, sdpMLineIndex) {\n      var lines = SDPUtils.splitLines(mediaSection);\n      var kind = SDPUtils.getKind(mediaSection);\n      // treat bundle-only as not-rejected.\n      var rejected = SDPUtils.isRejected(mediaSection) &&\n          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n      var protocol = lines[0].substr(2).split(' ')[2];\n\n      var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n      var remoteMsid = SDPUtils.parseMsid(mediaSection);\n\n      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();\n\n      // Reject datachannels which are not implemented yet.\n      if ((kind === 'application' && protocol === 'DTLS/SCTP') || rejected) {\n        // TODO: this is dangerous in the case where a non-rejected m-line\n        //     becomes rejected.\n        pc.transceivers[sdpMLineIndex] = {\n          mid: mid,\n          kind: kind,\n          rejected: true\n        };\n        return;\n      }\n\n      if (!rejected && pc.transceivers[sdpMLineIndex] &&\n          pc.transceivers[sdpMLineIndex].rejected) {\n        // recycle a rejected transceiver.\n        pc.transceivers[sdpMLineIndex] = pc._createTransceiver(kind, true);\n      }\n\n      var transceiver;\n      var iceGatherer;\n      var iceTransport;\n      var dtlsTransport;\n      var rtpReceiver;\n      var sendEncodingParameters;\n      var recvEncodingParameters;\n      var localCapabilities;\n\n      var track;\n      // FIXME: ensure the mediaSection has rtcp-mux set.\n      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n      var remoteIceParameters;\n      var remoteDtlsParameters;\n      if (!rejected) {\n        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters.role = 'client';\n      }\n      recvEncodingParameters =\n          SDPUtils.parseRtpEncodingParameters(mediaSection);\n\n      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);\n\n      var isComplete = SDPUtils.matchPrefix(mediaSection,\n          'a=end-of-candidates', sessionpart).length > 0;\n      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\n          .map(function(cand) {\n            return SDPUtils.parseCandidate(cand);\n          })\n          .filter(function(cand) {\n            return cand.component === 1;\n          });\n\n      // Check if we can use BUNDLE and dispose transports.\n      if ((description.type === 'offer' || description.type === 'answer') &&\n          !rejected && usingBundle && sdpMLineIndex > 0 &&\n          pc.transceivers[sdpMLineIndex]) {\n        pc._disposeIceAndDtlsTransports(sdpMLineIndex);\n        pc.transceivers[sdpMLineIndex].iceGatherer =\n            pc.transceivers[0].iceGatherer;\n        pc.transceivers[sdpMLineIndex].iceTransport =\n            pc.transceivers[0].iceTransport;\n        pc.transceivers[sdpMLineIndex].dtlsTransport =\n            pc.transceivers[0].dtlsTransport;\n        if (pc.transceivers[sdpMLineIndex].rtpSender) {\n          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {\n          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n      }\n      if (description.type === 'offer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex] ||\n            pc._createTransceiver(kind);\n        transceiver.mid = mid;\n\n        if (!transceiver.iceGatherer) {\n          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n              usingBundle);\n        }\n\n        if (cands.length && transceiver.iceTransport.state === 'new') {\n          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {\n            transceiver.iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);\n\n        // filter RTX until additional stuff needed for RTX is implemented\n        // in adapter.js\n        if (edgeVersion < 15019) {\n          localCapabilities.codecs = localCapabilities.codecs.filter(\n              function(codec) {\n                return codec.name !== 'rtx';\n              });\n        }\n\n        sendEncodingParameters = transceiver.sendEncodingParameters || [{\n          ssrc: (2 * sdpMLineIndex + 2) * 1001\n        }];\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        var isNewTrack = false;\n        if (direction === 'sendrecv' || direction === 'sendonly') {\n          isNewTrack = !transceiver.rtpReceiver;\n          rtpReceiver = transceiver.rtpReceiver ||\n              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);\n\n          if (isNewTrack) {\n            var stream;\n            track = rtpReceiver.track;\n            // FIXME: does not work with Plan B.\n            if (remoteMsid && remoteMsid.stream === '-') {\n              // no-op. a stream id of '-' means: no associated stream.\n            } else if (remoteMsid) {\n              if (!streams[remoteMsid.stream]) {\n                streams[remoteMsid.stream] = new window.MediaStream();\n                Object.defineProperty(streams[remoteMsid.stream], 'id', {\n                  get: function() {\n                    return remoteMsid.stream;\n                  }\n                });\n              }\n              Object.defineProperty(track, 'id', {\n                get: function() {\n                  return remoteMsid.track;\n                }\n              });\n              stream = streams[remoteMsid.stream];\n            } else {\n              if (!streams.default) {\n                streams.default = new window.MediaStream();\n              }\n              stream = streams.default;\n            }\n            if (stream) {\n              addTrackToStreamAndFireEvent(track, stream);\n              transceiver.associatedRemoteMediaStreams.push(stream);\n            }\n            receiverList.push([track, rtpReceiver, stream]);\n          }\n        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {\n          transceiver.associatedRemoteMediaStreams.forEach(function(s) {\n            var nativeTrack = s.getTracks().find(function(t) {\n              return t.id === transceiver.rtpReceiver.track.id;\n            });\n            if (nativeTrack) {\n              removeTrackFromStreamAndFireEvent(nativeTrack, s);\n            }\n          });\n          transceiver.associatedRemoteMediaStreams = [];\n        }\n\n        transceiver.localCapabilities = localCapabilities;\n        transceiver.remoteCapabilities = remoteCapabilities;\n        transceiver.rtpReceiver = rtpReceiver;\n        transceiver.rtcpParameters = rtcpParameters;\n        transceiver.sendEncodingParameters = sendEncodingParameters;\n        transceiver.recvEncodingParameters = recvEncodingParameters;\n\n        // Start the RTCRtpReceiver now. The RTPSender is started in\n        // setLocalDescription.\n        pc._transceive(pc.transceivers[sdpMLineIndex],\n            false,\n            isNewTrack);\n      } else if (description.type === 'answer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex];\n        iceGatherer = transceiver.iceGatherer;\n        iceTransport = transceiver.iceTransport;\n        dtlsTransport = transceiver.dtlsTransport;\n        rtpReceiver = transceiver.rtpReceiver;\n        sendEncodingParameters = transceiver.sendEncodingParameters;\n        localCapabilities = transceiver.localCapabilities;\n\n        pc.transceivers[sdpMLineIndex].recvEncodingParameters =\n            recvEncodingParameters;\n        pc.transceivers[sdpMLineIndex].remoteCapabilities =\n            remoteCapabilities;\n        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;\n\n        if (cands.length && iceTransport.state === 'new') {\n          if ((isIceLite || isComplete) &&\n              (!usingBundle || sdpMLineIndex === 0)) {\n            iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        if (!usingBundle || sdpMLineIndex === 0) {\n          if (iceTransport.state === 'new') {\n            iceTransport.start(iceGatherer, remoteIceParameters,\n                'controlling');\n          }\n          if (dtlsTransport.state === 'new') {\n            dtlsTransport.start(remoteDtlsParameters);\n          }\n        }\n\n        pc._transceive(transceiver,\n            direction === 'sendrecv' || direction === 'recvonly',\n            direction === 'sendrecv' || direction === 'sendonly');\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        if (rtpReceiver &&\n            (direction === 'sendrecv' || direction === 'sendonly')) {\n          track = rtpReceiver.track;\n          if (remoteMsid) {\n            if (!streams[remoteMsid.stream]) {\n              streams[remoteMsid.stream] = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\n          } else {\n            if (!streams.default) {\n              streams.default = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams.default);\n            receiverList.push([track, rtpReceiver, streams.default]);\n          }\n        } else {\n          // FIXME: actually the receiver should be created later.\n          delete transceiver.rtpReceiver;\n        }\n      }\n    });\n\n    if (pc._dtlsRole === undefined) {\n      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';\n    }\n\n    pc.remoteDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-remote-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n    Object.keys(streams).forEach(function(sid) {\n      var stream = streams[sid];\n      if (stream.getTracks().length) {\n        if (pc.remoteStreams.indexOf(stream) === -1) {\n          pc.remoteStreams.push(stream);\n          var event = new Event('addstream');\n          event.stream = stream;\n          window.setTimeout(function() {\n            pc._dispatchEvent('addstream', event);\n          });\n        }\n\n        receiverList.forEach(function(item) {\n          var track = item[0];\n          var receiver = item[1];\n          if (stream.id !== item[2].id) {\n            return;\n          }\n          fireAddTrack(pc, track, receiver, [stream]);\n        });\n      }\n    });\n    receiverList.forEach(function(item) {\n      if (item[2]) {\n        return;\n      }\n      fireAddTrack(pc, item[0], item[1], []);\n    });\n\n    // check whether addIceCandidate({}) was called within four seconds after\n    // setRemoteDescription.\n    window.setTimeout(function() {\n      if (!(pc && pc.transceivers)) {\n        return;\n      }\n      pc.transceivers.forEach(function(transceiver) {\n        if (transceiver.iceTransport &&\n            transceiver.iceTransport.state === 'new' &&\n            transceiver.iceTransport.getRemoteCandidates().length > 0) {\n          console.warn('Timeout for addRemoteCandidate. Consider sending ' +\n              'an end-of-candidates notification');\n          transceiver.iceTransport.addRemoteCandidate({});\n        }\n      });\n    }, 4000);\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.close = function() {\n    this.transceivers.forEach(function(transceiver) {\n      /* not yet\n      if (transceiver.iceGatherer) {\n        transceiver.iceGatherer.close();\n      }\n      */\n      if (transceiver.iceTransport) {\n        transceiver.iceTransport.stop();\n      }\n      if (transceiver.dtlsTransport) {\n        transceiver.dtlsTransport.stop();\n      }\n      if (transceiver.rtpSender) {\n        transceiver.rtpSender.stop();\n      }\n      if (transceiver.rtpReceiver) {\n        transceiver.rtpReceiver.stop();\n      }\n    });\n    // FIXME: clean up tracks, local streams, remote streams, etc\n    this._isClosed = true;\n    this._updateSignalingState('closed');\n  };\n\n  // Update the signaling state.\n  RTCPeerConnection.prototype._updateSignalingState = function(newState) {\n    this.signalingState = newState;\n    var event = new Event('signalingstatechange');\n    this._dispatchEvent('signalingstatechange', event);\n  };\n\n  // Determine whether to fire the negotiationneeded event.\n  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {\n    var pc = this;\n    if (this.signalingState !== 'stable' || this.needNegotiation === true) {\n      return;\n    }\n    this.needNegotiation = true;\n    window.setTimeout(function() {\n      if (pc.needNegotiation) {\n        pc.needNegotiation = false;\n        var event = new Event('negotiationneeded');\n        pc._dispatchEvent('negotiationneeded', event);\n      }\n    }, 0);\n  };\n\n  // Update the ice connection state.\n  RTCPeerConnection.prototype._updateIceConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      checking: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      states[transceiver.iceTransport.state]++;\n    });\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.checking > 0) {\n      newState = 'checking';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    } else if (states.completed > 0) {\n      newState = 'completed';\n    }\n\n    if (newState !== this.iceConnectionState) {\n      this.iceConnectionState = newState;\n      var event = new Event('iceconnectionstatechange');\n      this._dispatchEvent('iceconnectionstatechange', event);\n    }\n  };\n\n  // Update the connection state.\n  RTCPeerConnection.prototype._updateConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      connecting: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      states[transceiver.iceTransport.state]++;\n      states[transceiver.dtlsTransport.state]++;\n    });\n    // ICETransport.completed and connected are the same for this purpose.\n    states.connected += states.completed;\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.connecting > 0) {\n      newState = 'connecting';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0) {\n      newState = 'connected';\n    }\n\n    if (newState !== this.connectionState) {\n      this.connectionState = newState;\n      var event = new Event('connectionstatechange');\n      this._dispatchEvent('connectionstatechange', event);\n    }\n  };\n\n  RTCPeerConnection.prototype.createOffer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createOffer after close'));\n    }\n\n    var numAudioTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'audio';\n    }).length;\n    var numVideoTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'video';\n    }).length;\n\n    // Determine number of audio and video tracks we need to send/recv.\n    var offerOptions = arguments[0];\n    if (offerOptions) {\n      // Reject Chrome legacy constraints.\n      if (offerOptions.mandatory || offerOptions.optional) {\n        throw new TypeError(\n            'Legacy mandatory/optional constraints not supported.');\n      }\n      if (offerOptions.offerToReceiveAudio !== undefined) {\n        if (offerOptions.offerToReceiveAudio === true) {\n          numAudioTracks = 1;\n        } else if (offerOptions.offerToReceiveAudio === false) {\n          numAudioTracks = 0;\n        } else {\n          numAudioTracks = offerOptions.offerToReceiveAudio;\n        }\n      }\n      if (offerOptions.offerToReceiveVideo !== undefined) {\n        if (offerOptions.offerToReceiveVideo === true) {\n          numVideoTracks = 1;\n        } else if (offerOptions.offerToReceiveVideo === false) {\n          numVideoTracks = 0;\n        } else {\n          numVideoTracks = offerOptions.offerToReceiveVideo;\n        }\n      }\n    }\n\n    pc.transceivers.forEach(function(transceiver) {\n      if (transceiver.kind === 'audio') {\n        numAudioTracks--;\n        if (numAudioTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      } else if (transceiver.kind === 'video') {\n        numVideoTracks--;\n        if (numVideoTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      }\n    });\n\n    // Create M-lines for recvonly streams.\n    while (numAudioTracks > 0 || numVideoTracks > 0) {\n      if (numAudioTracks > 0) {\n        pc._createTransceiver('audio');\n        numAudioTracks--;\n      }\n      if (numVideoTracks > 0) {\n        pc._createTransceiver('video');\n        numVideoTracks--;\n      }\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      // For each track, create an ice gatherer, ice transport,\n      // dtls transport, potentially rtpsender and rtpreceiver.\n      var track = transceiver.track;\n      var kind = transceiver.kind;\n      var mid = transceiver.mid || SDPUtils.generateIdentifier();\n      transceiver.mid = mid;\n\n      if (!transceiver.iceGatherer) {\n        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n            pc.usingBundle);\n      }\n\n      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);\n      // filter RTX until additional stuff needed for RTX is implemented\n      // in adapter.js\n      if (edgeVersion < 15019) {\n        localCapabilities.codecs = localCapabilities.codecs.filter(\n            function(codec) {\n              return codec.name !== 'rtx';\n            });\n      }\n      localCapabilities.codecs.forEach(function(codec) {\n        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552\n        // by adding level-asymmetry-allowed=1\n        if (codec.name === 'H264' &&\n            codec.parameters['level-asymmetry-allowed'] === undefined) {\n          codec.parameters['level-asymmetry-allowed'] = '1';\n        }\n\n        // for subsequent offers, we might have to re-use the payload\n        // type of the last offer.\n        if (transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.codecs) {\n          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {\n            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&\n                codec.clockRate === remoteCodec.clockRate) {\n              codec.preferredPayloadType = remoteCodec.payloadType;\n            }\n          });\n        }\n      });\n      localCapabilities.headerExtensions.forEach(function(hdrExt) {\n        var remoteExtensions = transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.headerExtensions || [];\n        remoteExtensions.forEach(function(rHdrExt) {\n          if (hdrExt.uri === rHdrExt.uri) {\n            hdrExt.id = rHdrExt.id;\n          }\n        });\n      });\n\n      // generate an ssrc now, to be used later in rtpSender.send\n      var sendEncodingParameters = transceiver.sendEncodingParameters || [{\n        ssrc: (2 * sdpMLineIndex + 1) * 1001\n      }];\n      if (track) {\n        // add RTX\n        if (edgeVersion >= 15019 && kind === 'video' &&\n            !sendEncodingParameters[0].rtx) {\n          sendEncodingParameters[0].rtx = {\n            ssrc: sendEncodingParameters[0].ssrc + 1\n          };\n        }\n      }\n\n      if (transceiver.wantReceive) {\n        transceiver.rtpReceiver = new window.RTCRtpReceiver(\n            transceiver.dtlsTransport, kind);\n      }\n\n      transceiver.localCapabilities = localCapabilities;\n      transceiver.sendEncodingParameters = sendEncodingParameters;\n    });\n\n    // always offer BUNDLE and dispose on return if not supported.\n    if (pc._config.bundlePolicy !== 'max-compat') {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,\n          'offer', transceiver.stream, pc._dtlsRole);\n      sdp += 'a=rtcp-rsize\\r\\n';\n\n      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&\n          (sdpMLineIndex === 0 || !pc.usingBundle)) {\n        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {\n          cand.component = 1;\n          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\\r\\n';\n        });\n\n        if (transceiver.iceGatherer.state === 'completed') {\n          sdp += 'a=end-of-candidates\\r\\n';\n        }\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'offer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.createAnswer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer after close'));\n    }\n\n    if (!(pc.signalingState === 'have-remote-offer' ||\n        pc.signalingState === 'have-local-pranswer')) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer in signalingState ' + pc.signalingState));\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    if (pc.usingBundle) {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    var mediaSectionsInOffer = SDPUtils.getMediaSections(\n        pc.remoteDescription.sdp).length;\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {\n        return;\n      }\n      if (transceiver.rejected) {\n        if (transceiver.kind === 'application') {\n          sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n';\n        } else if (transceiver.kind === 'audio') {\n          sdp += 'm=audio 0 UDP/TLS/RTP/SAVPF 0\\r\\n' +\n              'a=rtpmap:0 PCMU/8000\\r\\n';\n        } else if (transceiver.kind === 'video') {\n          sdp += 'm=video 0 UDP/TLS/RTP/SAVPF 120\\r\\n' +\n              'a=rtpmap:120 VP8/90000\\r\\n';\n        }\n        sdp += 'c=IN IP4 0.0.0.0\\r\\n' +\n            'a=inactive\\r\\n' +\n            'a=mid:' + transceiver.mid + '\\r\\n';\n        return;\n      }\n\n      // FIXME: look at direction.\n      if (transceiver.stream) {\n        var localTrack;\n        if (transceiver.kind === 'audio') {\n          localTrack = transceiver.stream.getAudioTracks()[0];\n        } else if (transceiver.kind === 'video') {\n          localTrack = transceiver.stream.getVideoTracks()[0];\n        }\n        if (localTrack) {\n          // add RTX\n          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&\n              !transceiver.sendEncodingParameters[0].rtx) {\n            transceiver.sendEncodingParameters[0].rtx = {\n              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1\n            };\n          }\n        }\n      }\n\n      // Calculate intersection of capabilities.\n      var commonCapabilities = getCommonCapabilities(\n          transceiver.localCapabilities,\n          transceiver.remoteCapabilities);\n\n      var hasRtx = commonCapabilities.codecs.filter(function(c) {\n        return c.name.toLowerCase() === 'rtx';\n      }).length;\n      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n        delete transceiver.sendEncodingParameters[0].rtx;\n      }\n\n      sdp += writeMediaSection(transceiver, commonCapabilities,\n          'answer', transceiver.stream, pc._dtlsRole);\n      if (transceiver.rtcpParameters &&\n          transceiver.rtcpParameters.reducedSize) {\n        sdp += 'a=rtcp-rsize\\r\\n';\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'answer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\n    var pc = this;\n    var sections;\n    if (candidate && !(candidate.sdpMLineIndex !== undefined ||\n        candidate.sdpMid)) {\n      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));\n    }\n\n    // TODO: needs to go into ops queue.\n    return new Promise(function(resolve, reject) {\n      if (!pc.remoteDescription) {\n        return reject(makeError('InvalidStateError',\n            'Can not add ICE candidate without a remote description'));\n      } else if (!candidate || candidate.candidate === '') {\n        for (var j = 0; j < pc.transceivers.length; j++) {\n          if (pc.transceivers[j].rejected) {\n            continue;\n          }\n          pc.transceivers[j].iceTransport.addRemoteCandidate({});\n          sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);\n          sections[j] += 'a=end-of-candidates\\r\\n';\n          pc.remoteDescription.sdp =\n              SDPUtils.getDescription(pc.remoteDescription.sdp) +\n              sections.join('');\n          if (pc.usingBundle) {\n            break;\n          }\n        }\n      } else {\n        var sdpMLineIndex = candidate.sdpMLineIndex;\n        if (candidate.sdpMid) {\n          for (var i = 0; i < pc.transceivers.length; i++) {\n            if (pc.transceivers[i].mid === candidate.sdpMid) {\n              sdpMLineIndex = i;\n              break;\n            }\n          }\n        }\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        if (transceiver) {\n          if (transceiver.rejected) {\n            return resolve();\n          }\n          var cand = Object.keys(candidate.candidate).length > 0 ?\n              SDPUtils.parseCandidate(candidate.candidate) : {};\n          // Ignore Chrome's invalid candidates since Edge does not like them.\n          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\n            return resolve();\n          }\n          // Ignore RTCP candidates, we assume RTCP-MUX.\n          if (cand.component && cand.component !== 1) {\n            return resolve();\n          }\n          // when using bundle, avoid adding candidates to the wrong\n          // ice transport. And avoid adding candidates added in the SDP.\n          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&\n              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {\n            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {\n              return reject(makeError('OperationError',\n                  'Can not add ICE candidate'));\n            }\n          }\n\n          // update the remoteDescription.\n          var candidateString = candidate.candidate.trim();\n          if (candidateString.indexOf('a=') === 0) {\n            candidateString = candidateString.substr(2);\n          }\n          sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);\n          sections[sdpMLineIndex] += 'a=' +\n              (cand.type ? candidateString : 'end-of-candidates')\n              + '\\r\\n';\n          pc.remoteDescription.sdp =\n              SDPUtils.getDescription(pc.remoteDescription.sdp) +\n              sections.join('');\n        } else {\n          return reject(makeError('OperationError',\n              'Can not add ICE candidate'));\n        }\n      }\n      resolve();\n    });\n  };\n\n  RTCPeerConnection.prototype.getStats = function() {\n    var promises = [];\n    this.transceivers.forEach(function(transceiver) {\n      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\n          'dtlsTransport'].forEach(function(method) {\n            if (transceiver[method]) {\n              promises.push(transceiver[method].getStats());\n            }\n          });\n    });\n    var fixStatsType = function(stat) {\n      return {\n        inboundrtp: 'inbound-rtp',\n        outboundrtp: 'outbound-rtp',\n        candidatepair: 'candidate-pair',\n        localcandidate: 'local-candidate',\n        remotecandidate: 'remote-candidate'\n      }[stat.type] || stat.type;\n    };\n    return new Promise(function(resolve) {\n      // shim getStats with maplike support\n      var results = new Map();\n      Promise.all(promises).then(function(res) {\n        res.forEach(function(result) {\n          Object.keys(result).forEach(function(id) {\n            result[id].type = fixStatsType(result[id]);\n            results.set(id, result[id]);\n          });\n        });\n        resolve(results);\n      });\n    });\n  };\n\n  // legacy callback shims. Should be moved to adapter.js some days.\n  var methods = ['createOffer', 'createAnswer'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[0] === 'function' ||\n          typeof args[1] === 'function') { // legacy\n        return nativeMethod.apply(this, [arguments[2]])\n        .then(function(description) {\n          if (typeof args[0] === 'function') {\n            args[0].apply(null, [description]);\n          }\n        }, function(error) {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function' ||\n          typeof args[2] === 'function') { // legacy\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        }, function(error) {\n          if (typeof args[2] === 'function') {\n            args[2].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  // getStats is special. It doesn't have a spec legacy method yet we support\n  // getStats(something, cb) without error callbacks.\n  ['getStats'].forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function') {\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  return RTCPeerConnection;\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js?");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/grammar.js":
/*!***************************************************!*\
  !*** ./node_modules/sdp-transform/lib/grammar.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var grammar = module.exports = {\n  v: [{\n    name: 'version',\n    reg: /^(\\d*)$/\n  }],\n  o: [{ //o=- 20518 0 IN IP4 203.0.113.1\n    // NB: sessionId will be a String in most cases because it is huge\n    name: 'origin',\n    reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],\n    format: '%s %s %d %s IP%d %s'\n  }],\n  // default parsing of these only (though some of these feel outdated)\n  s: [{ name: 'name' }],\n  i: [{ name: 'description' }],\n  u: [{ name: 'uri' }],\n  e: [{ name: 'email' }],\n  p: [{ name: 'phone' }],\n  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..\n  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly\n  //k: [{}], // outdated thing ignored\n  t: [{ //t=0 0\n    name: 'timing',\n    reg: /^(\\d*) (\\d*)/,\n    names: ['start', 'stop'],\n    format: '%d %d'\n  }],\n  c: [{ //c=IN IP4 10.47.197.26\n    name: 'connection',\n    reg: /^IN IP(\\d) (\\S*)/,\n    names: ['version', 'ip'],\n    format: 'IN IP%d %s'\n  }],\n  b: [{ //b=AS:4000\n    push: 'bandwidth',\n    reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n    names: ['type', 'limit'],\n    format: '%s:%s'\n  }],\n  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31\n    // NB: special - pushes to session\n    // TODO: rtp/fmtp should be filtered by the payloads found here?\n    reg: /^(\\w*) (\\d*) ([\\w\\/]*)(?: (.*))?/,\n    names: ['type', 'port', 'protocol', 'payloads'],\n    format: '%s %d %s %s'\n  }],\n  a: [\n    { //a=rtpmap:110 opus/48000/2\n      push: 'rtp',\n      reg: /^rtpmap:(\\d*) ([\\w\\-\\.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n      names: ['payload', 'codec', 'rate', 'encoding'],\n      format: function (o) {\n        return (o.encoding) ?\n          'rtpmap:%d %s/%s/%s':\n          o.rate ?\n          'rtpmap:%d %s/%s':\n          'rtpmap:%d %s';\n      }\n    },\n    { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n      //a=fmtp:111 minptime=10; useinbandfec=1\n      push: 'fmtp',\n      reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n      names: ['payload', 'config'],\n      format: 'fmtp:%d %s'\n    },\n    { //a=control:streamid=0\n      name: 'control',\n      reg: /^control:(.*)/,\n      format: 'control:%s'\n    },\n    { //a=rtcp:65179 IN IP4 193.84.77.194\n      name: 'rtcp',\n      reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n      names: ['port', 'netType', 'ipVer', 'address'],\n      format: function (o) {\n        return (o.address != null) ?\n          'rtcp:%d %s IP%d %s':\n          'rtcp:%d';\n      }\n    },\n    { //a=rtcp-fb:98 trr-int 100\n      push: 'rtcpFbTrrInt',\n      reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n      names: ['payload', 'value'],\n      format: 'rtcp-fb:%d trr-int %d'\n    },\n    { //a=rtcp-fb:98 nack rpsi\n      push: 'rtcpFb',\n      reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n      names: ['payload', 'type', 'subtype'],\n      format: function (o) {\n        return (o.subtype != null) ?\n          'rtcp-fb:%s %s %s':\n          'rtcp-fb:%s %s';\n      }\n    },\n    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n      //a=extmap:1/recvonly URI-gps-string\n      push: 'ext',\n      reg: /^extmap:(\\d+)(?:\\/(\\w+))? (\\S*)(?: (\\S*))?/,\n      names: ['value', 'direction', 'uri', 'config'],\n      format: function (o) {\n        return 'extmap:%d' + (o.direction ? '/%s' : '%v') + ' %s' + (o.config ? ' %s' : '');\n      }\n    },\n    { //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n      push: 'crypto',\n      reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n      names: ['id', 'suite', 'config', 'sessionConfig'],\n      format: function (o) {\n        return (o.sessionConfig != null) ?\n          'crypto:%d %s %s %s':\n          'crypto:%d %s %s';\n      }\n    },\n    { //a=setup:actpass\n      name: 'setup',\n      reg: /^setup:(\\w*)/,\n      format: 'setup:%s'\n    },\n    { //a=mid:1\n      name: 'mid',\n      reg: /^mid:([^\\s]*)/,\n      format: 'mid:%s'\n    },\n    { //a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n      name: 'msid',\n      reg: /^msid:(.*)/,\n      format: 'msid:%s'\n    },\n    { //a=ptime:20\n      name: 'ptime',\n      reg: /^ptime:(\\d*)/,\n      format: 'ptime:%d'\n    },\n    { //a=maxptime:60\n      name: 'maxptime',\n      reg: /^maxptime:(\\d*)/,\n      format: 'maxptime:%d'\n    },\n    { //a=sendrecv\n      name: 'direction',\n      reg: /^(sendrecv|recvonly|sendonly|inactive)/\n    },\n    { //a=ice-lite\n      name: 'icelite',\n      reg: /^(ice-lite)/\n    },\n    { //a=ice-ufrag:F7gI\n      name: 'iceUfrag',\n      reg: /^ice-ufrag:(\\S*)/,\n      format: 'ice-ufrag:%s'\n    },\n    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n      name: 'icePwd',\n      reg: /^ice-pwd:(\\S*)/,\n      format: 'ice-pwd:%s'\n    },\n    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n      name: 'fingerprint',\n      reg: /^fingerprint:(\\S*) (\\S*)/,\n      names: ['type', 'hash'],\n      format: 'fingerprint:%s %s'\n    },\n    { //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n      //a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n      //a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n      push:'candidates',\n      reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],\n      format: function (o) {\n        var str = 'candidate:%s %d %s %d %s %d typ %s';\n\n        str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';\n\n        // NB: candidate has three optional chunks, so %void middles one if it's missing\n        str += (o.tcptype != null) ? ' tcptype %s' : '%v';\n\n        if (o.generation != null) {\n          str += ' generation %d';\n        }\n\n        str += (o['network-id'] != null) ? ' network-id %d' : '%v';\n        str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';\n        return str;\n      }\n    },\n    { //a=end-of-candidates (keep after the candidates line for readability)\n      name: 'endOfCandidates',\n      reg: /^(end-of-candidates)/\n    },\n    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n      name: 'remoteCandidates',\n      reg: /^remote-candidates:(.*)/,\n      format: 'remote-candidates:%s'\n    },\n    { //a=ice-options:google-ice\n      name: 'iceOptions',\n      reg: /^ice-options:(\\S*)/,\n      format: 'ice-options:%s'\n    },\n    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n      push: 'ssrcs',\n      reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n      names: ['id', 'attribute', 'value'],\n      format: function (o) {\n        var str = 'ssrc:%d';\n        if (o.attribute != null) {\n          str += ' %s';\n          if (o.value != null) {\n            str += ':%s';\n          }\n        }\n        return str;\n      }\n    },\n    { //a=ssrc-group:FEC 1 2\n      //a=ssrc-group:FEC-FR 3004364195 1080772241\n      push: 'ssrcGroups',\n      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n      reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n      names: ['semantics', 'ssrcs'],\n      format: 'ssrc-group:%s %s'\n    },\n    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n      name: 'msidSemantic',\n      reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n      names: ['semantic', 'token'],\n      format: 'msid-semantic: %s %s' // space after ':' is not accidental\n    },\n    { //a=group:BUNDLE audio video\n      push: 'groups',\n      reg: /^group:(\\w*) (.*)/,\n      names: ['type', 'mids'],\n      format: 'group:%s %s'\n    },\n    { //a=rtcp-mux\n      name: 'rtcpMux',\n      reg: /^(rtcp-mux)/\n    },\n    { //a=rtcp-rsize\n      name: 'rtcpRsize',\n      reg: /^(rtcp-rsize)/\n    },\n    { //a=sctpmap:5000 webrtc-datachannel 1024\n      name: 'sctpmap',\n      reg: /^sctpmap:([\\w_\\/]*) (\\S*)(?: (\\S*))?/,\n      names: ['sctpmapNumber', 'app', 'maxMessageSize'],\n      format: function (o) {\n        return (o.maxMessageSize != null) ?\n          'sctpmap:%s %s %s' :\n          'sctpmap:%s %s';\n      }\n    },\n    { //a=x-google-flag:conference\n      name: 'xGoogleFlag',\n      reg: /^x-google-flag:([^\\s]*)/,\n      format: 'x-google-flag:%s'\n    },\n    { //a=content:slides|main\n      name: 'content',\n      reg: /^content:([^\\s]*)/,\n      format: 'content:%s'\n    },\n    { //a=label:1\n      name: 'label',\n      reg: /^label:([\\d]*)/,\n      format: 'label:%d'\n    },\n    { //a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n      push: 'rids',\n      reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n      names: ['id', 'direction', 'params'],\n      format: function (o) {\n        return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';\n      }\n    },\n    { //a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n      //a=imageattr:* send [x=800,y=640] recv *\n      //a=imageattr:100 recv [x=320,y=240]\n      push: 'imageattrs',\n      reg: new RegExp(\n        //a=imageattr:97\n        '^imageattr:(\\\\d+|\\\\*)' +\n        //send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n        '[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)' +\n        //recv [x=330,y=250]\n        '(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?'\n      ),\n      names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],\n      format: function (o) {\n        return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    { //a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n      //a=simulcast:recv 1;4,5 send 6;7\n      name: 'simulcast',\n      reg: new RegExp(\n        //a=simulcast:\n        '^simulcast:' +\n        //send 1,2,3;~4,~5\n        '(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)' +\n        //space + recv 6;~7,~8\n        '(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?' +\n        //end\n        '$'\n      ),\n      names: ['dir1', 'list1', 'dir2', 'list2'],\n      format: function (o) {\n        return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');\n      }\n    },\n    { //Old simulcast draft 03 (implemented by Firefox)\n      //  https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n      //a=simulcast: recv pt=97;98 send pt=97\n      //a=simulcast: send rid=5;6;7 paused=6,7\n      name: 'simulcast_03',\n      reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n      names: ['value'],\n      format: 'simulcast: %s'\n    },\n    {\n      //a=framerate:25\n      //a=framerate:29.97\n      name: 'framerate',\n      reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n      format: 'framerate:%s'\n    },\n    { // RFC4570\n      //a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n      name: 'sourceFilter',\n      reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n      names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],\n      format: 'source-filter: %s %s %s %s %s'\n    },\n    { // any a= that we don't understand is kepts verbatim on media.invalid\n      push: 'invalid',\n      names: ['value']\n    }\n  ]\n};\n\n// set sensible defaults to avoid polluting the grammar with boring details\nObject.keys(grammar).forEach(function (key) {\n  var objs = grammar[key];\n  objs.forEach(function (obj) {\n    if (!obj.reg) {\n      obj.reg = /(.*)/;\n    }\n    if (!obj.format) {\n      obj.format = '%s';\n    }\n  });\n});\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/sdp-transform/lib/grammar.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/sdp-transform/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var parser = __webpack_require__(/*! ./parser */ \"./node_modules/sdp-transform/lib/parser.js\");\nvar writer = __webpack_require__(/*! ./writer */ \"./node_modules/sdp-transform/lib/writer.js\");\n\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseFmtpConfig = parser.parseFmtpConfig;\nexports.parseParams = parser.parseParams;\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/sdp-transform/lib/index.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/parser.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/parser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var toIntIfInt = function (v) {\n  return String(Number(v)) === v ? Number(v) : v;\n};\n\nvar attachProperties = function (match, location, names, rawName) {\n  if (rawName && !names) {\n    location[rawName] = toIntIfInt(match[1]);\n  }\n  else {\n    for (var i = 0; i < names.length; i += 1) {\n      if (match[i+1] != null) {\n        location[names[i]] = toIntIfInt(match[i+1]);\n      }\n    }\n  }\n};\n\nvar parseReg = function (obj, location, content) {\n  var needsBlank = obj.name && obj.names;\n  if (obj.push && !location[obj.push]) {\n    location[obj.push] = [];\n  }\n  else if (needsBlank && !location[obj.name]) {\n    location[obj.name] = {};\n  }\n  var keyLocation = obj.push ?\n    {} :  // blank object that will be pushed\n    needsBlank ? location[obj.name] : location; // otherwise, named location or root\n\n  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n\n  if (obj.push) {\n    location[obj.push].push(keyLocation);\n  }\n};\n\nvar grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\");\nvar validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n\nexports.parse = function (sdp) {\n  var session = {}\n    , media = []\n    , location = session; // points at where properties go under (one of the above)\n\n  // parse lines we understand\n  sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function (l) {\n    var type = l[0];\n    var content = l.slice(2);\n    if (type === 'm') {\n      media.push({rtp: [], fmtp: []});\n      location = media[media.length-1]; // point at latest media line\n    }\n\n    for (var j = 0; j < (grammar[type] || []).length; j += 1) {\n      var obj = grammar[type][j];\n      if (obj.reg.test(content)) {\n        return parseReg(obj, location, content);\n      }\n    }\n  });\n\n  session.media = media; // link it up\n  return session;\n};\n\nvar paramReducer = function (acc, expr) {\n  var s = expr.split(/=(.+)/, 2);\n  if (s.length === 2) {\n    acc[s[0]] = toIntIfInt(s[1]);\n  }\n  return acc;\n};\n\nexports.parseParams = function (str) {\n  return str.split(/\\;\\s?/).reduce(paramReducer, {});\n};\n\n// For backward compatibility - alias will be removed in 3.0.0\nexports.parseFmtpConfig = exports.parseParams;\n\nexports.parsePayloads = function (str) {\n  return str.split(' ').map(Number);\n};\n\nexports.parseRemoteCandidates = function (str) {\n  var candidates = [];\n  var parts = str.split(' ').map(toIntIfInt);\n  for (var i = 0; i < parts.length; i += 3) {\n    candidates.push({\n      component: parts[i],\n      ip: parts[i + 1],\n      port: parts[i + 2]\n    });\n  }\n  return candidates;\n};\n\nexports.parseImageAttributes = function (str) {\n  return str.split(' ').map(function (item) {\n    return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});\n  });\n};\n\nexports.parseSimulcastStreamList = function (str) {\n  return str.split(';').map(function (stream) {\n    return stream.split(',').map(function (format) {\n      var scid, paused = false;\n\n      if (format[0] !== '~') {\n        scid = toIntIfInt(format);\n      } else {\n        scid = toIntIfInt(format.substring(1, format.length));\n        paused = true;\n      }\n\n      return {\n        scid: scid,\n        paused: paused\n      };\n    });\n  });\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/sdp-transform/lib/parser.js?");

/***/ }),

/***/ "./node_modules/sdp-transform/lib/writer.js":
/*!**************************************************!*\
  !*** ./node_modules/sdp-transform/lib/writer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var grammar = __webpack_require__(/*! ./grammar */ \"./node_modules/sdp-transform/lib/grammar.js\");\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/sdp-transform/lib/writer.js?");

/***/ }),

/***/ "./node_modules/sdp/sdp.js":
/*!*********************************!*\
  !*** ./node_modules/sdp/sdp.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(" /* eslint-env node */\n\n\n// SDP helpers.\nvar SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(function(line) {\n    return line.trim();\n  });\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  var parts = blob.split('\\nm=');\n  return parts.map(function(part, index) {\n    return (index > 0 ? 'm=' + part : part).trim() + '\\r\\n';\n  });\n};\n\n// returns the session description.\nSDPUtils.getDescription = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(function(line) {\n    return line.indexOf(prefix) === 0;\n  });\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\nSDPUtils.parseCandidate = function(line) {\n  var parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  var candidate = {\n    foundation: parts[0],\n    component: parseInt(parts[1], 10),\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n\n  for (var i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compability.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag\n        candidate[parts[i]] = parts[i + 1];\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\nSDPUtils.writeCandidate = function(candidate) {\n  var sdp = [];\n  sdp.push(candidate.foundation);\n  sdp.push(candidate.component);\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.ip);\n  sdp.push(candidate.port);\n\n  var type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress); // was: relAddr\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort); // was: relPort\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substr(14).split(' ');\n}\n\n// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  var parts = line.substr(9).split(' ');\n  var parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  // was: channels\n  parsed.numChannels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  return parsed;\n};\n\n// Generate an a=rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (codec.numChannels !== 1 ? '/' + codec.numChannels : '') + '\\r\\n';\n};\n\n// Parses an a=extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  var parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1]\n  };\n};\n\n// Generates a=extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n          ? '/' + headerExtension.direction\n          : '') +\n      ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses an ftmp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  var parsed = {};\n  var kv;\n  var parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (var j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  var line = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    var params = [];\n    Object.keys(codec.parameters).forEach(function(param) {\n      params.push(param + '=' + codec.parameters[param]);\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  var parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n};\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  var lines = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(function(fb) {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses an RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  var sp = line.indexOf(' ');\n  var parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\n  };\n  var colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n}\n\nSDPUtils.parseFingerprint = function(line) {\n  var parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1]\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n      'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role.\n  // Note2: 'algorithm' is not case sensitive except in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  var sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(function(fp) {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  // Search in session part, too.\n  lines = lines.concat(SDPUtils.splitLines(sessionpart));\n  var iceParameters = {\n    usernameFragment: lines.filter(function(line) {\n      return line.indexOf('a=ice-ufrag:') === 0;\n    })[0].substr(12),\n    password: lines.filter(function(line) {\n      return line.indexOf('a=ice-pwd:') === 0;\n    })[0].substr(10)\n  };\n  return iceParameters;\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  var description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    var pt = mline[i];\n    var rtpmapline = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      var codec = SDPUtils.parseRtpMap(rtpmapline);\n      var fmtps = SDPUtils.matchPrefix(\n          mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n          mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  var sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(function(codec) {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(function(codec) {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  var maxptime = 0;\n  caps.codecs.forEach(function(codec) {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n  sdp += 'a=rtcp-mux\\r\\n';\n\n  caps.headerExtensions.forEach(function(extension) {\n    sdp += SDPUtils.writeExtmap(extension);\n  });\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  var encodingParameters = [];\n  var description = SDPUtils.parseRtpParameters(mediaSection);\n  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n  .map(function(line) {\n    return SDPUtils.parseSsrcMedia(line);\n  })\n  .filter(function(parts) {\n    return parts.attribute === 'cname';\n  });\n  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  var secondarySsrc;\n\n  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n  .map(function(line) {\n    var parts = line.split(' ');\n    parts.shift();\n    return parts.map(function(part) {\n      return parseInt(part, 10);\n    });\n  });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(function(codec) {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      var encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10),\n        rtx: {\n          ssrc: secondarySsrc\n        }\n      };\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: secondarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(function(params) {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  var rtcpParameters = {};\n\n  var cname;\n  // Gets the first SSRC. Note that with RTX there might be multiple\n  // SSRCs.\n  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n      .map(function(line) {\n        return SDPUtils.parseSsrcMedia(line);\n      })\n      .filter(function(obj) {\n        return obj.attribute === 'cname';\n      })[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrіbute.\n  // Note that Edge does not support unmuxed RTCP.\n  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  var parts;\n  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n  .map(function(line) {\n    return SDPUtils.parseSsrcMedia(line);\n  })\n  .filter(function(parts) {\n    return parts.attribute === 'msid';\n  });\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boilder plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer) {\n  var sessionId;\n  var version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=thisisadapterortc ' + sessionId + ' ' + version + ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\nSDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.direction) {\n    sdp += 'a=' + transceiver.direction + '\\r\\n';\n  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    // spec.\n    var msid = 'msid:' + stream.id + ' ' +\n        transceiver.rtpSender.track.id + '\\r\\n';\n    sdp += 'a=' + msid;\n\n    // for Chrome.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  var lines = SDPUtils.splitLines(mediaSection);\n  for (var i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  var parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5],\n  };\n}\n\n// Expose public methods.\nif (true) {\n  module.exports = SDPUtils;\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/sdp/sdp.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/socket.io-client/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * Module dependencies.\n */\n\nvar url = __webpack_require__(/*! ./url */ \"./node_modules/socket.io-client/lib/url.js\");\nvar parser = __webpack_require__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/index.js\");\nvar Manager = __webpack_require__(/*! ./manager */ \"./node_modules/socket.io-client/lib/manager.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/socket.io-client/node_modules/debug/src/index.js\")('socket.io-client');\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = lookup;\n\n/**\n * Managers cache.\n */\n\nvar cache = exports.managers = {};\n\n/**\n * Looks up an existing `Manager` for multiplexing.\n * If the user summons:\n *\n *   `io('http://localhost/a');`\n *   `io('http://localhost/b');`\n *\n * We reuse the existing instance based on same scheme/port/host,\n * and we initialize sockets for each namespace.\n *\n * @api public\n */\n\nfunction lookup (uri, opts) {\n  if (typeof uri === 'object') {\n    opts = uri;\n    uri = undefined;\n  }\n\n  opts = opts || {};\n\n  var parsed = url(uri);\n  var source = parsed.source;\n  var id = parsed.id;\n  var path = parsed.path;\n  var sameNamespace = cache[id] && path in cache[id].nsps;\n  var newConnection = opts.forceNew || opts['force new connection'] ||\n                      false === opts.multiplex || sameNamespace;\n\n  var io;\n\n  if (newConnection) {\n    debug('ignoring socket cache for %s', source);\n    io = Manager(source, opts);\n  } else {\n    if (!cache[id]) {\n      debug('new io instance for %s', source);\n      cache[id] = Manager(source, opts);\n    }\n    io = cache[id];\n  }\n  if (parsed.query && !opts.query) {\n    opts.query = parsed.query;\n  }\n  return io.socket(parsed.path, opts);\n}\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = parser.protocol;\n\n/**\n * `connect`.\n *\n * @param {String} uri\n * @api public\n */\n\nexports.connect = lookup;\n\n/**\n * Expose constructors for standalone build.\n *\n * @api public\n */\n\nexports.Manager = __webpack_require__(/*! ./manager */ \"./node_modules/socket.io-client/lib/manager.js\");\nexports.Socket = __webpack_require__(/*! ./socket */ \"./node_modules/socket.io-client/lib/socket.js\");\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/socket.io-client/lib/index.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/lib/manager.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-client/lib/manager.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * Module dependencies.\n */\n\nvar eio = __webpack_require__(/*! engine.io-client */ \"./node_modules/engine.io-client/lib/index.js\");\nvar Socket = __webpack_require__(/*! ./socket */ \"./node_modules/socket.io-client/lib/socket.js\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\nvar parser = __webpack_require__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/index.js\");\nvar on = __webpack_require__(/*! ./on */ \"./node_modules/socket.io-client/lib/on.js\");\nvar bind = __webpack_require__(/*! component-bind */ \"./node_modules/component-bind/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/socket.io-client/node_modules/debug/src/index.js\")('socket.io-client:manager');\nvar indexOf = __webpack_require__(/*! indexof */ \"./node_modules/indexof/index.js\");\nvar Backoff = __webpack_require__(/*! backo2 */ \"./node_modules/backo2/index.js\");\n\n/**\n * IE6+ hasOwnProperty\n */\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Module exports\n */\n\nmodule.exports = Manager;\n\n/**\n * `Manager` constructor.\n *\n * @param {String} engine instance or engine uri/opts\n * @param {Object} options\n * @api public\n */\n\nfunction Manager (uri, opts) {\n  if (!(this instanceof Manager)) return new Manager(uri, opts);\n  if (uri && ('object' === typeof uri)) {\n    opts = uri;\n    uri = undefined;\n  }\n  opts = opts || {};\n\n  opts.path = opts.path || '/socket.io';\n  this.nsps = {};\n  this.subs = [];\n  this.opts = opts;\n  this.reconnection(opts.reconnection !== false);\n  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n  this.reconnectionDelay(opts.reconnectionDelay || 1000);\n  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n  this.randomizationFactor(opts.randomizationFactor || 0.5);\n  this.backoff = new Backoff({\n    min: this.reconnectionDelay(),\n    max: this.reconnectionDelayMax(),\n    jitter: this.randomizationFactor()\n  });\n  this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n  this.readyState = 'closed';\n  this.uri = uri;\n  this.connecting = [];\n  this.lastPing = null;\n  this.encoding = false;\n  this.packetBuffer = [];\n  var _parser = opts.parser || parser;\n  this.encoder = new _parser.Encoder();\n  this.decoder = new _parser.Decoder();\n  this.autoConnect = opts.autoConnect !== false;\n  if (this.autoConnect) this.open();\n}\n\n/**\n * Propagate given event to sockets and emit on `this`\n *\n * @api private\n */\n\nManager.prototype.emitAll = function () {\n  this.emit.apply(this, arguments);\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);\n    }\n  }\n};\n\n/**\n * Update `socket.id` of all sockets\n *\n * @api private\n */\n\nManager.prototype.updateSocketIds = function () {\n  for (var nsp in this.nsps) {\n    if (has.call(this.nsps, nsp)) {\n      this.nsps[nsp].id = this.generateId(nsp);\n    }\n  }\n};\n\n/**\n * generate `socket.id` for the given `nsp`\n *\n * @param {String} nsp\n * @return {String}\n * @api private\n */\n\nManager.prototype.generateId = function (nsp) {\n  return (nsp === '/' ? '' : (nsp + '#')) + this.engine.id;\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Manager.prototype);\n\n/**\n * Sets the `reconnection` config.\n *\n * @param {Boolean} true/false if it should automatically reconnect\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnection = function (v) {\n  if (!arguments.length) return this._reconnection;\n  this._reconnection = !!v;\n  return this;\n};\n\n/**\n * Sets the reconnection attempts config.\n *\n * @param {Number} max reconnection attempts before giving up\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionAttempts = function (v) {\n  if (!arguments.length) return this._reconnectionAttempts;\n  this._reconnectionAttempts = v;\n  return this;\n};\n\n/**\n * Sets the delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelay = function (v) {\n  if (!arguments.length) return this._reconnectionDelay;\n  this._reconnectionDelay = v;\n  this.backoff && this.backoff.setMin(v);\n  return this;\n};\n\nManager.prototype.randomizationFactor = function (v) {\n  if (!arguments.length) return this._randomizationFactor;\n  this._randomizationFactor = v;\n  this.backoff && this.backoff.setJitter(v);\n  return this;\n};\n\n/**\n * Sets the maximum delay between reconnections.\n *\n * @param {Number} delay\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.reconnectionDelayMax = function (v) {\n  if (!arguments.length) return this._reconnectionDelayMax;\n  this._reconnectionDelayMax = v;\n  this.backoff && this.backoff.setMax(v);\n  return this;\n};\n\n/**\n * Sets the connection timeout. `false` to disable\n *\n * @return {Manager} self or value\n * @api public\n */\n\nManager.prototype.timeout = function (v) {\n  if (!arguments.length) return this._timeout;\n  this._timeout = v;\n  return this;\n};\n\n/**\n * Starts trying to reconnect if reconnection is enabled and we have not\n * started reconnecting yet\n *\n * @api private\n */\n\nManager.prototype.maybeReconnectOnOpen = function () {\n  // Only try to reconnect if it's the first time we're connecting\n  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {\n    // keeps reconnection from firing twice for the same reconnection loop\n    this.reconnect();\n  }\n};\n\n/**\n * Sets the current transport `socket`.\n *\n * @param {Function} optional, callback\n * @return {Manager} self\n * @api public\n */\n\nManager.prototype.open =\nManager.prototype.connect = function (fn, opts) {\n  debug('readyState %s', this.readyState);\n  if (~this.readyState.indexOf('open')) return this;\n\n  debug('opening %s', this.uri);\n  this.engine = eio(this.uri, this.opts);\n  var socket = this.engine;\n  var self = this;\n  this.readyState = 'opening';\n  this.skipReconnect = false;\n\n  // emit `open`\n  var openSub = on(socket, 'open', function () {\n    self.onopen();\n    fn && fn();\n  });\n\n  // emit `connect_error`\n  var errorSub = on(socket, 'error', function (data) {\n    debug('connect_error');\n    self.cleanup();\n    self.readyState = 'closed';\n    self.emitAll('connect_error', data);\n    if (fn) {\n      var err = new Error('Connection error');\n      err.data = data;\n      fn(err);\n    } else {\n      // Only do this if there is no fn to handle the error\n      self.maybeReconnectOnOpen();\n    }\n  });\n\n  // emit `connect_timeout`\n  if (false !== this._timeout) {\n    var timeout = this._timeout;\n    debug('connect attempt will timeout after %d', timeout);\n\n    // set timer\n    var timer = setTimeout(function () {\n      debug('connect attempt timed out after %d', timeout);\n      openSub.destroy();\n      socket.close();\n      socket.emit('error', 'timeout');\n      self.emitAll('connect_timeout', timeout);\n    }, timeout);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n\n  this.subs.push(openSub);\n  this.subs.push(errorSub);\n\n  return this;\n};\n\n/**\n * Called upon transport open.\n *\n * @api private\n */\n\nManager.prototype.onopen = function () {\n  debug('open');\n\n  // clear old subs\n  this.cleanup();\n\n  // mark as open\n  this.readyState = 'open';\n  this.emit('open');\n\n  // add new subs\n  var socket = this.engine;\n  this.subs.push(on(socket, 'data', bind(this, 'ondata')));\n  this.subs.push(on(socket, 'ping', bind(this, 'onping')));\n  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));\n  this.subs.push(on(socket, 'error', bind(this, 'onerror')));\n  this.subs.push(on(socket, 'close', bind(this, 'onclose')));\n  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));\n};\n\n/**\n * Called upon a ping.\n *\n * @api private\n */\n\nManager.prototype.onping = function () {\n  this.lastPing = new Date();\n  this.emitAll('ping');\n};\n\n/**\n * Called upon a packet.\n *\n * @api private\n */\n\nManager.prototype.onpong = function () {\n  this.emitAll('pong', new Date() - this.lastPing);\n};\n\n/**\n * Called with data.\n *\n * @api private\n */\n\nManager.prototype.ondata = function (data) {\n  this.decoder.add(data);\n};\n\n/**\n * Called when parser fully decodes a packet.\n *\n * @api private\n */\n\nManager.prototype.ondecoded = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon socket error.\n *\n * @api private\n */\n\nManager.prototype.onerror = function (err) {\n  debug('error', err);\n  this.emitAll('error', err);\n};\n\n/**\n * Creates a new socket for the given `nsp`.\n *\n * @return {Socket}\n * @api public\n */\n\nManager.prototype.socket = function (nsp, opts) {\n  var socket = this.nsps[nsp];\n  if (!socket) {\n    socket = new Socket(this, nsp, opts);\n    this.nsps[nsp] = socket;\n    var self = this;\n    socket.on('connecting', onConnecting);\n    socket.on('connect', function () {\n      socket.id = self.generateId(nsp);\n    });\n\n    if (this.autoConnect) {\n      // manually call here since connecting event is fired before listening\n      onConnecting();\n    }\n  }\n\n  function onConnecting () {\n    if (!~indexOf(self.connecting, socket)) {\n      self.connecting.push(socket);\n    }\n  }\n\n  return socket;\n};\n\n/**\n * Called upon a socket close.\n *\n * @param {Socket} socket\n */\n\nManager.prototype.destroy = function (socket) {\n  var index = indexOf(this.connecting, socket);\n  if (~index) this.connecting.splice(index, 1);\n  if (this.connecting.length) return;\n\n  this.close();\n};\n\n/**\n * Writes a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nManager.prototype.packet = function (packet) {\n  debug('writing packet %j', packet);\n  var self = this;\n  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;\n\n  if (!self.encoding) {\n    // encode, then write to engine with result\n    self.encoding = true;\n    this.encoder.encode(packet, function (encodedPackets) {\n      for (var i = 0; i < encodedPackets.length; i++) {\n        self.engine.write(encodedPackets[i], packet.options);\n      }\n      self.encoding = false;\n      self.processPacketQueue();\n    });\n  } else { // add packet to the queue\n    self.packetBuffer.push(packet);\n  }\n};\n\n/**\n * If packet buffer is non-empty, begins encoding the\n * next packet in line.\n *\n * @api private\n */\n\nManager.prototype.processPacketQueue = function () {\n  if (this.packetBuffer.length > 0 && !this.encoding) {\n    var pack = this.packetBuffer.shift();\n    this.packet(pack);\n  }\n};\n\n/**\n * Clean up transport subscriptions and packet buffer.\n *\n * @api private\n */\n\nManager.prototype.cleanup = function () {\n  debug('cleanup');\n\n  var subsLength = this.subs.length;\n  for (var i = 0; i < subsLength; i++) {\n    var sub = this.subs.shift();\n    sub.destroy();\n  }\n\n  this.packetBuffer = [];\n  this.encoding = false;\n  this.lastPing = null;\n\n  this.decoder.destroy();\n};\n\n/**\n * Close the current socket.\n *\n * @api private\n */\n\nManager.prototype.close =\nManager.prototype.disconnect = function () {\n  debug('disconnect');\n  this.skipReconnect = true;\n  this.reconnecting = false;\n  if ('opening' === this.readyState) {\n    // `onclose` will not fire because\n    // an open event never happened\n    this.cleanup();\n  }\n  this.backoff.reset();\n  this.readyState = 'closed';\n  if (this.engine) this.engine.close();\n};\n\n/**\n * Called upon engine close.\n *\n * @api private\n */\n\nManager.prototype.onclose = function (reason) {\n  debug('onclose');\n\n  this.cleanup();\n  this.backoff.reset();\n  this.readyState = 'closed';\n  this.emit('close', reason);\n\n  if (this._reconnection && !this.skipReconnect) {\n    this.reconnect();\n  }\n};\n\n/**\n * Attempt a reconnection.\n *\n * @api private\n */\n\nManager.prototype.reconnect = function () {\n  if (this.reconnecting || this.skipReconnect) return this;\n\n  var self = this;\n\n  if (this.backoff.attempts >= this._reconnectionAttempts) {\n    debug('reconnect failed');\n    this.backoff.reset();\n    this.emitAll('reconnect_failed');\n    this.reconnecting = false;\n  } else {\n    var delay = this.backoff.duration();\n    debug('will wait %dms before reconnect attempt', delay);\n\n    this.reconnecting = true;\n    var timer = setTimeout(function () {\n      if (self.skipReconnect) return;\n\n      debug('attempting reconnect');\n      self.emitAll('reconnect_attempt', self.backoff.attempts);\n      self.emitAll('reconnecting', self.backoff.attempts);\n\n      // check again for the case socket closed in above events\n      if (self.skipReconnect) return;\n\n      self.open(function (err) {\n        if (err) {\n          debug('reconnect attempt error');\n          self.reconnecting = false;\n          self.reconnect();\n          self.emitAll('reconnect_error', err.data);\n        } else {\n          debug('reconnect success');\n          self.onreconnect();\n        }\n      });\n    }, delay);\n\n    this.subs.push({\n      destroy: function () {\n        clearTimeout(timer);\n      }\n    });\n  }\n};\n\n/**\n * Called upon successful reconnect.\n *\n * @api private\n */\n\nManager.prototype.onreconnect = function () {\n  var attempt = this.backoff.attempts;\n  this.reconnecting = false;\n  this.backoff.reset();\n  this.updateSocketIds();\n  this.emitAll('reconnect', attempt);\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/socket.io-client/lib/manager.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/lib/on.js":
/*!*************************************************!*\
  !*** ./node_modules/socket.io-client/lib/on.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * Module exports.\n */\n\nmodule.exports = on;\n\n/**\n * Helper for subscriptions.\n *\n * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`\n * @param {String} event name\n * @param {Function} callback\n * @api public\n */\n\nfunction on (obj, ev, fn) {\n  obj.on(ev, fn);\n  return {\n    destroy: function () {\n      obj.removeListener(ev, fn);\n    }\n  };\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/socket.io-client/lib/on.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/lib/socket.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io-client/lib/socket.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * Module dependencies.\n */\n\nvar parser = __webpack_require__(/*! socket.io-parser */ \"./node_modules/socket.io-parser/index.js\");\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\nvar toArray = __webpack_require__(/*! to-array */ \"./node_modules/to-array/index.js\");\nvar on = __webpack_require__(/*! ./on */ \"./node_modules/socket.io-client/lib/on.js\");\nvar bind = __webpack_require__(/*! component-bind */ \"./node_modules/component-bind/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/socket.io-client/node_modules/debug/src/index.js\")('socket.io-client:socket');\nvar parseqs = __webpack_require__(/*! parseqs */ \"./node_modules/parseqs/index.js\");\n\n/**\n * Module exports.\n */\n\nmodule.exports = exports = Socket;\n\n/**\n * Internal events (blacklisted).\n * These events can't be emitted by the user.\n *\n * @api private\n */\n\nvar events = {\n  connect: 1,\n  connect_error: 1,\n  connect_timeout: 1,\n  connecting: 1,\n  disconnect: 1,\n  error: 1,\n  reconnect: 1,\n  reconnect_attempt: 1,\n  reconnect_failed: 1,\n  reconnect_error: 1,\n  reconnecting: 1,\n  ping: 1,\n  pong: 1\n};\n\n/**\n * Shortcut to `Emitter#emit`.\n */\n\nvar emit = Emitter.prototype.emit;\n\n/**\n * `Socket` constructor.\n *\n * @api public\n */\n\nfunction Socket (io, nsp, opts) {\n  this.io = io;\n  this.nsp = nsp;\n  this.json = this; // compat\n  this.ids = 0;\n  this.acks = {};\n  this.receiveBuffer = [];\n  this.sendBuffer = [];\n  this.connected = false;\n  this.disconnected = true;\n  if (opts && opts.query) {\n    this.query = opts.query;\n  }\n  if (this.io.autoConnect) this.open();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Subscribe to open, close and packet events\n *\n * @api private\n */\n\nSocket.prototype.subEvents = function () {\n  if (this.subs) return;\n\n  var io = this.io;\n  this.subs = [\n    on(io, 'open', bind(this, 'onopen')),\n    on(io, 'packet', bind(this, 'onpacket')),\n    on(io, 'close', bind(this, 'onclose'))\n  ];\n};\n\n/**\n * \"Opens\" the socket.\n *\n * @api public\n */\n\nSocket.prototype.open =\nSocket.prototype.connect = function () {\n  if (this.connected) return this;\n\n  this.subEvents();\n  this.io.open(); // ensure open\n  if ('open' === this.io.readyState) this.onopen();\n  this.emit('connecting');\n  return this;\n};\n\n/**\n * Sends a `message` event.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.send = function () {\n  var args = toArray(arguments);\n  args.unshift('message');\n  this.emit.apply(this, args);\n  return this;\n};\n\n/**\n * Override `emit`.\n * If the event is in `events`, it's emitted normally.\n *\n * @param {String} event name\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.emit = function (ev) {\n  if (events.hasOwnProperty(ev)) {\n    emit.apply(this, arguments);\n    return this;\n  }\n\n  var args = toArray(arguments);\n  var packet = { type: parser.EVENT, data: args };\n\n  packet.options = {};\n  packet.options.compress = !this.flags || false !== this.flags.compress;\n\n  // event ack callback\n  if ('function' === typeof args[args.length - 1]) {\n    debug('emitting packet with ack id %d', this.ids);\n    this.acks[this.ids] = args.pop();\n    packet.id = this.ids++;\n  }\n\n  if (this.connected) {\n    this.packet(packet);\n  } else {\n    this.sendBuffer.push(packet);\n  }\n\n  delete this.flags;\n\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.packet = function (packet) {\n  packet.nsp = this.nsp;\n  this.io.packet(packet);\n};\n\n/**\n * Called upon engine `open`.\n *\n * @api private\n */\n\nSocket.prototype.onopen = function () {\n  debug('transport is open - connecting');\n\n  // write connect packet if necessary\n  if ('/' !== this.nsp) {\n    if (this.query) {\n      var query = typeof this.query === 'object' ? parseqs.encode(this.query) : this.query;\n      debug('sending connect packet with query %s', query);\n      this.packet({type: parser.CONNECT, query: query});\n    } else {\n      this.packet({type: parser.CONNECT});\n    }\n  }\n};\n\n/**\n * Called upon engine `close`.\n *\n * @param {String} reason\n * @api private\n */\n\nSocket.prototype.onclose = function (reason) {\n  debug('close (%s)', reason);\n  this.connected = false;\n  this.disconnected = true;\n  delete this.id;\n  this.emit('disconnect', reason);\n};\n\n/**\n * Called with socket packet.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onpacket = function (packet) {\n  if (packet.nsp !== this.nsp) return;\n\n  switch (packet.type) {\n    case parser.CONNECT:\n      this.onconnect();\n      break;\n\n    case parser.EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.BINARY_EVENT:\n      this.onevent(packet);\n      break;\n\n    case parser.ACK:\n      this.onack(packet);\n      break;\n\n    case parser.BINARY_ACK:\n      this.onack(packet);\n      break;\n\n    case parser.DISCONNECT:\n      this.ondisconnect();\n      break;\n\n    case parser.ERROR:\n      this.emit('error', packet.data);\n      break;\n  }\n};\n\n/**\n * Called upon a server event.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onevent = function (packet) {\n  var args = packet.data || [];\n  debug('emitting event %j', args);\n\n  if (null != packet.id) {\n    debug('attaching ack callback to event');\n    args.push(this.ack(packet.id));\n  }\n\n  if (this.connected) {\n    emit.apply(this, args);\n  } else {\n    this.receiveBuffer.push(args);\n  }\n};\n\n/**\n * Produces an ack callback to emit with an event.\n *\n * @api private\n */\n\nSocket.prototype.ack = function (id) {\n  var self = this;\n  var sent = false;\n  return function () {\n    // prevent double callbacks\n    if (sent) return;\n    sent = true;\n    var args = toArray(arguments);\n    debug('sending ack %j', args);\n\n    self.packet({\n      type: parser.ACK,\n      id: id,\n      data: args\n    });\n  };\n};\n\n/**\n * Called upon a server acknowlegement.\n *\n * @param {Object} packet\n * @api private\n */\n\nSocket.prototype.onack = function (packet) {\n  var ack = this.acks[packet.id];\n  if ('function' === typeof ack) {\n    debug('calling ack %s with %j', packet.id, packet.data);\n    ack.apply(this, packet.data);\n    delete this.acks[packet.id];\n  } else {\n    debug('bad ack %s', packet.id);\n  }\n};\n\n/**\n * Called upon server connect.\n *\n * @api private\n */\n\nSocket.prototype.onconnect = function () {\n  this.connected = true;\n  this.disconnected = false;\n  this.emit('connect');\n  this.emitBuffered();\n};\n\n/**\n * Emit buffered events (received and emitted).\n *\n * @api private\n */\n\nSocket.prototype.emitBuffered = function () {\n  var i;\n  for (i = 0; i < this.receiveBuffer.length; i++) {\n    emit.apply(this, this.receiveBuffer[i]);\n  }\n  this.receiveBuffer = [];\n\n  for (i = 0; i < this.sendBuffer.length; i++) {\n    this.packet(this.sendBuffer[i]);\n  }\n  this.sendBuffer = [];\n};\n\n/**\n * Called upon server disconnect.\n *\n * @api private\n */\n\nSocket.prototype.ondisconnect = function () {\n  debug('server disconnect (%s)', this.nsp);\n  this.destroy();\n  this.onclose('io server disconnect');\n};\n\n/**\n * Called upon forced client/server side disconnections,\n * this method ensures the manager stops tracking us and\n * that reconnections don't get triggered for this.\n *\n * @api private.\n */\n\nSocket.prototype.destroy = function () {\n  if (this.subs) {\n    // clean subscriptions to avoid reconnections\n    for (var i = 0; i < this.subs.length; i++) {\n      this.subs[i].destroy();\n    }\n    this.subs = null;\n  }\n\n  this.io.destroy(this);\n};\n\n/**\n * Disconnects the socket manually.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.close =\nSocket.prototype.disconnect = function () {\n  if (this.connected) {\n    debug('performing disconnect (%s)', this.nsp);\n    this.packet({ type: parser.DISCONNECT });\n  }\n\n  // remove socket from pool\n  this.destroy();\n\n  if (this.connected) {\n    // fire events\n    this.onclose('io client disconnect');\n  }\n  return this;\n};\n\n/**\n * Sets the compress flag.\n *\n * @param {Boolean} if `true`, compresses the sending data\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.compress = function (compress) {\n  this.flags = this.flags || {};\n  this.flags.compress = compress;\n  return this;\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/socket.io-client/lib/socket.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/lib/url.js":
/*!**************************************************!*\
  !*** ./node_modules/socket.io-client/lib/url.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * Module dependencies.\n */\n\nvar parseuri = __webpack_require__(/*! parseuri */ \"./node_modules/parseuri/index.js\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/socket.io-client/node_modules/debug/src/index.js\")('socket.io-client:url');\n\n/**\n * Module exports.\n */\n\nmodule.exports = url;\n\n/**\n * URL parser.\n *\n * @param {String} url\n * @param {Object} An object meant to mimic window.location.\n *                 Defaults to window.location.\n * @api public\n */\n\nfunction url (uri, loc) {\n  var obj = uri;\n\n  // default to window.location\n  loc = loc || global.location;\n  if (null == uri) uri = loc.protocol + '//' + loc.host;\n\n  // relative path support\n  if ('string' === typeof uri) {\n    if ('/' === uri.charAt(0)) {\n      if ('/' === uri.charAt(1)) {\n        uri = loc.protocol + uri;\n      } else {\n        uri = loc.host + uri;\n      }\n    }\n\n    if (!/^(https?|wss?):\\/\\//.test(uri)) {\n      debug('protocol-less url %s', uri);\n      if ('undefined' !== typeof loc) {\n        uri = loc.protocol + '//' + uri;\n      } else {\n        uri = 'https://' + uri;\n      }\n    }\n\n    // parse\n    debug('parse %s', uri);\n    obj = parseuri(uri);\n  }\n\n  // make sure we treat `localhost:80` and `localhost` equally\n  if (!obj.port) {\n    if (/^(http|ws)$/.test(obj.protocol)) {\n      obj.port = '80';\n    } else if (/^(http|ws)s$/.test(obj.protocol)) {\n      obj.port = '443';\n    }\n  }\n\n  obj.path = obj.path || '/';\n\n  var ipv6 = obj.host.indexOf(':') !== -1;\n  var host = ipv6 ? '[' + obj.host + ']' : obj.host;\n\n  // define unique id\n  obj.id = obj.protocol + '://' + host + ':' + obj.port;\n  // define href\n  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));\n\n  return obj;\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/socket.io-client/lib/url.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/debug/src/browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/debug/src/browser.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/socket.io-client/node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/socket.io-client/node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/debug/src/debug.js":
/*!***********************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/debug/src/debug.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/socket.io-client/node_modules/debug/src/debug.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/debug/src/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/debug/src/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = __webpack_require__(/*! ./browser.js */ \"./node_modules/socket.io-client/node_modules/debug/src/browser.js\");\n} else {\n  module.exports = __webpack_require__(/*! ./node.js */ \"./node_modules/socket.io-client/node_modules/debug/src/node.js\");\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/socket.io-client/node_modules/debug/src/index.js?");

/***/ }),

/***/ "./node_modules/socket.io-client/node_modules/debug/src/node.js":
/*!**********************************************************************!*\
  !*** ./node_modules/socket.io-client/node_modules/debug/src/node.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar tty = __webpack_require__(/*! tty */ \"tty\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/socket.io-client/node_modules/debug/src/debug.js\");\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = __webpack_require__(/*! fs */ \"fs\");\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = __webpack_require__(/*! net */ \"net\");\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/socket.io-client/node_modules/debug/src/node.js?");

/***/ }),

/***/ "./node_modules/socket.io-parser/binary.js":
/*!*************************************************!*\
  !*** ./node_modules/socket.io-parser/binary.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/socket.io-parser/node_modules/isarray/index.js\");\nvar isBuf = __webpack_require__(/*! ./is-buffer */ \"./node_modules/socket.io-parser/is-buffer.js\");\nvar toString = Object.prototype.toString;\nvar withNativeBlob = typeof global.Blob === 'function' || toString.call(global.Blob) === '[object BlobConstructor]';\nvar withNativeFile = typeof global.File === 'function' || toString.call(global.File) === '[object FileConstructor]';\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet) {\n  var buffers = [];\n  var packetData = packet.data;\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData, buffers);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\nfunction _deconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (isBuf(data)) {\n    var placeholder = { _placeholder: true, num: buffers.length };\n    buffers.push(data);\n    return placeholder;\n  } else if (isArray(data)) {\n    var newData = new Array(data.length);\n    for (var i = 0; i < data.length; i++) {\n      newData[i] = _deconstructPacket(data[i], buffers);\n    }\n    return newData;\n  } else if (typeof data === 'object' && !(data instanceof Date)) {\n    var newData = {};\n    for (var key in data) {\n      newData[key] = _deconstructPacket(data[key], buffers);\n    }\n    return newData;\n  }\n  return data;\n}\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  packet.data = _reconstructPacket(packet.data, buffers);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\nfunction _reconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (data && data._placeholder) {\n    return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n  } else if (isArray(data)) {\n    for (var i = 0; i < data.length; i++) {\n      data[i] = _reconstructPacket(data[i], buffers);\n    }\n  } else if (typeof data === 'object') {\n    for (var key in data) {\n      data[key] = _reconstructPacket(data[key], buffers);\n    }\n  }\n\n  return data;\n}\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/socket.io-parser/binary.js?");

/***/ }),

/***/ "./node_modules/socket.io-parser/index.js":
/*!************************************************!*\
  !*** ./node_modules/socket.io-parser/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * Module dependencies.\n */\n\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('socket.io-parser');\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\nvar hasBin = __webpack_require__(/*! has-binary2 */ \"./node_modules/has-binary2/index.js\");\nvar binary = __webpack_require__(/*! ./binary */ \"./node_modules/socket.io-parser/binary.js\");\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/socket.io-parser/node_modules/isarray/index.js\");\nvar isBuf = __webpack_require__(/*! ./is-buffer */ \"./node_modules/socket.io-parser/is-buffer.js\");\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'ACK',\n  'ERROR',\n  'BINARY_EVENT',\n  'BINARY_ACK'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  if ((obj.type === exports.EVENT || obj.type === exports.ACK) && hasBin(obj.data)) {\n    obj.type = obj.type === exports.EVENT ? exports.BINARY_EVENT : exports.BINARY_ACK;\n  }\n\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    encodeAsBinary(obj, callback);\n  }\n  else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n\n  // first is type\n  var str = '' + obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    str += obj.attachments + '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' !== obj.nsp) {\n    str += obj.nsp + ',';\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    str += JSON.stringify(obj.data);\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an ecoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if (typeof obj === 'string') {\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  }\n  else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  }\n  else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var i = 0;\n  // look up type\n  var p = {\n    type: Number(str.charAt(0))\n  };\n\n  if (null == exports.types[p.type]) {\n    return error('unknown packet type ' + p.type);\n  }\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {\n    var buf = '';\n    while (str.charAt(++i) !== '-') {\n      buf += str.charAt(i);\n      if (i == str.length) break;\n    }\n    if (buf != Number(buf) || str.charAt(i) !== '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' === str.charAt(i + 1)) {\n    p.nsp = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' === c) break;\n      p.nsp += c;\n      if (i === str.length) break;\n    }\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    p.id = '';\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      p.id += str.charAt(i);\n      if (i === str.length) break;\n    }\n    p.id = Number(p.id);\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    var payload = tryParse(str.substr(i));\n    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));\n    if (isPayloadValid) {\n      p.data = payload;\n    } else {\n      return error('invalid payload');\n    }\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch(e){\n    return false;\n  }\n}\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(msg) {\n  return {\n    type: exports.ERROR,\n    data: 'parser error: ' + msg\n  };\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/socket.io-parser/index.js?");

/***/ }),

/***/ "./node_modules/socket.io-parser/is-buffer.js":
/*!****************************************************!*\
  !*** ./node_modules/socket.io-parser/is-buffer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\nmodule.exports = isBuf;\n\n/**\n * Returns true if obj is a buffer or an arraybuffer.\n *\n * @api private\n */\n\nfunction isBuf(obj) {\n  return (global.Buffer && global.Buffer.isBuffer(obj)) ||\n         (global.ArrayBuffer && (obj instanceof ArrayBuffer || ArrayBuffer.isView(obj)));\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/socket.io-parser/is-buffer.js?");

/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/isarray/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/socket.io-parser/node_modules/isarray/index.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/socket.io-parser/node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/supports-color/index.js":
/*!**********************************************!*\
  !*** ./node_modules/supports-color/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst os = __webpack_require__(/*! os */ \"os\");\nconst hasFlag = __webpack_require__(/*! has-flag */ \"./node_modules/has-flag/index.js\");\n\nconst env = process.env;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false')) {\n\tforceColor = false;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = true;\n}\nif ('FORCE_COLOR' in env) {\n\tforceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(stream) {\n\tif (forceColor === false) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (stream && !stream.isTTY && forceColor !== true) {\n\t\t// VS code debugger doesn't have isTTY set\n\t\tif (env.VSCODE_PID) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor ? 1 : 0;\n\n\tif (process.platform === 'win32') {\n\t\t// Node.js 7.5.0 is the first version of Node.js to include a patch to\n\t\t// libuv that enables 256 color output on Windows. Anything earlier and it\n\t\t// won't work. However, here we target Node.js 8 at minimum as it is an LTS\n\t\t// release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows\n\t\t// release that supports 256 colors. Windows 10 build 14931 is the first release\n\t\t// that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(process.versions.node.split('.')[0]) >= 8 &&\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: getSupportLevel(process.stdout),\n\tstderr: getSupportLevel(process.stderr)\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/supports-color/index.js?");

/***/ }),

/***/ "./node_modules/to-array/index.js":
/*!****************************************!*\
  !*** ./node_modules/to-array/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = toArray\n\nfunction toArray(list, index) {\n    var array = []\n\n    index = index || 0\n\n    for (var i = index || 0; i < list.length; i++) {\n        array[i - index] = list[i]\n    }\n\n    return array\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/to-array/index.js?");

/***/ }),

/***/ "./node_modules/ultron/index.js":
/*!**************************************!*\
  !*** ./node_modules/ultron/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * An auto incrementing id which we can use to create \"unique\" Ultron instances\n * so we can track the event emitters that are added through the Ultron\n * interface.\n *\n * @type {Number}\n * @private\n */\nvar id = 0;\n\n/**\n * Ultron is high-intelligence robot. It gathers intelligence so it can start improving\n * upon his rudimentary design. It will learn from your EventEmitting patterns\n * and exterminate them.\n *\n * @constructor\n * @param {EventEmitter} ee EventEmitter instance we need to wrap.\n * @api public\n */\nfunction Ultron(ee) {\n  if (!(this instanceof Ultron)) return new Ultron(ee);\n\n  this.id = id++;\n  this.ee = ee;\n}\n\n/**\n * Register a new EventListener for the given event.\n *\n * @param {String} event Name of the event.\n * @param {Functon} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.on = function on(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.on(event, fn, context);\n\n  return this;\n};\n/**\n * Add an EventListener that's only called once.\n *\n * @param {String} event Name of the event.\n * @param {Function} fn Callback function.\n * @param {Mixed} context The context of the function.\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.once = function once(event, fn, context) {\n  fn.__ultron = this.id;\n  this.ee.once(event, fn, context);\n\n  return this;\n};\n\n/**\n * Remove the listeners we assigned for the given event.\n *\n * @returns {Ultron}\n * @api public\n */\nUltron.prototype.remove = function remove() {\n  var args = arguments\n    , ee = this.ee\n    , event;\n\n  //\n  // When no event names are provided we assume that we need to clear all the\n  // events that were assigned through us.\n  //\n  if (args.length === 1 && 'string' === typeof args[0]) {\n    args = args[0].split(/[, ]+/);\n  } else if (!args.length) {\n    if (ee.eventNames) {\n      args = ee.eventNames();\n    } else if (ee._events) {\n      args = [];\n\n      for (event in ee._events) {\n        if (has.call(ee._events, event)) args.push(event);\n      }\n\n      if (Object.getOwnPropertySymbols) {\n        args = args.concat(Object.getOwnPropertySymbols(ee._events));\n      }\n    }\n  }\n\n  for (var i = 0; i < args.length; i++) {\n    var listeners = ee.listeners(args[i]);\n\n    for (var j = 0; j < listeners.length; j++) {\n      event = listeners[j];\n\n      //\n      // Once listeners have a `listener` property that stores the real listener\n      // in the EventEmitter that ships with Node.js.\n      //\n      if (event.listener) {\n        if (event.listener.__ultron !== this.id) continue;\n      } else if (event.__ultron !== this.id) {\n        continue;\n      }\n\n      ee.removeListener(args[i], event);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Destroy the Ultron instance, remove all listeners and release all references.\n *\n * @returns {Boolean}\n * @api public\n */\nUltron.prototype.destroy = function destroy() {\n  if (!this.ee) return false;\n\n  this.remove();\n  this.ee = null;\n\n  return true;\n};\n\n//\n// Expose the module.\n//\nmodule.exports = Ultron;\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ultron/index.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\r\n\tthrow new Error(\"define cannot be used indirect\");\r\n};\r\n\n\n//# sourceURL=webpack://ApolloSIP/(webpack)/buildin/amd-define.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif (!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif (!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n//# sourceURL=webpack://ApolloSIP/(webpack)/buildin/module.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/adapter_core.js":
/*!************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_core.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\n\nvar adapterFactory = __webpack_require__(/*! ./adapter_factory.js */ \"./node_modules/webrtc-adapter/src/js/adapter_factory.js\");\nmodule.exports = adapterFactory({window: global.window});\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/webrtc-adapter/src/js/adapter_core.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/adapter_factory.js":
/*!***************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/adapter_factory.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n// Shimming starts here.\nmodule.exports = function(dependencies, opts) {\n  var window = dependencies && dependencies.window;\n\n  var options = {\n    shimChrome: true,\n    shimFirefox: true,\n    shimEdge: true,\n    shimSafari: true,\n  };\n\n  for (var key in opts) {\n    if (hasOwnProperty.call(opts, key)) {\n      options[key] = opts[key];\n    }\n  }\n\n  // Utils.\n  var logging = utils.log;\n  var browserDetails = utils.detectBrowser(window);\n\n  // Uncomment the line below if you want logging to occur, including logging\n  // for the switch statement below. Can also be turned on in the browser via\n  // adapter.disableLog(false), but then logging from the switch statement below\n  // will not appear.\n  // require('./utils').disableLog(false);\n\n  // Browser shims.\n  var chromeShim = __webpack_require__(/*! ./chrome/chrome_shim */ \"./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js\") || null;\n  var edgeShim = __webpack_require__(/*! ./edge/edge_shim */ \"./node_modules/webrtc-adapter/src/js/edge/edge_shim.js\") || null;\n  var firefoxShim = __webpack_require__(/*! ./firefox/firefox_shim */ \"./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js\") || null;\n  var safariShim = __webpack_require__(/*! ./safari/safari_shim */ \"./node_modules/webrtc-adapter/src/js/safari/safari_shim.js\") || null;\n  var commonShim = __webpack_require__(/*! ./common_shim */ \"./node_modules/webrtc-adapter/src/js/common_shim.js\") || null;\n\n  // Export to the adapter global object visible in the browser.\n  var adapter = {\n    browserDetails: browserDetails,\n    commonShim: commonShim,\n    extractVersion: utils.extractVersion,\n    disableLog: utils.disableLog,\n    disableWarnings: utils.disableWarnings\n  };\n\n  // Shim browser if found.\n  switch (browserDetails.browser) {\n    case 'chrome':\n      if (!chromeShim || !chromeShim.shimPeerConnection ||\n          !options.shimChrome) {\n        logging('Chrome shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming chrome.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = chromeShim;\n      commonShim.shimCreateObjectURL(window);\n\n      chromeShim.shimGetUserMedia(window);\n      chromeShim.shimMediaStream(window);\n      chromeShim.shimSourceObject(window);\n      chromeShim.shimPeerConnection(window);\n      chromeShim.shimOnTrack(window);\n      chromeShim.shimAddTrackRemoveTrack(window);\n      chromeShim.shimGetSendersWithDtmf(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'firefox':\n      if (!firefoxShim || !firefoxShim.shimPeerConnection ||\n          !options.shimFirefox) {\n        logging('Firefox shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming firefox.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = firefoxShim;\n      commonShim.shimCreateObjectURL(window);\n\n      firefoxShim.shimGetUserMedia(window);\n      firefoxShim.shimSourceObject(window);\n      firefoxShim.shimPeerConnection(window);\n      firefoxShim.shimOnTrack(window);\n      firefoxShim.shimRemoveStream(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'edge':\n      if (!edgeShim || !edgeShim.shimPeerConnection || !options.shimEdge) {\n        logging('MS edge shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming edge.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = edgeShim;\n      commonShim.shimCreateObjectURL(window);\n\n      edgeShim.shimGetUserMedia(window);\n      edgeShim.shimPeerConnection(window);\n      edgeShim.shimReplaceTrack(window);\n\n      // the edge shim implements the full RTCIceCandidate object.\n\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    case 'safari':\n      if (!safariShim || !options.shimSafari) {\n        logging('Safari shim is not included in this adapter release.');\n        return adapter;\n      }\n      logging('adapter.js shimming safari.');\n      // Export to the adapter global object visible in the browser.\n      adapter.browserShim = safariShim;\n      commonShim.shimCreateObjectURL(window);\n\n      safariShim.shimRTCIceServerUrls(window);\n      safariShim.shimCallbacksAPI(window);\n      safariShim.shimLocalStreamsAPI(window);\n      safariShim.shimRemoteStreamsAPI(window);\n      safariShim.shimTrackEventTransceiver(window);\n      safariShim.shimGetUserMedia(window);\n      safariShim.shimCreateOfferLegacy(window);\n\n      commonShim.shimRTCIceCandidate(window);\n      commonShim.shimMaxMessageSize(window);\n      commonShim.shimSendThrowTypeError(window);\n      break;\n    default:\n      logging('Unsupported browser!');\n      break;\n  }\n\n  return adapter;\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/webrtc-adapter/src/js/adapter_factory.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\nvar utils = __webpack_require__(/*! ../utils.js */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\nvar logging = utils.log;\n\nmodule.exports = {\n  shimGetUserMedia: __webpack_require__(/*! ./getusermedia */ \"./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js\"),\n  shimMediaStream: function(window) {\n    window.MediaStream = window.MediaStream || window.webkitMediaStream;\n  },\n\n  shimOnTrack: function(window) {\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n        window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n        get: function() {\n          return this._ontrack;\n        },\n        set: function(f) {\n          if (this._ontrack) {\n            this.removeEventListener('track', this._ontrack);\n          }\n          this.addEventListener('track', this._ontrack = f);\n        }\n      });\n      var origSetRemoteDescription =\n          window.RTCPeerConnection.prototype.setRemoteDescription;\n      window.RTCPeerConnection.prototype.setRemoteDescription = function() {\n        var pc = this;\n        if (!pc._ontrackpoly) {\n          pc._ontrackpoly = function(e) {\n            // onaddstream does not fire when a track is added to an existing\n            // stream. But stream.onaddtrack is implemented so we use that.\n            e.stream.addEventListener('addtrack', function(te) {\n              var receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = pc.getReceivers().find(function(r) {\n                  return r.track && r.track.id === te.track.id;\n                });\n              } else {\n                receiver = {track: te.track};\n              }\n\n              var event = new Event('track');\n              event.track = te.track;\n              event.receiver = receiver;\n              event.transceiver = {receiver: receiver};\n              event.streams = [e.stream];\n              pc.dispatchEvent(event);\n            });\n            e.stream.getTracks().forEach(function(track) {\n              var receiver;\n              if (window.RTCPeerConnection.prototype.getReceivers) {\n                receiver = pc.getReceivers().find(function(r) {\n                  return r.track && r.track.id === track.id;\n                });\n              } else {\n                receiver = {track: track};\n              }\n              var event = new Event('track');\n              event.track = track;\n              event.receiver = receiver;\n              event.transceiver = {receiver: receiver};\n              event.streams = [e.stream];\n              pc.dispatchEvent(event);\n            });\n          };\n          pc.addEventListener('addstream', pc._ontrackpoly);\n        }\n        return origSetRemoteDescription.apply(pc, arguments);\n      };\n    } else if (!('RTCRtpTransceiver' in window)) {\n      utils.wrapPeerConnectionEvent(window, 'track', function(e) {\n        if (!e.transceiver) {\n          e.transceiver = {receiver: e.receiver};\n        }\n        return e;\n      });\n    }\n  },\n\n  shimGetSendersWithDtmf: function(window) {\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n    if (typeof window === 'object' && window.RTCPeerConnection &&\n        !('getSenders' in window.RTCPeerConnection.prototype) &&\n        'createDTMFSender' in window.RTCPeerConnection.prototype) {\n      var shimSenderWithDtmf = function(pc, track) {\n        return {\n          track: track,\n          get dtmf() {\n            if (this._dtmf === undefined) {\n              if (track.kind === 'audio') {\n                this._dtmf = pc.createDTMFSender(track);\n              } else {\n                this._dtmf = null;\n              }\n            }\n            return this._dtmf;\n          },\n          _pc: pc\n        };\n      };\n\n      // augment addTrack when getSenders is not available.\n      if (!window.RTCPeerConnection.prototype.getSenders) {\n        window.RTCPeerConnection.prototype.getSenders = function() {\n          this._senders = this._senders || [];\n          return this._senders.slice(); // return a copy of the internal state.\n        };\n        var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n        window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n          var pc = this;\n          var sender = origAddTrack.apply(pc, arguments);\n          if (!sender) {\n            sender = shimSenderWithDtmf(pc, track);\n            pc._senders.push(sender);\n          }\n          return sender;\n        };\n\n        var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n        window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n          var pc = this;\n          origRemoveTrack.apply(pc, arguments);\n          var idx = pc._senders.indexOf(sender);\n          if (idx !== -1) {\n            pc._senders.splice(idx, 1);\n          }\n        };\n      }\n      var origAddStream = window.RTCPeerConnection.prototype.addStream;\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\n        var pc = this;\n        pc._senders = pc._senders || [];\n        origAddStream.apply(pc, [stream]);\n        stream.getTracks().forEach(function(track) {\n          pc._senders.push(shimSenderWithDtmf(pc, track));\n        });\n      };\n\n      var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\n        var pc = this;\n        pc._senders = pc._senders || [];\n        origRemoveStream.apply(pc, [stream]);\n\n        stream.getTracks().forEach(function(track) {\n          var sender = pc._senders.find(function(s) {\n            return s.track === track;\n          });\n          if (sender) {\n            pc._senders.splice(pc._senders.indexOf(sender), 1); // remove sender\n          }\n        });\n      };\n    } else if (typeof window === 'object' && window.RTCPeerConnection &&\n               'getSenders' in window.RTCPeerConnection.prototype &&\n               'createDTMFSender' in window.RTCPeerConnection.prototype &&\n               window.RTCRtpSender &&\n               !('dtmf' in window.RTCRtpSender.prototype)) {\n      var origGetSenders = window.RTCPeerConnection.prototype.getSenders;\n      window.RTCPeerConnection.prototype.getSenders = function() {\n        var pc = this;\n        var senders = origGetSenders.apply(pc, []);\n        senders.forEach(function(sender) {\n          sender._pc = pc;\n        });\n        return senders;\n      };\n\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n        get: function() {\n          if (this._dtmf === undefined) {\n            if (this.track.kind === 'audio') {\n              this._dtmf = this._pc.createDTMFSender(this.track);\n            } else {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        }\n      });\n    }\n  },\n\n  shimSourceObject: function(window) {\n    var URL = window && window.URL;\n\n    if (typeof window === 'object') {\n      if (window.HTMLMediaElement &&\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n          get: function() {\n            return this._srcObject;\n          },\n          set: function(stream) {\n            var self = this;\n            // Use _srcObject as a private property for this shim\n            this._srcObject = stream;\n            if (this.src) {\n              URL.revokeObjectURL(this.src);\n            }\n\n            if (!stream) {\n              this.src = '';\n              return undefined;\n            }\n            this.src = URL.createObjectURL(stream);\n            // We need to recreate the blob url when a track is added or\n            // removed. Doing it manually since we want to avoid a recursion.\n            stream.addEventListener('addtrack', function() {\n              if (self.src) {\n                URL.revokeObjectURL(self.src);\n              }\n              self.src = URL.createObjectURL(stream);\n            });\n            stream.addEventListener('removetrack', function() {\n              if (self.src) {\n                URL.revokeObjectURL(self.src);\n              }\n              self.src = URL.createObjectURL(stream);\n            });\n          }\n        });\n      }\n    }\n  },\n\n  shimAddTrackRemoveTrackWithNative: function(window) {\n    // shim addTrack/removeTrack with native variants in order to make\n    // the interactions with legacy getLocalStreams behave as in other browsers.\n    // Keeps a mapping stream.id => [stream, rtpsenders...]\n    window.RTCPeerConnection.prototype.getLocalStreams = function() {\n      var pc = this;\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      return Object.keys(this._shimmedLocalStreams).map(function(streamId) {\n        return pc._shimmedLocalStreams[streamId][0];\n      });\n    };\n\n    var origAddTrack = window.RTCPeerConnection.prototype.addTrack;\n    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n      if (!stream) {\n        return origAddTrack.apply(this, arguments);\n      }\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      var sender = origAddTrack.apply(this, arguments);\n      if (!this._shimmedLocalStreams[stream.id]) {\n        this._shimmedLocalStreams[stream.id] = [stream, sender];\n      } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n        this._shimmedLocalStreams[stream.id].push(sender);\n      }\n      return sender;\n    };\n\n    var origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function(stream) {\n      var pc = this;\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n\n      stream.getTracks().forEach(function(track) {\n        var alreadyExists = pc.getSenders().find(function(s) {\n          return s.track === track;\n        });\n        if (alreadyExists) {\n          throw new DOMException('Track already exists.',\n              'InvalidAccessError');\n        }\n      });\n      var existingSenders = pc.getSenders();\n      origAddStream.apply(this, arguments);\n      var newSenders = pc.getSenders().filter(function(newSender) {\n        return existingSenders.indexOf(newSender) === -1;\n      });\n      this._shimmedLocalStreams[stream.id] = [stream].concat(newSenders);\n    };\n\n    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      delete this._shimmedLocalStreams[stream.id];\n      return origRemoveStream.apply(this, arguments);\n    };\n\n    var origRemoveTrack = window.RTCPeerConnection.prototype.removeTrack;\n    window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n      var pc = this;\n      this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n      if (sender) {\n        Object.keys(this._shimmedLocalStreams).forEach(function(streamId) {\n          var idx = pc._shimmedLocalStreams[streamId].indexOf(sender);\n          if (idx !== -1) {\n            pc._shimmedLocalStreams[streamId].splice(idx, 1);\n          }\n          if (pc._shimmedLocalStreams[streamId].length === 1) {\n            delete pc._shimmedLocalStreams[streamId];\n          }\n        });\n      }\n      return origRemoveTrack.apply(this, arguments);\n    };\n  },\n\n  shimAddTrackRemoveTrack: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n    // shim addTrack and removeTrack.\n    if (window.RTCPeerConnection.prototype.addTrack &&\n        browserDetails.version >= 65) {\n      return this.shimAddTrackRemoveTrackWithNative(window);\n    }\n\n    // also shim pc.getLocalStreams when addTrack is shimmed\n    // to return the original streams.\n    var origGetLocalStreams = window.RTCPeerConnection.prototype\n        .getLocalStreams;\n    window.RTCPeerConnection.prototype.getLocalStreams = function() {\n      var pc = this;\n      var nativeStreams = origGetLocalStreams.apply(this);\n      pc._reverseStreams = pc._reverseStreams || {};\n      return nativeStreams.map(function(stream) {\n        return pc._reverseStreams[stream.id];\n      });\n    };\n\n    var origAddStream = window.RTCPeerConnection.prototype.addStream;\n    window.RTCPeerConnection.prototype.addStream = function(stream) {\n      var pc = this;\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n\n      stream.getTracks().forEach(function(track) {\n        var alreadyExists = pc.getSenders().find(function(s) {\n          return s.track === track;\n        });\n        if (alreadyExists) {\n          throw new DOMException('Track already exists.',\n              'InvalidAccessError');\n        }\n      });\n      // Add identity mapping for consistency with addTrack.\n      // Unless this is being used with a stream from addTrack.\n      if (!pc._reverseStreams[stream.id]) {\n        var newStream = new window.MediaStream(stream.getTracks());\n        pc._streams[stream.id] = newStream;\n        pc._reverseStreams[newStream.id] = stream;\n        stream = newStream;\n      }\n      origAddStream.apply(pc, [stream]);\n    };\n\n    var origRemoveStream = window.RTCPeerConnection.prototype.removeStream;\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\n      var pc = this;\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n\n      origRemoveStream.apply(pc, [(pc._streams[stream.id] || stream)]);\n      delete pc._reverseStreams[(pc._streams[stream.id] ?\n          pc._streams[stream.id].id : stream.id)];\n      delete pc._streams[stream.id];\n    };\n\n    window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n      var pc = this;\n      if (pc.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      var streams = [].slice.call(arguments, 1);\n      if (streams.length !== 1 ||\n          !streams[0].getTracks().find(function(t) {\n            return t === track;\n          })) {\n        // this is not fully correct but all we can manage without\n        // [[associated MediaStreams]] internal slot.\n        throw new DOMException(\n          'The adapter.js addTrack polyfill only supports a single ' +\n          ' stream which is associated with the specified track.',\n          'NotSupportedError');\n      }\n\n      var alreadyExists = pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n      if (alreadyExists) {\n        throw new DOMException('Track already exists.',\n            'InvalidAccessError');\n      }\n\n      pc._streams = pc._streams || {};\n      pc._reverseStreams = pc._reverseStreams || {};\n      var oldStream = pc._streams[stream.id];\n      if (oldStream) {\n        // this is using odd Chrome behaviour, use with caution:\n        // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n        // Note: we rely on the high-level addTrack/dtmf shim to\n        // create the sender with a dtmf sender.\n        oldStream.addTrack(track);\n\n        // Trigger ONN async.\n        Promise.resolve().then(function() {\n          pc.dispatchEvent(new Event('negotiationneeded'));\n        });\n      } else {\n        var newStream = new window.MediaStream([track]);\n        pc._streams[stream.id] = newStream;\n        pc._reverseStreams[newStream.id] = stream;\n        pc.addStream(newStream);\n      }\n      return pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n    };\n\n    // replace the internal stream id with the external one and\n    // vice versa.\n    function replaceInternalStreamId(pc, description) {\n      var sdp = description.sdp;\n      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {\n        var externalStream = pc._reverseStreams[internalId];\n        var internalStream = pc._streams[externalStream.id];\n        sdp = sdp.replace(new RegExp(internalStream.id, 'g'),\n            externalStream.id);\n      });\n      return new RTCSessionDescription({\n        type: description.type,\n        sdp: sdp\n      });\n    }\n    function replaceExternalStreamId(pc, description) {\n      var sdp = description.sdp;\n      Object.keys(pc._reverseStreams || []).forEach(function(internalId) {\n        var externalStream = pc._reverseStreams[internalId];\n        var internalStream = pc._streams[externalStream.id];\n        sdp = sdp.replace(new RegExp(externalStream.id, 'g'),\n            internalStream.id);\n      });\n      return new RTCSessionDescription({\n        type: description.type,\n        sdp: sdp\n      });\n    }\n    ['createOffer', 'createAnswer'].forEach(function(method) {\n      var nativeMethod = window.RTCPeerConnection.prototype[method];\n      window.RTCPeerConnection.prototype[method] = function() {\n        var pc = this;\n        var args = arguments;\n        var isLegacyCall = arguments.length &&\n            typeof arguments[0] === 'function';\n        if (isLegacyCall) {\n          return nativeMethod.apply(pc, [\n            function(description) {\n              var desc = replaceInternalStreamId(pc, description);\n              args[0].apply(null, [desc]);\n            },\n            function(err) {\n              if (args[1]) {\n                args[1].apply(null, err);\n              }\n            }, arguments[2]\n          ]);\n        }\n        return nativeMethod.apply(pc, arguments)\n        .then(function(description) {\n          return replaceInternalStreamId(pc, description);\n        });\n      };\n    });\n\n    var origSetLocalDescription =\n        window.RTCPeerConnection.prototype.setLocalDescription;\n    window.RTCPeerConnection.prototype.setLocalDescription = function() {\n      var pc = this;\n      if (!arguments.length || !arguments[0].type) {\n        return origSetLocalDescription.apply(pc, arguments);\n      }\n      arguments[0] = replaceExternalStreamId(pc, arguments[0]);\n      return origSetLocalDescription.apply(pc, arguments);\n    };\n\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n\n    var origLocalDescription = Object.getOwnPropertyDescriptor(\n        window.RTCPeerConnection.prototype, 'localDescription');\n    Object.defineProperty(window.RTCPeerConnection.prototype,\n        'localDescription', {\n          get: function() {\n            var pc = this;\n            var description = origLocalDescription.get.apply(this);\n            if (description.type === '') {\n              return description;\n            }\n            return replaceInternalStreamId(pc, description);\n          }\n        });\n\n    window.RTCPeerConnection.prototype.removeTrack = function(sender) {\n      var pc = this;\n      if (pc.signalingState === 'closed') {\n        throw new DOMException(\n          'The RTCPeerConnection\\'s signalingState is \\'closed\\'.',\n          'InvalidStateError');\n      }\n      // We can not yet check for sender instanceof RTCRtpSender\n      // since we shim RTPSender. So we check if sender._pc is set.\n      if (!sender._pc) {\n        throw new DOMException('Argument 1 of RTCPeerConnection.removeTrack ' +\n            'does not implement interface RTCRtpSender.', 'TypeError');\n      }\n      var isLocal = sender._pc === pc;\n      if (!isLocal) {\n        throw new DOMException('Sender was not created by this connection.',\n            'InvalidAccessError');\n      }\n\n      // Search for the native stream the senders track belongs to.\n      pc._streams = pc._streams || {};\n      var stream;\n      Object.keys(pc._streams).forEach(function(streamid) {\n        var hasTrack = pc._streams[streamid].getTracks().find(function(track) {\n          return sender.track === track;\n        });\n        if (hasTrack) {\n          stream = pc._streams[streamid];\n        }\n      });\n\n      if (stream) {\n        if (stream.getTracks().length === 1) {\n          // if this is the last track of the stream, remove the stream. This\n          // takes care of any shimmed _senders.\n          pc.removeStream(pc._reverseStreams[stream.id]);\n        } else {\n          // relying on the same odd chrome behaviour as above.\n          stream.removeTrack(sender.track);\n        }\n        pc.dispatchEvent(new Event('negotiationneeded'));\n      }\n    };\n  },\n\n  shimPeerConnection: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    // The RTCPeerConnection object.\n    if (!window.RTCPeerConnection && window.webkitRTCPeerConnection) {\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n        // Translate iceTransportPolicy to iceTransports,\n        // see https://code.google.com/p/webrtc/issues/detail?id=4869\n        // this was fixed in M56 along with unprefixing RTCPeerConnection.\n        logging('PeerConnection');\n        if (pcConfig && pcConfig.iceTransportPolicy) {\n          pcConfig.iceTransports = pcConfig.iceTransportPolicy;\n        }\n\n        return new window.webkitRTCPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype =\n          window.webkitRTCPeerConnection.prototype;\n      // wrap static methods. Currently just generateCertificate.\n      if (window.webkitRTCPeerConnection.generateCertificate) {\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n          get: function() {\n            return window.webkitRTCPeerConnection.generateCertificate;\n          }\n        });\n      }\n    } else {\n      // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n      var OrigPeerConnection = window.RTCPeerConnection;\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n        if (pcConfig && pcConfig.iceServers) {\n          var newIceServers = [];\n          for (var i = 0; i < pcConfig.iceServers.length; i++) {\n            var server = pcConfig.iceServers[i];\n            if (!server.hasOwnProperty('urls') &&\n                server.hasOwnProperty('url')) {\n              utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n              server = JSON.parse(JSON.stringify(server));\n              server.urls = server.url;\n              newIceServers.push(server);\n            } else {\n              newIceServers.push(pcConfig.iceServers[i]);\n            }\n          }\n          pcConfig.iceServers = newIceServers;\n        }\n        return new OrigPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n      // wrap static methods. Currently just generateCertificate.\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n        get: function() {\n          return OrigPeerConnection.generateCertificate;\n        }\n      });\n    }\n\n    var origGetStats = window.RTCPeerConnection.prototype.getStats;\n    window.RTCPeerConnection.prototype.getStats = function(selector,\n        successCallback, errorCallback) {\n      var pc = this;\n      var args = arguments;\n\n      // If selector is a function then we are in the old style stats so just\n      // pass back the original getStats format to avoid breaking old users.\n      if (arguments.length > 0 && typeof selector === 'function') {\n        return origGetStats.apply(this, arguments);\n      }\n\n      // When spec-style getStats is supported, return those when called with\n      // either no arguments or the selector argument is null.\n      if (origGetStats.length === 0 && (arguments.length === 0 ||\n          typeof arguments[0] !== 'function')) {\n        return origGetStats.apply(this, []);\n      }\n\n      var fixChromeStats_ = function(response) {\n        var standardReport = {};\n        var reports = response.result();\n        reports.forEach(function(report) {\n          var standardStats = {\n            id: report.id,\n            timestamp: report.timestamp,\n            type: {\n              localcandidate: 'local-candidate',\n              remotecandidate: 'remote-candidate'\n            }[report.type] || report.type\n          };\n          report.names().forEach(function(name) {\n            standardStats[name] = report.stat(name);\n          });\n          standardReport[standardStats.id] = standardStats;\n        });\n\n        return standardReport;\n      };\n\n      // shim getStats with maplike support\n      var makeMapStats = function(stats) {\n        return new Map(Object.keys(stats).map(function(key) {\n          return [key, stats[key]];\n        }));\n      };\n\n      if (arguments.length >= 2) {\n        var successCallbackWrapper_ = function(response) {\n          args[1](makeMapStats(fixChromeStats_(response)));\n        };\n\n        return origGetStats.apply(this, [successCallbackWrapper_,\n          arguments[0]]);\n      }\n\n      // promise-support\n      return new Promise(function(resolve, reject) {\n        origGetStats.apply(pc, [\n          function(response) {\n            resolve(makeMapStats(fixChromeStats_(response)));\n          }, reject]);\n      }).then(successCallback, errorCallback);\n    };\n\n    // add promise support -- natively available in Chrome 51\n    if (browserDetails.version < 51) {\n      ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n          .forEach(function(method) {\n            var nativeMethod = window.RTCPeerConnection.prototype[method];\n            window.RTCPeerConnection.prototype[method] = function() {\n              var args = arguments;\n              var pc = this;\n              var promise = new Promise(function(resolve, reject) {\n                nativeMethod.apply(pc, [args[0], resolve, reject]);\n              });\n              if (args.length < 2) {\n                return promise;\n              }\n              return promise.then(function() {\n                args[1].apply(null, []);\n              },\n              function(err) {\n                if (args.length >= 3) {\n                  args[2].apply(null, [err]);\n                }\n              });\n            };\n          });\n    }\n\n    // promise support for createOffer and createAnswer. Available (without\n    // bugs) since M52: crbug/619289\n    if (browserDetails.version < 52) {\n      ['createOffer', 'createAnswer'].forEach(function(method) {\n        var nativeMethod = window.RTCPeerConnection.prototype[method];\n        window.RTCPeerConnection.prototype[method] = function() {\n          var pc = this;\n          if (arguments.length < 1 || (arguments.length === 1 &&\n              typeof arguments[0] === 'object')) {\n            var opts = arguments.length === 1 ? arguments[0] : undefined;\n            return new Promise(function(resolve, reject) {\n              nativeMethod.apply(pc, [resolve, reject, opts]);\n            });\n          }\n          return nativeMethod.apply(this, arguments);\n        };\n      });\n    }\n\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\n          window.RTCPeerConnection.prototype[method] = function() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          };\n        });\n\n    // support for addIceCandidate(null or undefined)\n    var nativeAddIceCandidate =\n        window.RTCPeerConnection.prototype.addIceCandidate;\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n  }\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/webrtc-adapter/src/js/chrome/chrome_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\nvar utils = __webpack_require__(/*! ../utils.js */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\nvar logging = utils.log;\n\n// Expose public methods.\nmodule.exports = function(window) {\n  var browserDetails = utils.detectBrowser(window);\n  var navigator = window && window.navigator;\n\n  var constraintsToChrome_ = function(c) {\n    if (typeof c !== 'object' || c.mandatory || c.optional) {\n      return c;\n    }\n    var cc = {};\n    Object.keys(c).forEach(function(key) {\n      if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n        return;\n      }\n      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};\n      if (r.exact !== undefined && typeof r.exact === 'number') {\n        r.min = r.max = r.exact;\n      }\n      var oldname_ = function(prefix, name) {\n        if (prefix) {\n          return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n        }\n        return (name === 'deviceId') ? 'sourceId' : name;\n      };\n      if (r.ideal !== undefined) {\n        cc.optional = cc.optional || [];\n        var oc = {};\n        if (typeof r.ideal === 'number') {\n          oc[oldname_('min', key)] = r.ideal;\n          cc.optional.push(oc);\n          oc = {};\n          oc[oldname_('max', key)] = r.ideal;\n          cc.optional.push(oc);\n        } else {\n          oc[oldname_('', key)] = r.ideal;\n          cc.optional.push(oc);\n        }\n      }\n      if (r.exact !== undefined && typeof r.exact !== 'number') {\n        cc.mandatory = cc.mandatory || {};\n        cc.mandatory[oldname_('', key)] = r.exact;\n      } else {\n        ['min', 'max'].forEach(function(mix) {\n          if (r[mix] !== undefined) {\n            cc.mandatory = cc.mandatory || {};\n            cc.mandatory[oldname_(mix, key)] = r[mix];\n          }\n        });\n      }\n    });\n    if (c.advanced) {\n      cc.optional = (cc.optional || []).concat(c.advanced);\n    }\n    return cc;\n  };\n\n  var shimConstraints_ = function(constraints, func) {\n    if (browserDetails.version >= 61) {\n      return func(constraints);\n    }\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (constraints && typeof constraints.audio === 'object') {\n      var remap = function(obj, a, b) {\n        if (a in obj && !(b in obj)) {\n          obj[b] = obj[a];\n          delete obj[a];\n        }\n      };\n      constraints = JSON.parse(JSON.stringify(constraints));\n      remap(constraints.audio, 'autoGainControl', 'googAutoGainControl');\n      remap(constraints.audio, 'noiseSuppression', 'googNoiseSuppression');\n      constraints.audio = constraintsToChrome_(constraints.audio);\n    }\n    if (constraints && typeof constraints.video === 'object') {\n      // Shim facingMode for mobile & surface pro.\n      var face = constraints.video.facingMode;\n      face = face && ((typeof face === 'object') ? face : {ideal: face});\n      var getSupportedFacingModeLies = browserDetails.version < 66;\n\n      if ((face && (face.exact === 'user' || face.exact === 'environment' ||\n                    face.ideal === 'user' || face.ideal === 'environment')) &&\n          !(navigator.mediaDevices.getSupportedConstraints &&\n            navigator.mediaDevices.getSupportedConstraints().facingMode &&\n            !getSupportedFacingModeLies)) {\n        delete constraints.video.facingMode;\n        var matches;\n        if (face.exact === 'environment' || face.ideal === 'environment') {\n          matches = ['back', 'rear'];\n        } else if (face.exact === 'user' || face.ideal === 'user') {\n          matches = ['front'];\n        }\n        if (matches) {\n          // Look for matches in label, or use last cam for back (typical).\n          return navigator.mediaDevices.enumerateDevices()\n          .then(function(devices) {\n            devices = devices.filter(function(d) {\n              return d.kind === 'videoinput';\n            });\n            var dev = devices.find(function(d) {\n              return matches.some(function(match) {\n                return d.label.toLowerCase().indexOf(match) !== -1;\n              });\n            });\n            if (!dev && devices.length && matches.indexOf('back') !== -1) {\n              dev = devices[devices.length - 1]; // more likely the back cam\n            }\n            if (dev) {\n              constraints.video.deviceId = face.exact ? {exact: dev.deviceId} :\n                                                        {ideal: dev.deviceId};\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n            logging('chrome: ' + JSON.stringify(constraints));\n            return func(constraints);\n          });\n        }\n      }\n      constraints.video = constraintsToChrome_(constraints.video);\n    }\n    logging('chrome: ' + JSON.stringify(constraints));\n    return func(constraints);\n  };\n\n  var shimError_ = function(e) {\n    return {\n      name: {\n        PermissionDeniedError: 'NotAllowedError',\n        PermissionDismissedError: 'NotAllowedError',\n        InvalidStateError: 'NotAllowedError',\n        DevicesNotFoundError: 'NotFoundError',\n        ConstraintNotSatisfiedError: 'OverconstrainedError',\n        TrackStartError: 'NotReadableError',\n        MediaDeviceFailedDueToShutdown: 'NotAllowedError',\n        MediaDeviceKillSwitchOn: 'NotAllowedError',\n        TabCaptureError: 'AbortError',\n        ScreenCaptureError: 'AbortError',\n        DeviceCaptureError: 'AbortError'\n      }[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraintName,\n      toString: function() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\n    shimConstraints_(constraints, function(c) {\n      navigator.webkitGetUserMedia(c, onSuccess, function(e) {\n        if (onError) {\n          onError(shimError_(e));\n        }\n      });\n    });\n  };\n\n  navigator.getUserMedia = getUserMedia_;\n\n  // Returns the result of getUserMedia as a Promise.\n  var getUserMediaPromise_ = function(constraints) {\n    return new Promise(function(resolve, reject) {\n      navigator.getUserMedia(constraints, resolve, reject);\n    });\n  };\n\n  if (!navigator.mediaDevices) {\n    navigator.mediaDevices = {\n      getUserMedia: getUserMediaPromise_,\n      enumerateDevices: function() {\n        return new Promise(function(resolve) {\n          var kinds = {audio: 'audioinput', video: 'videoinput'};\n          return window.MediaStreamTrack.getSources(function(devices) {\n            resolve(devices.map(function(device) {\n              return {label: device.label,\n                kind: kinds[device.kind],\n                deviceId: device.id,\n                groupId: ''};\n            }));\n          });\n        });\n      },\n      getSupportedConstraints: function() {\n        return {\n          deviceId: true, echoCancellation: true, facingMode: true,\n          frameRate: true, height: true, width: true\n        };\n      }\n    };\n  }\n\n  // A shim for getUserMedia method on the mediaDevices object.\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\n  if (!navigator.mediaDevices.getUserMedia) {\n    navigator.mediaDevices.getUserMedia = function(constraints) {\n      return getUserMediaPromise_(constraints);\n    };\n  } else {\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n    // function which returns a Promise, it does not accept spec-style\n    // constraints.\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(cs) {\n      return shimConstraints_(cs, function(c) {\n        return origGetUserMedia(c).then(function(stream) {\n          if (c.audio && !stream.getAudioTracks().length ||\n              c.video && !stream.getVideoTracks().length) {\n            stream.getTracks().forEach(function(track) {\n              track.stop();\n            });\n            throw new DOMException('', 'NotFoundError');\n          }\n          return stream;\n        }, function(e) {\n          return Promise.reject(shimError_(e));\n        });\n      });\n    };\n  }\n\n  // Dummy devicechange event methods.\n  // TODO(KaptenJansson) remove once implemented in Chrome stable.\n  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {\n    navigator.mediaDevices.addEventListener = function() {\n      logging('Dummy mediaDevices.addEventListener called.');\n    };\n  }\n  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {\n    navigator.mediaDevices.removeEventListener = function() {\n      logging('Dummy mediaDevices.removeEventListener called.');\n    };\n  }\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/webrtc-adapter/src/js/chrome/getusermedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/common_shim.js":
/*!***********************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/common_shim.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar SDPUtils = __webpack_require__(/*! sdp */ \"./node_modules/sdp/sdp.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n\nmodule.exports = {\n  shimRTCIceCandidate: function(window) {\n    // foundation is arbitrarily chosen as an indicator for full support for\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n    if (!window.RTCIceCandidate || (window.RTCIceCandidate && 'foundation' in\n        window.RTCIceCandidate.prototype)) {\n      return;\n    }\n\n    var NativeRTCIceCandidate = window.RTCIceCandidate;\n    window.RTCIceCandidate = function(args) {\n      // Remove the a= which shouldn't be part of the candidate string.\n      if (typeof args === 'object' && args.candidate &&\n          args.candidate.indexOf('a=') === 0) {\n        args = JSON.parse(JSON.stringify(args));\n        args.candidate = args.candidate.substr(2);\n      }\n\n      if (args.candidate && args.candidate.length) {\n        // Augment the native candidate with the parsed fields.\n        var nativeCandidate = new NativeRTCIceCandidate(args);\n        var parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n        var augmentedCandidate = Object.assign(nativeCandidate,\n            parsedCandidate);\n\n        // Add a serializer that does not serialize the extra attributes.\n        augmentedCandidate.toJSON = function() {\n          return {\n            candidate: augmentedCandidate.candidate,\n            sdpMid: augmentedCandidate.sdpMid,\n            sdpMLineIndex: augmentedCandidate.sdpMLineIndex,\n            usernameFragment: augmentedCandidate.usernameFragment,\n          };\n        };\n        return augmentedCandidate;\n      }\n      return new NativeRTCIceCandidate(args);\n    };\n    window.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    utils.wrapPeerConnectionEvent(window, 'icecandidate', function(e) {\n      if (e.candidate) {\n        Object.defineProperty(e, 'candidate', {\n          value: new window.RTCIceCandidate(e.candidate),\n          writable: 'false'\n        });\n      }\n      return e;\n    });\n  },\n\n  // shimCreateObjectURL must be called before shimSourceObject to avoid loop.\n\n  shimCreateObjectURL: function(window) {\n    var URL = window && window.URL;\n\n    if (!(typeof window === 'object' && window.HTMLMediaElement &&\n          'srcObject' in window.HTMLMediaElement.prototype &&\n        URL.createObjectURL && URL.revokeObjectURL)) {\n      // Only shim CreateObjectURL using srcObject if srcObject exists.\n      return undefined;\n    }\n\n    var nativeCreateObjectURL = URL.createObjectURL.bind(URL);\n    var nativeRevokeObjectURL = URL.revokeObjectURL.bind(URL);\n    var streams = new Map(), newId = 0;\n\n    URL.createObjectURL = function(stream) {\n      if ('getTracks' in stream) {\n        var url = 'polyblob:' + (++newId);\n        streams.set(url, stream);\n        utils.deprecated('URL.createObjectURL(stream)',\n            'elem.srcObject = stream');\n        return url;\n      }\n      return nativeCreateObjectURL(stream);\n    };\n    URL.revokeObjectURL = function(url) {\n      nativeRevokeObjectURL(url);\n      streams.delete(url);\n    };\n\n    var dsc = Object.getOwnPropertyDescriptor(window.HTMLMediaElement.prototype,\n                                              'src');\n    Object.defineProperty(window.HTMLMediaElement.prototype, 'src', {\n      get: function() {\n        return dsc.get.apply(this);\n      },\n      set: function(url) {\n        this.srcObject = streams.get(url) || null;\n        return dsc.set.apply(this, [url]);\n      }\n    });\n\n    var nativeSetAttribute = window.HTMLMediaElement.prototype.setAttribute;\n    window.HTMLMediaElement.prototype.setAttribute = function() {\n      if (arguments.length === 2 &&\n          ('' + arguments[0]).toLowerCase() === 'src') {\n        this.srcObject = streams.get(arguments[1]) || null;\n      }\n      return nativeSetAttribute.apply(this, arguments);\n    };\n  },\n\n  shimMaxMessageSize: function(window) {\n    if (window.RTCSctpTransport || !window.RTCPeerConnection) {\n      return;\n    }\n    var browserDetails = utils.detectBrowser(window);\n\n    if (!('sctp' in window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'sctp', {\n        get: function() {\n          return typeof this._sctp === 'undefined' ? null : this._sctp;\n        }\n      });\n    }\n\n    var sctpInDescription = function(description) {\n      var sections = SDPUtils.splitSections(description.sdp);\n      sections.shift();\n      return sections.some(function(mediaSection) {\n        var mLine = SDPUtils.parseMLine(mediaSection);\n        return mLine && mLine.kind === 'application'\n            && mLine.protocol.indexOf('SCTP') !== -1;\n      });\n    };\n\n    var getRemoteFirefoxVersion = function(description) {\n      // TODO: Is there a better solution for detecting Firefox?\n      var match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n      if (match === null || match.length < 2) {\n        return -1;\n      }\n      var version = parseInt(match[1], 10);\n      // Test for NaN (yes, this is ugly)\n      return version !== version ? -1 : version;\n    };\n\n    var getCanSendMaxMessageSize = function(remoteIsFirefox) {\n      // Every implementation we know can send at least 64 KiB.\n      // Note: Although Chrome is technically able to send up to 256 KiB, the\n      //       data does not reach the other peer reliably.\n      //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n      var canSendMaxMessageSize = 65536;\n      if (browserDetails.browser === 'firefox') {\n        if (browserDetails.version < 57) {\n          if (remoteIsFirefox === -1) {\n            // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n            // fragmentation.\n            canSendMaxMessageSize = 16384;\n          } else {\n            // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n            // messages. Thus, supporting ~2 GiB when sending.\n            canSendMaxMessageSize = 2147483637;\n          }\n        } else {\n          // Currently, all FF >= 57 will reset the remote maximum message size\n          // to the default value when a data channel is created at a later\n          // stage. :(\n          // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n          canSendMaxMessageSize =\n            browserDetails.version === 57 ? 65535 : 65536;\n        }\n      }\n      return canSendMaxMessageSize;\n    };\n\n    var getMaxMessageSize = function(description, remoteIsFirefox) {\n      // Note: 65536 bytes is the default value from the SDP spec. Also,\n      //       every implementation we know supports receiving 65536 bytes.\n      var maxMessageSize = 65536;\n\n      // FF 57 has a slightly incorrect default remote max message size, so\n      // we need to adjust it here to avoid a failure when sending.\n      // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n      if (browserDetails.browser === 'firefox'\n           && browserDetails.version === 57) {\n        maxMessageSize = 65535;\n      }\n\n      var match = SDPUtils.matchPrefix(description.sdp, 'a=max-message-size:');\n      if (match.length > 0) {\n        maxMessageSize = parseInt(match[0].substr(19), 10);\n      } else if (browserDetails.browser === 'firefox' &&\n                  remoteIsFirefox !== -1) {\n        // If the maximum message size is not present in the remote SDP and\n        // both local and remote are Firefox, the remote peer can receive\n        // ~2 GiB.\n        maxMessageSize = 2147483637;\n      }\n      return maxMessageSize;\n    };\n\n    var origSetRemoteDescription =\n        window.RTCPeerConnection.prototype.setRemoteDescription;\n    window.RTCPeerConnection.prototype.setRemoteDescription = function() {\n      var pc = this;\n      pc._sctp = null;\n\n      if (sctpInDescription(arguments[0])) {\n        // Check if the remote is FF.\n        var isFirefox = getRemoteFirefoxVersion(arguments[0]);\n\n        // Get the maximum message size the local peer is capable of sending\n        var canSendMMS = getCanSendMaxMessageSize(isFirefox);\n\n        // Get the maximum message size of the remote peer.\n        var remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n\n        // Determine final maximum message size\n        var maxMessageSize;\n        if (canSendMMS === 0 && remoteMMS === 0) {\n          maxMessageSize = Number.POSITIVE_INFINITY;\n        } else if (canSendMMS === 0 || remoteMMS === 0) {\n          maxMessageSize = Math.max(canSendMMS, remoteMMS);\n        } else {\n          maxMessageSize = Math.min(canSendMMS, remoteMMS);\n        }\n\n        // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n        // attribute.\n        var sctp = {};\n        Object.defineProperty(sctp, 'maxMessageSize', {\n          get: function() {\n            return maxMessageSize;\n          }\n        });\n        pc._sctp = sctp;\n      }\n\n      return origSetRemoteDescription.apply(pc, arguments);\n    };\n  },\n\n  shimSendThrowTypeError: function(window) {\n    if (!window.RTCPeerConnection) {\n      return;\n    }\n\n    // Note: Although Firefox >= 57 has a native implementation, the maximum\n    //       message size can be reset for all data channels at a later stage.\n    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n\n    var origCreateDataChannel =\n      window.RTCPeerConnection.prototype.createDataChannel;\n    window.RTCPeerConnection.prototype.createDataChannel = function() {\n      var pc = this;\n      var dataChannel = origCreateDataChannel.apply(pc, arguments);\n      var origDataChannelSend = dataChannel.send;\n\n      // Patch 'send' method\n      dataChannel.send = function() {\n        var dc = this;\n        var data = arguments[0];\n        var length = data.length || data.size || data.byteLength;\n        if (length > pc.sctp.maxMessageSize) {\n          throw new DOMException('Message too large (can send a maximum of ' +\n            pc.sctp.maxMessageSize + ' bytes)', 'TypeError');\n        }\n        return origDataChannelSend.apply(dc, arguments);\n      };\n\n      return dataChannel;\n    };\n  }\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/webrtc-adapter/src/js/common_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/edge/edge_shim.js":
/*!**************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/edge/edge_shim.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\nvar shimRTCPeerConnection = __webpack_require__(/*! rtcpeerconnection-shim */ \"./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js\");\n\nmodule.exports = {\n  shimGetUserMedia: __webpack_require__(/*! ./getusermedia */ \"./node_modules/webrtc-adapter/src/js/edge/getusermedia.js\"),\n  shimPeerConnection: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    if (window.RTCIceGatherer) {\n      if (!window.RTCIceCandidate) {\n        window.RTCIceCandidate = function(args) {\n          return args;\n        };\n      }\n      if (!window.RTCSessionDescription) {\n        window.RTCSessionDescription = function(args) {\n          return args;\n        };\n      }\n      // this adds an additional event listener to MediaStrackTrack that signals\n      // when a tracks enabled property was changed. Workaround for a bug in\n      // addStream, see below. No longer required in 15025+\n      if (browserDetails.version < 15025) {\n        var origMSTEnabled = Object.getOwnPropertyDescriptor(\n            window.MediaStreamTrack.prototype, 'enabled');\n        Object.defineProperty(window.MediaStreamTrack.prototype, 'enabled', {\n          set: function(value) {\n            origMSTEnabled.set.call(this, value);\n            var ev = new Event('enabled');\n            ev.enabled = value;\n            this.dispatchEvent(ev);\n          }\n        });\n      }\n    }\n\n    // ORTC defines the DTMF sender a bit different.\n    // https://github.com/w3c/ortc/issues/714\n    if (window.RTCRtpSender && !('dtmf' in window.RTCRtpSender.prototype)) {\n      Object.defineProperty(window.RTCRtpSender.prototype, 'dtmf', {\n        get: function() {\n          if (this._dtmf === undefined) {\n            if (this.track.kind === 'audio') {\n              this._dtmf = new window.RTCDtmfSender(this);\n            } else if (this.track.kind === 'video') {\n              this._dtmf = null;\n            }\n          }\n          return this._dtmf;\n        }\n      });\n    }\n    // Edge currently only implements the RTCDtmfSender, not the\n    // RTCDTMFSender alias. See http://draft.ortc.org/#rtcdtmfsender2*\n    if (window.RTCDtmfSender && !window.RTCDTMFSender) {\n      window.RTCDTMFSender = window.RTCDtmfSender;\n    }\n\n    window.RTCPeerConnection =\n        shimRTCPeerConnection(window, browserDetails.version);\n  },\n  shimReplaceTrack: function(window) {\n    // ORTC has replaceTrack -- https://github.com/w3c/ortc/issues/614\n    if (window.RTCRtpSender &&\n        !('replaceTrack' in window.RTCRtpSender.prototype)) {\n      window.RTCRtpSender.prototype.replaceTrack =\n          window.RTCRtpSender.prototype.setTrack;\n    }\n  }\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/webrtc-adapter/src/js/edge/edge_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/edge/getusermedia.js":
/*!*****************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/edge/getusermedia.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\n// Expose public methods.\nmodule.exports = function(window) {\n  var navigator = window && window.navigator;\n\n  var shimError_ = function(e) {\n    return {\n      name: {PermissionDeniedError: 'NotAllowedError'}[e.name] || e.name,\n      message: e.message,\n      constraint: e.constraint,\n      toString: function() {\n        return this.name;\n      }\n    };\n  };\n\n  // getUserMedia error shim.\n  var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n      bind(navigator.mediaDevices);\n  navigator.mediaDevices.getUserMedia = function(c) {\n    return origGetUserMedia(c).catch(function(e) {\n      return Promise.reject(shimError_(e));\n    });\n  };\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/webrtc-adapter/src/js/edge/getusermedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n\nmodule.exports = {\n  shimGetUserMedia: __webpack_require__(/*! ./getusermedia */ \"./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js\"),\n  shimOnTrack: function(window) {\n    if (typeof window === 'object' && window.RTCPeerConnection && !('ontrack' in\n        window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'ontrack', {\n        get: function() {\n          return this._ontrack;\n        },\n        set: function(f) {\n          if (this._ontrack) {\n            this.removeEventListener('track', this._ontrack);\n            this.removeEventListener('addstream', this._ontrackpoly);\n          }\n          this.addEventListener('track', this._ontrack = f);\n          this.addEventListener('addstream', this._ontrackpoly = function(e) {\n            e.stream.getTracks().forEach(function(track) {\n              var event = new Event('track');\n              event.track = track;\n              event.receiver = {track: track};\n              event.transceiver = {receiver: event.receiver};\n              event.streams = [e.stream];\n              this.dispatchEvent(event);\n            }.bind(this));\n          }.bind(this));\n        }\n      });\n    }\n    if (typeof window === 'object' && window.RTCTrackEvent &&\n        ('receiver' in window.RTCTrackEvent.prototype) &&\n        !('transceiver' in window.RTCTrackEvent.prototype)) {\n      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n        get: function() {\n          return {receiver: this.receiver};\n        }\n      });\n    }\n  },\n\n  shimSourceObject: function(window) {\n    // Firefox has supported mozSrcObject since FF22, unprefixed in 42.\n    if (typeof window === 'object') {\n      if (window.HTMLMediaElement &&\n        !('srcObject' in window.HTMLMediaElement.prototype)) {\n        // Shim the srcObject property, once, when HTMLMediaElement is found.\n        Object.defineProperty(window.HTMLMediaElement.prototype, 'srcObject', {\n          get: function() {\n            return this.mozSrcObject;\n          },\n          set: function(stream) {\n            this.mozSrcObject = stream;\n          }\n        });\n      }\n    }\n  },\n\n  shimPeerConnection: function(window) {\n    var browserDetails = utils.detectBrowser(window);\n\n    if (typeof window !== 'object' || !(window.RTCPeerConnection ||\n        window.mozRTCPeerConnection)) {\n      return; // probably media.peerconnection.enabled=false in about:config\n    }\n    // The RTCPeerConnection object.\n    if (!window.RTCPeerConnection) {\n      window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n        if (browserDetails.version < 38) {\n          // .urls is not supported in FF < 38.\n          // create RTCIceServers with a single url.\n          if (pcConfig && pcConfig.iceServers) {\n            var newIceServers = [];\n            for (var i = 0; i < pcConfig.iceServers.length; i++) {\n              var server = pcConfig.iceServers[i];\n              if (server.hasOwnProperty('urls')) {\n                for (var j = 0; j < server.urls.length; j++) {\n                  var newServer = {\n                    url: server.urls[j]\n                  };\n                  if (server.urls[j].indexOf('turn') === 0) {\n                    newServer.username = server.username;\n                    newServer.credential = server.credential;\n                  }\n                  newIceServers.push(newServer);\n                }\n              } else {\n                newIceServers.push(pcConfig.iceServers[i]);\n              }\n            }\n            pcConfig.iceServers = newIceServers;\n          }\n        }\n        return new window.mozRTCPeerConnection(pcConfig, pcConstraints);\n      };\n      window.RTCPeerConnection.prototype =\n          window.mozRTCPeerConnection.prototype;\n\n      // wrap static methods. Currently just generateCertificate.\n      if (window.mozRTCPeerConnection.generateCertificate) {\n        Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n          get: function() {\n            return window.mozRTCPeerConnection.generateCertificate;\n          }\n        });\n      }\n\n      window.RTCSessionDescription = window.mozRTCSessionDescription;\n      window.RTCIceCandidate = window.mozRTCIceCandidate;\n    }\n\n    // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate']\n        .forEach(function(method) {\n          var nativeMethod = window.RTCPeerConnection.prototype[method];\n          window.RTCPeerConnection.prototype[method] = function() {\n            arguments[0] = new ((method === 'addIceCandidate') ?\n                window.RTCIceCandidate :\n                window.RTCSessionDescription)(arguments[0]);\n            return nativeMethod.apply(this, arguments);\n          };\n        });\n\n    // support for addIceCandidate(null or undefined)\n    var nativeAddIceCandidate =\n        window.RTCPeerConnection.prototype.addIceCandidate;\n    window.RTCPeerConnection.prototype.addIceCandidate = function() {\n      if (!arguments[0]) {\n        if (arguments[1]) {\n          arguments[1].apply(null);\n        }\n        return Promise.resolve();\n      }\n      return nativeAddIceCandidate.apply(this, arguments);\n    };\n\n    // shim getStats with maplike support\n    var makeMapStats = function(stats) {\n      var map = new Map();\n      Object.keys(stats).forEach(function(key) {\n        map.set(key, stats[key]);\n        map[key] = stats[key];\n      });\n      return map;\n    };\n\n    var modernStatsTypes = {\n      inboundrtp: 'inbound-rtp',\n      outboundrtp: 'outbound-rtp',\n      candidatepair: 'candidate-pair',\n      localcandidate: 'local-candidate',\n      remotecandidate: 'remote-candidate'\n    };\n\n    var nativeGetStats = window.RTCPeerConnection.prototype.getStats;\n    window.RTCPeerConnection.prototype.getStats = function(\n      selector,\n      onSucc,\n      onErr\n    ) {\n      return nativeGetStats.apply(this, [selector || null])\n        .then(function(stats) {\n          if (browserDetails.version < 48) {\n            stats = makeMapStats(stats);\n          }\n          if (browserDetails.version < 53 && !onSucc) {\n            // Shim only promise getStats with spec-hyphens in type names\n            // Leave callback version alone; misc old uses of forEach before Map\n            try {\n              stats.forEach(function(stat) {\n                stat.type = modernStatsTypes[stat.type] || stat.type;\n              });\n            } catch (e) {\n              if (e.name !== 'TypeError') {\n                throw e;\n              }\n              // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n              stats.forEach(function(stat, i) {\n                stats.set(i, Object.assign({}, stat, {\n                  type: modernStatsTypes[stat.type] || stat.type\n                }));\n              });\n            }\n          }\n          return stats;\n        })\n        .then(onSucc, onErr);\n    };\n  },\n\n  shimRemoveStream: function(window) {\n    if (!window.RTCPeerConnection ||\n        'removeStream' in window.RTCPeerConnection.prototype) {\n      return;\n    }\n    window.RTCPeerConnection.prototype.removeStream = function(stream) {\n      var pc = this;\n      utils.deprecated('removeStream', 'removeTrack');\n      this.getSenders().forEach(function(sender) {\n        if (sender.track && stream.getTracks().indexOf(sender.track) !== -1) {\n          pc.removeTrack(sender);\n        }\n      });\n    };\n  }\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/webrtc-adapter/src/js/firefox/firefox_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js":
/*!********************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\nvar logging = utils.log;\n\n// Expose public methods.\nmodule.exports = function(window) {\n  var browserDetails = utils.detectBrowser(window);\n  var navigator = window && window.navigator;\n  var MediaStreamTrack = window && window.MediaStreamTrack;\n\n  var shimError_ = function(e) {\n    return {\n      name: {\n        InternalError: 'NotReadableError',\n        NotSupportedError: 'TypeError',\n        PermissionDeniedError: 'NotAllowedError',\n        SecurityError: 'NotAllowedError'\n      }[e.name] || e.name,\n      message: {\n        'The operation is insecure.': 'The request is not allowed by the ' +\n        'user agent or the platform in the current context.'\n      }[e.message] || e.message,\n      constraint: e.constraint,\n      toString: function() {\n        return this.name + (this.message && ': ') + this.message;\n      }\n    };\n  };\n\n  // getUserMedia constraints shim.\n  var getUserMedia_ = function(constraints, onSuccess, onError) {\n    var constraintsToFF37_ = function(c) {\n      if (typeof c !== 'object' || c.require) {\n        return c;\n      }\n      var require = [];\n      Object.keys(c).forEach(function(key) {\n        if (key === 'require' || key === 'advanced' || key === 'mediaSource') {\n          return;\n        }\n        var r = c[key] = (typeof c[key] === 'object') ?\n            c[key] : {ideal: c[key]};\n        if (r.min !== undefined ||\n            r.max !== undefined || r.exact !== undefined) {\n          require.push(key);\n        }\n        if (r.exact !== undefined) {\n          if (typeof r.exact === 'number') {\n            r. min = r.max = r.exact;\n          } else {\n            c[key] = r.exact;\n          }\n          delete r.exact;\n        }\n        if (r.ideal !== undefined) {\n          c.advanced = c.advanced || [];\n          var oc = {};\n          if (typeof r.ideal === 'number') {\n            oc[key] = {min: r.ideal, max: r.ideal};\n          } else {\n            oc[key] = r.ideal;\n          }\n          c.advanced.push(oc);\n          delete r.ideal;\n          if (!Object.keys(r).length) {\n            delete c[key];\n          }\n        }\n      });\n      if (require.length) {\n        c.require = require;\n      }\n      return c;\n    };\n    constraints = JSON.parse(JSON.stringify(constraints));\n    if (browserDetails.version < 38) {\n      logging('spec: ' + JSON.stringify(constraints));\n      if (constraints.audio) {\n        constraints.audio = constraintsToFF37_(constraints.audio);\n      }\n      if (constraints.video) {\n        constraints.video = constraintsToFF37_(constraints.video);\n      }\n      logging('ff37: ' + JSON.stringify(constraints));\n    }\n    return navigator.mozGetUserMedia(constraints, onSuccess, function(e) {\n      onError(shimError_(e));\n    });\n  };\n\n  // Returns the result of getUserMedia as a Promise.\n  var getUserMediaPromise_ = function(constraints) {\n    return new Promise(function(resolve, reject) {\n      getUserMedia_(constraints, resolve, reject);\n    });\n  };\n\n  // Shim for mediaDevices on older versions.\n  if (!navigator.mediaDevices) {\n    navigator.mediaDevices = {getUserMedia: getUserMediaPromise_,\n      addEventListener: function() { },\n      removeEventListener: function() { }\n    };\n  }\n  navigator.mediaDevices.enumerateDevices =\n      navigator.mediaDevices.enumerateDevices || function() {\n        return new Promise(function(resolve) {\n          var infos = [\n            {kind: 'audioinput', deviceId: 'default', label: '', groupId: ''},\n            {kind: 'videoinput', deviceId: 'default', label: '', groupId: ''}\n          ];\n          resolve(infos);\n        });\n      };\n\n  if (browserDetails.version < 41) {\n    // Work around http://bugzil.la/1169665\n    var orgEnumerateDevices =\n        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);\n    navigator.mediaDevices.enumerateDevices = function() {\n      return orgEnumerateDevices().then(undefined, function(e) {\n        if (e.name === 'NotFoundError') {\n          return [];\n        }\n        throw e;\n      });\n    };\n  }\n  if (browserDetails.version < 49) {\n    var origGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      return origGetUserMedia(c).then(function(stream) {\n        // Work around https://bugzil.la/802326\n        if (c.audio && !stream.getAudioTracks().length ||\n            c.video && !stream.getVideoTracks().length) {\n          stream.getTracks().forEach(function(track) {\n            track.stop();\n          });\n          throw new DOMException('The object can not be found here.',\n                                 'NotFoundError');\n        }\n        return stream;\n      }, function(e) {\n        return Promise.reject(shimError_(e));\n      });\n    };\n  }\n  if (!(browserDetails.version > 55 &&\n      'autoGainControl' in navigator.mediaDevices.getSupportedConstraints())) {\n    var remap = function(obj, a, b) {\n      if (a in obj && !(b in obj)) {\n        obj[b] = obj[a];\n        delete obj[a];\n      }\n    };\n\n    var nativeGetUserMedia = navigator.mediaDevices.getUserMedia.\n        bind(navigator.mediaDevices);\n    navigator.mediaDevices.getUserMedia = function(c) {\n      if (typeof c === 'object' && typeof c.audio === 'object') {\n        c = JSON.parse(JSON.stringify(c));\n        remap(c.audio, 'autoGainControl', 'mozAutoGainControl');\n        remap(c.audio, 'noiseSuppression', 'mozNoiseSuppression');\n      }\n      return nativeGetUserMedia(c);\n    };\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.getSettings) {\n      var nativeGetSettings = MediaStreamTrack.prototype.getSettings;\n      MediaStreamTrack.prototype.getSettings = function() {\n        var obj = nativeGetSettings.apply(this, arguments);\n        remap(obj, 'mozAutoGainControl', 'autoGainControl');\n        remap(obj, 'mozNoiseSuppression', 'noiseSuppression');\n        return obj;\n      };\n    }\n\n    if (MediaStreamTrack && MediaStreamTrack.prototype.applyConstraints) {\n      var nativeApplyConstraints = MediaStreamTrack.prototype.applyConstraints;\n      MediaStreamTrack.prototype.applyConstraints = function(c) {\n        if (this.kind === 'audio' && typeof c === 'object') {\n          c = JSON.parse(JSON.stringify(c));\n          remap(c, 'autoGainControl', 'mozAutoGainControl');\n          remap(c, 'noiseSuppression', 'mozNoiseSuppression');\n        }\n        return nativeApplyConstraints.apply(this, [c]);\n      };\n    }\n  }\n  navigator.getUserMedia = function(constraints, onSuccess, onError) {\n    if (browserDetails.version < 44) {\n      return getUserMedia_(constraints, onSuccess, onError);\n    }\n    // Replace Firefox 44+'s deprecation warning with unprefixed version.\n    utils.deprecated('navigator.getUserMedia',\n        'navigator.mediaDevices.getUserMedia');\n    navigator.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n  };\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/webrtc-adapter/src/js/firefox/getusermedia.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/safari/safari_shim.js":
/*!******************************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/safari/safari_shim.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/webrtc-adapter/src/js/utils.js\");\n\nmodule.exports = {\n  shimLocalStreamsAPI: function(window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    if (!('getLocalStreams' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getLocalStreams = function() {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        return this._localStreams;\n      };\n    }\n    if (!('getStreamById' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getStreamById = function(id) {\n        var result = null;\n        if (this._localStreams) {\n          this._localStreams.forEach(function(stream) {\n            if (stream.id === id) {\n              result = stream;\n            }\n          });\n        }\n        if (this._remoteStreams) {\n          this._remoteStreams.forEach(function(stream) {\n            if (stream.id === id) {\n              result = stream;\n            }\n          });\n        }\n        return result;\n      };\n    }\n    if (!('addStream' in window.RTCPeerConnection.prototype)) {\n      var _addTrack = window.RTCPeerConnection.prototype.addTrack;\n      window.RTCPeerConnection.prototype.addStream = function(stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        if (this._localStreams.indexOf(stream) === -1) {\n          this._localStreams.push(stream);\n        }\n        var pc = this;\n        stream.getTracks().forEach(function(track) {\n          _addTrack.call(pc, track, stream);\n        });\n      };\n\n      window.RTCPeerConnection.prototype.addTrack = function(track, stream) {\n        if (stream) {\n          if (!this._localStreams) {\n            this._localStreams = [stream];\n          } else if (this._localStreams.indexOf(stream) === -1) {\n            this._localStreams.push(stream);\n          }\n        }\n        return _addTrack.call(this, track, stream);\n      };\n    }\n    if (!('removeStream' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.removeStream = function(stream) {\n        if (!this._localStreams) {\n          this._localStreams = [];\n        }\n        var index = this._localStreams.indexOf(stream);\n        if (index === -1) {\n          return;\n        }\n        this._localStreams.splice(index, 1);\n        var pc = this;\n        var tracks = stream.getTracks();\n        this.getSenders().forEach(function(sender) {\n          if (tracks.indexOf(sender.track) !== -1) {\n            pc.removeTrack(sender);\n          }\n        });\n      };\n    }\n  },\n  shimRemoteStreamsAPI: function(window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    if (!('getRemoteStreams' in window.RTCPeerConnection.prototype)) {\n      window.RTCPeerConnection.prototype.getRemoteStreams = function() {\n        return this._remoteStreams ? this._remoteStreams : [];\n      };\n    }\n    if (!('onaddstream' in window.RTCPeerConnection.prototype)) {\n      Object.defineProperty(window.RTCPeerConnection.prototype, 'onaddstream', {\n        get: function() {\n          return this._onaddstream;\n        },\n        set: function(f) {\n          var pc = this;\n          if (this._onaddstream) {\n            this.removeEventListener('addstream', this._onaddstream);\n            this.removeEventListener('track', this._onaddstreampoly);\n          }\n          this.addEventListener('addstream', this._onaddstream = f);\n          this.addEventListener('track', this._onaddstreampoly = function(e) {\n            e.streams.forEach(function(stream) {\n              if (!pc._remoteStreams) {\n                pc._remoteStreams = [];\n              }\n              if (pc._remoteStreams.indexOf(stream) >= 0) {\n                return;\n              }\n              pc._remoteStreams.push(stream);\n              var event = new Event('addstream');\n              event.stream = stream;\n              pc.dispatchEvent(event);\n            });\n          });\n        }\n      });\n    }\n  },\n  shimCallbacksAPI: function(window) {\n    if (typeof window !== 'object' || !window.RTCPeerConnection) {\n      return;\n    }\n    var prototype = window.RTCPeerConnection.prototype;\n    var createOffer = prototype.createOffer;\n    var createAnswer = prototype.createAnswer;\n    var setLocalDescription = prototype.setLocalDescription;\n    var setRemoteDescription = prototype.setRemoteDescription;\n    var addIceCandidate = prototype.addIceCandidate;\n\n    prototype.createOffer = function(successCallback, failureCallback) {\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      var promise = createOffer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n    prototype.createAnswer = function(successCallback, failureCallback) {\n      var options = (arguments.length >= 2) ? arguments[2] : arguments[0];\n      var promise = createAnswer.apply(this, [options]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n\n    var withCallback = function(description, successCallback, failureCallback) {\n      var promise = setLocalDescription.apply(this, [description]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.setLocalDescription = withCallback;\n\n    withCallback = function(description, successCallback, failureCallback) {\n      var promise = setRemoteDescription.apply(this, [description]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.setRemoteDescription = withCallback;\n\n    withCallback = function(candidate, successCallback, failureCallback) {\n      var promise = addIceCandidate.apply(this, [candidate]);\n      if (!failureCallback) {\n        return promise;\n      }\n      promise.then(successCallback, failureCallback);\n      return Promise.resolve();\n    };\n    prototype.addIceCandidate = withCallback;\n  },\n  shimGetUserMedia: function(window) {\n    var navigator = window && window.navigator;\n\n    if (!navigator.getUserMedia) {\n      if (navigator.webkitGetUserMedia) {\n        navigator.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);\n      } else if (navigator.mediaDevices &&\n          navigator.mediaDevices.getUserMedia) {\n        navigator.getUserMedia = function(constraints, cb, errcb) {\n          navigator.mediaDevices.getUserMedia(constraints)\n          .then(cb, errcb);\n        }.bind(navigator);\n      }\n    }\n  },\n  shimRTCIceServerUrls: function(window) {\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n    var OrigPeerConnection = window.RTCPeerConnection;\n    window.RTCPeerConnection = function(pcConfig, pcConstraints) {\n      if (pcConfig && pcConfig.iceServers) {\n        var newIceServers = [];\n        for (var i = 0; i < pcConfig.iceServers.length; i++) {\n          var server = pcConfig.iceServers[i];\n          if (!server.hasOwnProperty('urls') &&\n              server.hasOwnProperty('url')) {\n            utils.deprecated('RTCIceServer.url', 'RTCIceServer.urls');\n            server = JSON.parse(JSON.stringify(server));\n            server.urls = server.url;\n            delete server.url;\n            newIceServers.push(server);\n          } else {\n            newIceServers.push(pcConfig.iceServers[i]);\n          }\n        }\n        pcConfig.iceServers = newIceServers;\n      }\n      return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n    window.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n    // wrap static methods. Currently just generateCertificate.\n    if ('generateCertificate' in window.RTCPeerConnection) {\n      Object.defineProperty(window.RTCPeerConnection, 'generateCertificate', {\n        get: function() {\n          return OrigPeerConnection.generateCertificate;\n        }\n      });\n    }\n  },\n  shimTrackEventTransceiver: function(window) {\n    // Add event.transceiver member over deprecated event.receiver\n    if (typeof window === 'object' && window.RTCPeerConnection &&\n        ('receiver' in window.RTCTrackEvent.prototype) &&\n        // can't check 'transceiver' in window.RTCTrackEvent.prototype, as it is\n        // defined for some reason even when window.RTCTransceiver is not.\n        !window.RTCTransceiver) {\n      Object.defineProperty(window.RTCTrackEvent.prototype, 'transceiver', {\n        get: function() {\n          return {receiver: this.receiver};\n        }\n      });\n    }\n  },\n\n  shimCreateOfferLegacy: function(window) {\n    var origCreateOffer = window.RTCPeerConnection.prototype.createOffer;\n    window.RTCPeerConnection.prototype.createOffer = function(offerOptions) {\n      var pc = this;\n      if (offerOptions) {\n        var audioTransceiver = pc.getTransceivers().find(function(transceiver) {\n          return transceiver.sender.track &&\n              transceiver.sender.track.kind === 'audio';\n        });\n        if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n          if (audioTransceiver.direction === 'sendrecv') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('sendonly');\n            } else {\n              audioTransceiver.direction = 'sendonly';\n            }\n          } else if (audioTransceiver.direction === 'recvonly') {\n            if (audioTransceiver.setDirection) {\n              audioTransceiver.setDirection('inactive');\n            } else {\n              audioTransceiver.direction = 'inactive';\n            }\n          }\n        } else if (offerOptions.offerToReceiveAudio === true &&\n            !audioTransceiver) {\n          pc.addTransceiver('audio');\n        }\n\n        var videoTransceiver = pc.getTransceivers().find(function(transceiver) {\n          return transceiver.sender.track &&\n              transceiver.sender.track.kind === 'video';\n        });\n        if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n          if (videoTransceiver.direction === 'sendrecv') {\n            videoTransceiver.setDirection('sendonly');\n          } else if (videoTransceiver.direction === 'recvonly') {\n            videoTransceiver.setDirection('inactive');\n          }\n        } else if (offerOptions.offerToReceiveVideo === true &&\n            !videoTransceiver) {\n          pc.addTransceiver('video');\n        }\n      }\n      return origCreateOffer.apply(pc, arguments);\n    };\n  }\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/webrtc-adapter/src/js/safari/safari_shim.js?");

/***/ }),

/***/ "./node_modules/webrtc-adapter/src/js/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/webrtc-adapter/src/js/utils.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar logDisabled_ = true;\nvar deprecationWarnings_ = true;\n\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */\nfunction extractVersion(uastring, expr, pos) {\n  var match = uastring.match(expr);\n  return match && match.length >= pos && parseInt(match[pos], 10);\n}\n\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object.\nfunction wrapPeerConnectionEvent(window, eventNameToWrap, wrapper) {\n  if (!window.RTCPeerConnection) {\n    return;\n  }\n  var proto = window.RTCPeerConnection.prototype;\n  var nativeAddEventListener = proto.addEventListener;\n  proto.addEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap) {\n      return nativeAddEventListener.apply(this, arguments);\n    }\n    var wrappedCallback = function(e) {\n      cb(wrapper(e));\n    };\n    this._eventMap = this._eventMap || {};\n    this._eventMap[cb] = wrappedCallback;\n    return nativeAddEventListener.apply(this, [nativeEventName,\n      wrappedCallback]);\n  };\n\n  var nativeRemoveEventListener = proto.removeEventListener;\n  proto.removeEventListener = function(nativeEventName, cb) {\n    if (nativeEventName !== eventNameToWrap || !this._eventMap\n        || !this._eventMap[cb]) {\n      return nativeRemoveEventListener.apply(this, arguments);\n    }\n    var unwrappedCb = this._eventMap[cb];\n    delete this._eventMap[cb];\n    return nativeRemoveEventListener.apply(this, [nativeEventName,\n      unwrappedCb]);\n  };\n\n  Object.defineProperty(proto, 'on' + eventNameToWrap, {\n    get: function() {\n      return this['_on' + eventNameToWrap];\n    },\n    set: function(cb) {\n      if (this['_on' + eventNameToWrap]) {\n        this.removeEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap]);\n        delete this['_on' + eventNameToWrap];\n      }\n      if (cb) {\n        this.addEventListener(eventNameToWrap,\n            this['_on' + eventNameToWrap] = cb);\n      }\n    }\n  });\n}\n\n// Utility methods.\nmodule.exports = {\n  extractVersion: extractVersion,\n  wrapPeerConnectionEvent: wrapPeerConnectionEvent,\n  disableLog: function(bool) {\n    if (typeof bool !== 'boolean') {\n      return new Error('Argument type: ' + typeof bool +\n          '. Please use a boolean.');\n    }\n    logDisabled_ = bool;\n    return (bool) ? 'adapter.js logging disabled' :\n        'adapter.js logging enabled';\n  },\n\n  /**\n   * Disable or enable deprecation warnings\n   * @param {!boolean} bool set to true to disable warnings.\n   */\n  disableWarnings: function(bool) {\n    if (typeof bool !== 'boolean') {\n      return new Error('Argument type: ' + typeof bool +\n          '. Please use a boolean.');\n    }\n    deprecationWarnings_ = !bool;\n    return 'adapter.js deprecation warnings ' + (bool ? 'disabled' : 'enabled');\n  },\n\n  log: function() {\n    if (typeof window === 'object') {\n      if (logDisabled_) {\n        return;\n      }\n      if (typeof console !== 'undefined' && typeof console.log === 'function') {\n        console.log.apply(console, arguments);\n      }\n    }\n  },\n\n  /**\n   * Shows a deprecation warning suggesting the modern and spec-compatible API.\n   */\n  deprecated: function(oldMethod, newMethod) {\n    if (!deprecationWarnings_) {\n      return;\n    }\n    console.warn(oldMethod + ' is deprecated, please use ' + newMethod +\n        ' instead.');\n  },\n\n  /**\n   * Browser detector.\n   *\n   * @return {object} result containing browser and version\n   *     properties.\n   */\n  detectBrowser: function(window) {\n    var navigator = window && window.navigator;\n\n    // Returned result object.\n    var result = {};\n    result.browser = null;\n    result.version = null;\n\n    // Fail early if it's not a browser\n    if (typeof window === 'undefined' || !window.navigator) {\n      result.browser = 'Not a browser.';\n      return result;\n    }\n\n    if (navigator.mozGetUserMedia) { // Firefox.\n      result.browser = 'firefox';\n      result.version = extractVersion(navigator.userAgent,\n          /Firefox\\/(\\d+)\\./, 1);\n    } else if (navigator.webkitGetUserMedia) {\n      // Chrome, Chromium, Webview, Opera.\n      // Version matches Chrome/WebRTC version.\n      result.browser = 'chrome';\n      result.version = extractVersion(navigator.userAgent,\n          /Chrom(e|ium)\\/(\\d+)\\./, 2);\n    } else if (navigator.mediaDevices &&\n        navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)) { // Edge.\n      result.browser = 'edge';\n      result.version = extractVersion(navigator.userAgent,\n          /Edge\\/(\\d+).(\\d+)$/, 2);\n    } else if (window.RTCPeerConnection &&\n        navigator.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) { // Safari.\n      result.browser = 'safari';\n      result.version = extractVersion(navigator.userAgent,\n          /AppleWebKit\\/(\\d+)\\./, 1);\n    } else { // Default fallthrough: not supported.\n      result.browser = 'Not a supported browser.';\n      return result;\n    }\n\n    return result;\n  }\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/webrtc-adapter/src/js/utils.js?");

/***/ }),

/***/ "./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nconst WebSocket = __webpack_require__(/*! ./lib/WebSocket */ \"./node_modules/ws/lib/WebSocket.js\");\n\nWebSocket.Server = __webpack_require__(/*! ./lib/WebSocketServer */ \"./node_modules/ws/lib/WebSocketServer.js\");\nWebSocket.Receiver = __webpack_require__(/*! ./lib/Receiver */ \"./node_modules/ws/lib/Receiver.js\");\nWebSocket.Sender = __webpack_require__(/*! ./lib/Sender */ \"./node_modules/ws/lib/Sender.js\");\n\nmodule.exports = WebSocket;\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ws/index.js?");

/***/ }),

/***/ "./node_modules/ws/lib/BufferUtil.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/BufferUtil.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\");\n\nconst Buffer = safeBuffer.Buffer;\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nconst concat = (list, totalLength) => {\n  const target = Buffer.allocUnsafe(totalLength);\n  var offset = 0;\n\n  for (var i = 0; i < list.length; i++) {\n    const buf = list[i];\n    buf.copy(target, offset);\n    offset += buf.length;\n  }\n\n  return target;\n};\n\ntry {\n  const bufferUtil = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"bufferutil\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n  module.exports = Object.assign({ concat }, bufferUtil.BufferUtil || bufferUtil);\n} catch (e) /* istanbul ignore next */ {\n  /**\n   * Masks a buffer using the given mask.\n   *\n   * @param {Buffer} source The buffer to mask\n   * @param {Buffer} mask The mask to use\n   * @param {Buffer} output The buffer where to store the result\n   * @param {Number} offset The offset at which to start writing\n   * @param {Number} length The number of bytes to mask.\n   * @public\n   */\n  const mask = (source, mask, output, offset, length) => {\n    for (var i = 0; i < length; i++) {\n      output[offset + i] = source[i] ^ mask[i & 3];\n    }\n  };\n\n  /**\n   * Unmasks a buffer using the given mask.\n   *\n   * @param {Buffer} buffer The buffer to unmask\n   * @param {Buffer} mask The mask to use\n   * @public\n   */\n  const unmask = (buffer, mask) => {\n    // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n    const length = buffer.length;\n    for (var i = 0; i < length; i++) {\n      buffer[i] ^= mask[i & 3];\n    }\n  };\n\n  module.exports = { concat, mask, unmask };\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ws/lib/BufferUtil.js?");

/***/ }),

/***/ "./node_modules/ws/lib/Constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/Constants.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\");\n\nconst Buffer = safeBuffer.Buffer;\n\nexports.BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\nexports.GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\nexports.EMPTY_BUFFER = Buffer.alloc(0);\nexports.NOOP = () => {};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ws/lib/Constants.js?");

/***/ }),

/***/ "./node_modules/ws/lib/ErrorCodes.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/ErrorCodes.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nmodule.exports = {\n  isValidErrorCode: function (code) {\n    return (code >= 1000 && code <= 1013 && code !== 1004 && code !== 1005 && code !== 1006) ||\n      (code >= 3000 && code <= 4999);\n  },\n  1000: 'normal',\n  1001: 'going away',\n  1002: 'protocol error',\n  1003: 'unsupported data',\n  1004: 'reserved',\n  1005: 'reserved for extensions',\n  1006: 'reserved for extensions',\n  1007: 'inconsistent or invalid data',\n  1008: 'policy violation',\n  1009: 'message too big',\n  1010: 'extension handshake missing',\n  1011: 'an unexpected condition prevented the request from being fulfilled',\n  1012: 'service restart',\n  1013: 'try again later'\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ws/lib/ErrorCodes.js?");

/***/ }),

/***/ "./node_modules/ws/lib/EventTarget.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/EventTarget.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Class representing an event.\n *\n * @private\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} target A reference to the target to which the event was dispatched\n   */\n  constructor (type, target) {\n    this.target = target;\n    this.type = type;\n  }\n}\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n * @private\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor (data, target) {\n    super('message', target);\n\n    this.data = data;\n  }\n}\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n * @private\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {Number} code The status code explaining why the connection is being closed\n   * @param {String} reason A human-readable string explaining why the connection is closing\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor (code, reason, target) {\n    super('close', target);\n\n    this.wasClean = target._closeFrameReceived && target._closeFrameSent;\n    this.reason = reason;\n    this.code = code;\n  }\n}\n\n/**\n * Class representing an open event.\n *\n * @extends Event\n * @private\n */\nclass OpenEvent extends Event {\n  /**\n   * Create a new `OpenEvent`.\n   *\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor (target) {\n    super('open', target);\n  }\n}\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} method A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @public\n   */\n  addEventListener (method, listener) {\n    if (typeof listener !== 'function') return;\n\n    function onMessage (data) {\n      listener.call(this, new MessageEvent(data, this));\n    }\n\n    function onClose (code, message) {\n      listener.call(this, new CloseEvent(code, message, this));\n    }\n\n    function onError (event) {\n      event.type = 'error';\n      event.target = this;\n      listener.call(this, event);\n    }\n\n    function onOpen () {\n      listener.call(this, new OpenEvent(this));\n    }\n\n    if (method === 'message') {\n      onMessage._listener = listener;\n      this.on(method, onMessage);\n    } else if (method === 'close') {\n      onClose._listener = listener;\n      this.on(method, onClose);\n    } else if (method === 'error') {\n      onError._listener = listener;\n      this.on(method, onError);\n    } else if (method === 'open') {\n      onOpen._listener = listener;\n      this.on(method, onOpen);\n    } else {\n      this.on(method, listener);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} method A string representing the event type to remove\n   * @param {Function} listener The listener to remove\n   * @public\n   */\n  removeEventListener (method, listener) {\n    const listeners = this.listeners(method);\n\n    for (var i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener || listeners[i]._listener === listener) {\n        this.removeListener(method, listeners[i]);\n      }\n    }\n  }\n};\n\nmodule.exports = EventTarget;\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ws/lib/EventTarget.js?");

/***/ }),

/***/ "./node_modules/ws/lib/Extensions.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/Extensions.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push (dest, name, elem) {\n  if (Object.prototype.hasOwnProperty.call(dest, name)) dest[name].push(elem);\n  else dest[name] = [elem];\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse (header) {\n  const offers = {};\n\n  if (header === undefined || header === '') return offers;\n\n  var params = {};\n  var mustUnescape = false;\n  var isEscaping = false;\n  var inQuotes = false;\n  var extensionName;\n  var paramName;\n  var start = -1;\n  var end = -1;\n\n  for (var i = 0; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20/* ' ' */|| code === 0x09/* '\\t' */) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b/* ';' */ || code === 0x2c/* ',' */) {\n        if (start === -1) throw new Error(`unexpected character at index ${i}`);\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = {};\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new Error(`unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) throw new Error(`unexpected character at index ${i}`);\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = {};\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d/* '=' */&& start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new Error(`unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new Error(`unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22/* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c/* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new Error(`unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) throw new Error(`unexpected character at index ${i}`);\n\n        if (end === -1) end = i;\n        var value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = {};\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new Error(`unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes) throw new Error('unexpected end of input');\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, {});\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Serializes a parsed `Sec-WebSocket-Extensions` header to a string.\n *\n * @param {Object} value The object to format\n * @return {String} A string representing the given value\n * @public\n */\nfunction format (value) {\n  return Object.keys(value).map((token) => {\n    var paramsList = value[token];\n    if (!Array.isArray(paramsList)) paramsList = [paramsList];\n    return paramsList.map((params) => {\n      return [token].concat(Object.keys(params).map((k) => {\n        var p = params[k];\n        if (!Array.isArray(p)) p = [p];\n        return p.map((v) => v === true ? k : `${k}=${v}`).join('; ');\n      })).join('; ');\n    }).join(', ');\n  }).join(', ');\n}\n\nmodule.exports = { format, parse };\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ws/lib/Extensions.js?");

/***/ }),

/***/ "./node_modules/ws/lib/PerMessageDeflate.js":
/*!**************************************************!*\
  !*** ./node_modules/ws/lib/PerMessageDeflate.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\");\nconst Limiter = __webpack_require__(/*! async-limiter */ \"./node_modules/async-limiter/index.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./BufferUtil */ \"./node_modules/ws/lib/BufferUtil.js\");\n\nconst Buffer = safeBuffer.Buffer;\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst EMPTY_BLOCK = Buffer.from([0x00]);\n\nconst kWriteInProgress = Symbol('write-in-progress');\nconst kPendingClose = Symbol('pending-close');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\nconst kOwner = Symbol('owner');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\n   *     of server context takeover\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\n   *     disabling of client context takeover\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\n   *     for, or request, a custom client window size\n   * @param {Number} options.level The value of zlib's `level` param\n   * @param {Number} options.memLevel The value of zlib's `memLevel` param\n   * @param {Number} options.threshold Size (in bytes) below which messages\n   *     should not be compressed\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\n   *     zlib\n   * @param {Boolean} isServer Create the instance in either server or client\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor (options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== undefined\n      ? this._options.threshold\n      : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== undefined\n        ? this._options.concurrencyLimit\n        : 10;\n      zlibLimiter = new Limiter({ concurrency });\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName () {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create extension parameters offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer () {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept extension offer.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept (paramsList) {\n    paramsList = this.normalizeParams(paramsList);\n\n    var params;\n    if (this._isServer) {\n      params = this.acceptAsServer(paramsList);\n    } else {\n      params = this.acceptAsClient(paramsList);\n    }\n\n    this.params = params;\n    return params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup () {\n    if (this._inflate) {\n      if (this._inflate[kWriteInProgress]) {\n        this._inflate[kPendingClose] = true;\n      } else {\n        this._inflate.close();\n        this._inflate = null;\n      }\n    }\n    if (this._deflate) {\n      if (this._deflate[kWriteInProgress]) {\n        this._deflate[kPendingClose] = true;\n      } else {\n        this._deflate.close();\n        this._deflate = null;\n      }\n    }\n  }\n\n  /**\n   * Accept extension offer from client.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer (paramsList) {\n    const accepted = {};\n    const result = paramsList.some((params) => {\n      if (\n        (this._options.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (this._options.serverMaxWindowBits === false &&\n          params.server_max_window_bits) ||\n        (typeof this._options.serverMaxWindowBits === 'number' &&\n          typeof params.server_max_window_bits === 'number' &&\n          this._options.serverMaxWindowBits > params.server_max_window_bits) ||\n        (typeof this._options.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return;\n      }\n\n      if (\n        this._options.serverNoContextTakeover ||\n        params.server_no_context_takeover\n      ) {\n        accepted.server_no_context_takeover = true;\n      }\n      if (\n        this._options.clientNoContextTakeover ||\n        (this._options.clientNoContextTakeover !== false &&\n          params.client_no_context_takeover)\n      ) {\n        accepted.client_no_context_takeover = true;\n      }\n      if (typeof this._options.serverMaxWindowBits === 'number') {\n        accepted.server_max_window_bits = this._options.serverMaxWindowBits;\n      } else if (typeof params.server_max_window_bits === 'number') {\n        accepted.server_max_window_bits = params.server_max_window_bits;\n      }\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        accepted.client_max_window_bits = this._options.clientMaxWindowBits;\n      } else if (\n        this._options.clientMaxWindowBits !== false &&\n        typeof params.client_max_window_bits === 'number'\n      ) {\n        accepted.client_max_window_bits = params.client_max_window_bits;\n      }\n      return true;\n    });\n\n    if (!result) throw new Error(\"Doesn't support the offered configuration\");\n\n    return accepted;\n  }\n\n  /**\n   * Accept extension response from server.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient (paramsList) {\n    const params = paramsList[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Invalid value for \"client_no_context_takeover\"');\n    }\n\n    if (\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        (!params.client_max_window_bits ||\n          params.client_max_window_bits > this._options.clientMaxWindowBits)) ||\n      (this._options.clientMaxWindowBits === false &&\n        params.client_max_window_bits)\n    ) {\n      throw new Error('Invalid value for \"client_max_window_bits\"');\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize extensions parameters.\n   *\n   * @param {Array} paramsList Extension parameters\n   * @return {Array} Normalized extensions parameters\n   * @private\n   */\n  normalizeParams (paramsList) {\n    return paramsList.map((params) => {\n      Object.keys(params).forEach((key) => {\n        var value = params[key];\n        if (value.length > 1) {\n          throw new Error(`Multiple extension parameters for ${key}`);\n        }\n\n        value = value[0];\n\n        switch (key) {\n          case 'server_no_context_takeover':\n          case 'client_no_context_takeover':\n            if (value !== true) {\n              throw new Error(`invalid extension parameter value for ${key} (${value})`);\n            }\n            params[key] = true;\n            break;\n          case 'server_max_window_bits':\n          case 'client_max_window_bits':\n            if (typeof value === 'string') {\n              value = parseInt(value, 10);\n              if (\n                Number.isNaN(value) ||\n                value < zlib.Z_MIN_WINDOWBITS ||\n                value > zlib.Z_MAX_WINDOWBITS\n              ) {\n                throw new Error(`invalid extension parameter value for ${key} (${value})`);\n              }\n            }\n            if (!this._isServer && value === true) {\n              throw new Error(`Missing extension parameter value for ${key}`);\n            }\n            params[key] = value;\n            break;\n          default:\n            throw new Error(`Not defined extension parameter (${key})`);\n        }\n      });\n      return params;\n    });\n  }\n\n  /**\n   * Decompress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress (data, fin, callback) {\n    zlibLimiter.push((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited by async-limiter.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress (data, fin, callback) {\n    zlibLimiter.push((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress (data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number'\n        ? zlib.Z_DEFAULT_WINDOWBITS\n        : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({ windowBits });\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate[kOwner] = this;\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n    this._inflate[kWriteInProgress] = true;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (\n        (fin && this.params[`${endpoint}_no_context_takeover`]) ||\n        this._inflate[kPendingClose]\n      ) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kWriteInProgress] = false;\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress (data, fin, callback) {\n    if (!data || data.length === 0) {\n      process.nextTick(callback, null, EMPTY_BLOCK);\n      return;\n    }\n\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== 'number'\n        ? zlib.Z_DEFAULT_WINDOWBITS\n        : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        memLevel: this._options.memLevel,\n        level: this._options.level,\n        flush: zlib.Z_SYNC_FLUSH,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      //\n      // `zlib.DeflateRaw` emits an `'error'` event only when an attempt to use\n      // it is made after it has already been closed. This cannot happen here,\n      // so we only add a listener for the `'data'` event.\n      //\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kWriteInProgress] = true;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      var data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      if (\n        (fin && this.params[`${endpoint}_no_context_takeover`]) ||\n        this._deflate[kPendingClose]\n      ) {\n        this._deflate.close();\n        this._deflate = null;\n      } else {\n        this._deflate[kWriteInProgress] = false;\n        this._deflate[kTotalLength] = 0;\n        this._deflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData (chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData (chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kOwner]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kOwner]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new Error('max payload size exceeded');\n  this[kError].closeCode = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError (err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kOwner]._inflate = null;\n  this[kCallback](err);\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ws/lib/PerMessageDeflate.js?");

/***/ }),

/***/ "./node_modules/ws/lib/Receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/Receiver.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./PerMessageDeflate */ \"./node_modules/ws/lib/PerMessageDeflate.js\");\nconst isValidUTF8 = __webpack_require__(/*! ./Validation */ \"./node_modules/ws/lib/Validation.js\");\nconst bufferUtil = __webpack_require__(/*! ./BufferUtil */ \"./node_modules/ws/lib/BufferUtil.js\");\nconst ErrorCodes = __webpack_require__(/*! ./ErrorCodes */ \"./node_modules/ws/lib/ErrorCodes.js\");\nconst constants = __webpack_require__(/*! ./Constants */ \"./node_modules/ws/lib/Constants.js\");\n\nconst Buffer = safeBuffer.Buffer;\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n */\nclass Receiver {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Number} maxPayload The maximum allowed message length\n   * @param {String} binaryType The type for binary data\n   */\n  constructor (extensions, maxPayload, binaryType) {\n    this._binaryType = binaryType || constants.BINARY_TYPES[0];\n    this._extensions = extensions || {};\n    this._maxPayload = maxPayload | 0;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._mask = null;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._cleanupCallback = null;\n    this._hadError = false;\n    this._dead = false;\n    this._loop = false;\n\n    this.onmessage = null;\n    this.onclose = null;\n    this.onerror = null;\n    this.onping = null;\n    this.onpong = null;\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Consumes bytes from the available buffered data.\n   *\n   * @param {Number} bytes The number of bytes to consume\n   * @return {Buffer} Consumed bytes\n   * @private\n   */\n  readBuffer (bytes) {\n    var offset = 0;\n    var dst;\n    var l;\n\n    this._bufferedBytes -= bytes;\n\n    if (bytes === this._buffers[0].length) return this._buffers.shift();\n\n    if (bytes < this._buffers[0].length) {\n      dst = this._buffers[0].slice(0, bytes);\n      this._buffers[0] = this._buffers[0].slice(bytes);\n      return dst;\n    }\n\n    dst = Buffer.allocUnsafe(bytes);\n\n    while (bytes > 0) {\n      l = this._buffers[0].length;\n\n      if (bytes >= l) {\n        this._buffers[0].copy(dst, offset);\n        offset += l;\n        this._buffers.shift();\n      } else {\n        this._buffers[0].copy(dst, offset, 0, bytes);\n        this._buffers[0] = this._buffers[0].slice(bytes);\n      }\n\n      bytes -= l;\n    }\n\n    return dst;\n  }\n\n  /**\n   * Checks if the number of buffered bytes is bigger or equal than `n` and\n   * calls `cleanup` if necessary.\n   *\n   * @param {Number} n The number of bytes to check against\n   * @return {Boolean} `true` if `bufferedBytes >= n`, else `false`\n   * @private\n   */\n  hasBufferedBytes (n) {\n    if (this._bufferedBytes >= n) return true;\n\n    this._loop = false;\n    if (this._dead) this.cleanup(this._cleanupCallback);\n    return false;\n  }\n\n  /**\n   * Adds new data to the parser.\n   *\n   * @public\n   */\n  add (data) {\n    if (this._dead) return;\n\n    this._bufferedBytes += data.length;\n    this._buffers.push(data);\n    this.startLoop();\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @private\n   */\n  startLoop () {\n    this._loop = true;\n\n    while (this._loop) {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData();\n          break;\n        default: // `INFLATING`\n          this._loop = false;\n      }\n    }\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @private\n   */\n  getInfo () {\n    if (!this.hasBufferedBytes(2)) return;\n\n    const buf = this.readBuffer(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this.error(new Error('RSV2 and RSV3 must be clear'), 1002);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this.error(new Error('RSV1 must be clear'), 1002);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this.error(new Error('RSV1 must be clear'), 1002);\n        return;\n      }\n\n      if (!this._fragmented) {\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n        return;\n      } else {\n        this._opcode = this._fragmented;\n      }\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this.error(new Error('FIN must be set'), 1002);\n        return;\n      }\n\n      if (compressed) {\n        this.error(new Error('RSV1 must be clear'), 1002);\n        return;\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this.error(new Error('invalid payload length'), 1002);\n        return;\n      }\n    } else {\n      this.error(new Error(`invalid opcode: ${this._opcode}`), 1002);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @private\n   */\n  getPayloadLength16 () {\n    if (!this.hasBufferedBytes(2)) return;\n\n    this._payloadLength = this.readBuffer(2).readUInt16BE(0, true);\n    this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @private\n   */\n  getPayloadLength64 () {\n    if (!this.hasBufferedBytes(8)) return;\n\n    const buf = this.readBuffer(8);\n    const num = buf.readUInt32BE(0, true);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this.error(new Error('max payload size exceeded'), 1009);\n      return;\n    }\n\n    this._payloadLength = (num * Math.pow(2, 32)) + buf.readUInt32BE(4, true);\n    this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @private\n   */\n  haveLength () {\n    if (this._opcode < 0x08 && this.maxPayloadExceeded(this._payloadLength)) {\n      return;\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask () {\n    if (!this.hasBufferedBytes(4)) return;\n\n    this._mask = this.readBuffer(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @private\n   */\n  getData () {\n    var data = constants.EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (!this.hasBufferedBytes(this._payloadLength)) return;\n\n      data = this.readBuffer(this._payloadLength);\n      if (this._masked) bufferUtil.unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data);\n    } else if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data);\n    } else if (this.pushFragment(data)) {\n      this.dataMessage();\n    }\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @private\n   */\n  decompress (data) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) {\n        this.error(err, err.closeCode === 1009 ? 1009 : 1007);\n        return;\n      }\n\n      if (this.pushFragment(buf)) this.dataMessage();\n      this.startLoop();\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @private\n   */\n  dataMessage () {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        var data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = toBuffer(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(toBuffer(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.onmessage(data);\n      } else {\n        const buf = toBuffer(fragments, messageLength);\n\n        if (!isValidUTF8(buf)) {\n          this.error(new Error('invalid utf8 sequence'), 1007);\n          return;\n        }\n\n        this.onmessage(buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @private\n   */\n  controlMessage (data) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this.onclose(1000, '');\n        this._loop = false;\n        this.cleanup(this._cleanupCallback);\n      } else if (data.length === 1) {\n        this.error(new Error('invalid payload length'), 1002);\n      } else {\n        const code = data.readUInt16BE(0, true);\n\n        if (!ErrorCodes.isValidErrorCode(code)) {\n          this.error(new Error(`invalid status code: ${code}`), 1002);\n          return;\n        }\n\n        const buf = data.slice(2);\n\n        if (!isValidUTF8(buf)) {\n          this.error(new Error('invalid utf8 sequence'), 1007);\n          return;\n        }\n\n        this.onclose(code, buf.toString());\n        this._loop = false;\n        this.cleanup(this._cleanupCallback);\n      }\n\n      return;\n    }\n\n    if (this._opcode === 0x09) this.onping(data);\n    else this.onpong(data);\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles an error.\n   *\n   * @param {Error} err The error\n   * @param {Number} code Close code\n   * @private\n   */\n  error (err, code) {\n    this.onerror(err, code);\n    this._hadError = true;\n    this._loop = false;\n    this.cleanup(this._cleanupCallback);\n  }\n\n  /**\n   * Checks payload size, disconnects socket when it exceeds `maxPayload`.\n   *\n   * @param {Number} length Payload length\n   * @private\n   */\n  maxPayloadExceeded (length) {\n    if (length === 0 || this._maxPayload < 1) return false;\n\n    const fullLength = this._totalPayloadLength + length;\n\n    if (fullLength <= this._maxPayload) {\n      this._totalPayloadLength = fullLength;\n      return false;\n    }\n\n    this.error(new Error('max payload size exceeded'), 1009);\n    return true;\n  }\n\n  /**\n   * Appends a fragment in the fragments array after checking that the sum of\n   * fragment lengths does not exceed `maxPayload`.\n   *\n   * @param {Buffer} fragment The fragment to add\n   * @return {Boolean} `true` if `maxPayload` is not exceeded, else `false`\n   * @private\n   */\n  pushFragment (fragment) {\n    if (fragment.length === 0) return true;\n\n    const totalLength = this._messageLength + fragment.length;\n\n    if (this._maxPayload < 1 || totalLength <= this._maxPayload) {\n      this._messageLength = totalLength;\n      this._fragments.push(fragment);\n      return true;\n    }\n\n    this.error(new Error('max payload size exceeded'), 1009);\n    return false;\n  }\n\n  /**\n   * Releases resources used by the receiver.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  cleanup (cb) {\n    this._dead = true;\n\n    if (!this._hadError && (this._loop || this._state === INFLATING)) {\n      this._cleanupCallback = cb;\n    } else {\n      this._extensions = null;\n      this._fragments = null;\n      this._buffers = null;\n      this._mask = null;\n\n      this._cleanupCallback = null;\n      this.onmessage = null;\n      this.onclose = null;\n      this.onerror = null;\n      this.onping = null;\n      this.onpong = null;\n\n      if (cb) cb();\n    }\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Makes a buffer from a list of fragments.\n *\n * @param {Buffer[]} fragments The list of fragments composing the message\n * @param {Number} messageLength The length of the message\n * @return {Buffer}\n * @private\n */\nfunction toBuffer (fragments, messageLength) {\n  if (fragments.length === 1) return fragments[0];\n  if (fragments.length > 1) return bufferUtil.concat(fragments, messageLength);\n  return constants.EMPTY_BUFFER;\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n */\nfunction toArrayBuffer (buf) {\n  if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ws/lib/Receiver.js?");

/***/ }),

/***/ "./node_modules/ws/lib/Sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/Sender.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./PerMessageDeflate */ \"./node_modules/ws/lib/PerMessageDeflate.js\");\nconst bufferUtil = __webpack_require__(/*! ./BufferUtil */ \"./node_modules/ws/lib/BufferUtil.js\");\nconst ErrorCodes = __webpack_require__(/*! ./ErrorCodes */ \"./node_modules/ws/lib/ErrorCodes.js\");\nconst constants = __webpack_require__(/*! ./Constants */ \"./node_modules/ws/lib/Constants.js\");\n\nconst Buffer = safeBuffer.Buffer;\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  constructor (socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n  static frame (data, options) {\n    const merge = data.length < 1024 || (options.mask && options.readOnly);\n    var offset = options.mask ? 6 : 2;\n    var payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2, true);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2, true);\n      target.writeUInt32BE(data.length, 6, true);\n    }\n\n    if (!options.mask) {\n      target[1] = payloadLength;\n      if (merge) {\n        data.copy(target, offset);\n        return [target];\n      }\n\n      return [target, data];\n    }\n\n    const mask = crypto.randomBytes(4);\n\n    target[1] = payloadLength | 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      bufferUtil.mask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    bufferUtil.mask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */\n  close (code, data, mask, cb) {\n    var buf;\n\n    if (code === undefined) {\n      code = 1000;\n    } else if (typeof code !== 'number' || !ErrorCodes.isValidErrorCode(code)) {\n      throw new Error('first argument must be a valid error code number');\n    }\n\n    if (data === undefined || data === '') {\n      if (code === 1000) {\n        buf = constants.EMPTY_BUFFER;\n      } else {\n        buf = Buffer.allocUnsafe(2);\n        buf.writeUInt16BE(code, 0, true);\n      }\n    } else {\n      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\n      buf.writeUInt16BE(code, 0, true);\n      buf.write(data, 2);\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */\n  doClose (data, mask, cb) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x08,\n      mask,\n      readOnly: false\n    }), cb);\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @public\n   */\n  ping (data, mask) {\n    var readOnly = true;\n\n    if (!Buffer.isBuffer(data)) {\n      if (data instanceof ArrayBuffer) {\n        data = Buffer.from(data);\n      } else if (ArrayBuffer.isView(data)) {\n        data = viewToBuffer(data);\n      } else {\n        data = Buffer.from(data);\n        readOnly = false;\n      }\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, data, mask, readOnly]);\n    } else {\n      this.doPing(data, mask, readOnly);\n    }\n  }\n\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @private\n   */\n  doPing (data, mask, readOnly) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x09,\n      mask,\n      readOnly\n    }));\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @public\n   */\n  pong (data, mask) {\n    var readOnly = true;\n\n    if (!Buffer.isBuffer(data)) {\n      if (data instanceof ArrayBuffer) {\n        data = Buffer.from(data);\n      } else if (ArrayBuffer.isView(data)) {\n        data = viewToBuffer(data);\n      } else {\n        data = Buffer.from(data);\n        readOnly = false;\n      }\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, data, mask, readOnly]);\n    } else {\n      this.doPong(data, mask, readOnly);\n    }\n  }\n\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @private\n   */\n  doPong (data, mask, readOnly) {\n    this.sendFrame(Sender.frame(data, {\n      fin: true,\n      rsv1: false,\n      opcode: 0x0a,\n      mask,\n      readOnly\n    }));\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  send (data, options, cb) {\n    var opcode = options.binary ? 2 : 1;\n    var rsv1 = options.compress;\n    var readOnly = true;\n\n    if (!Buffer.isBuffer(data)) {\n      if (data instanceof ArrayBuffer) {\n        data = Buffer.from(data);\n      } else if (ArrayBuffer.isView(data)) {\n        data = viewToBuffer(data);\n      } else {\n        data = Buffer.from(data);\n        readOnly = false;\n      }\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = data.length >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(Sender.frame(data, {\n        fin: options.fin,\n        rsv1: false,\n        opcode,\n        mask: options.mask,\n        readOnly\n      }), cb);\n    }\n  }\n\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */\n  dispatch (data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this._deflating = false;\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue () {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      params[0].apply(this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue (params) {\n    this._bufferedBytes += params[1].length;\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */\n  sendFrame (list, cb) {\n    if (list.length === 2) {\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n/**\n * Converts an `ArrayBuffer` view into a buffer.\n *\n * @param {(DataView|TypedArray)} view The view to convert\n * @return {Buffer} Converted view\n * @private\n */\nfunction viewToBuffer (view) {\n  const buf = Buffer.from(view.buffer);\n\n  if (view.byteLength !== view.buffer.byteLength) {\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\n  }\n\n  return buf;\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ws/lib/Sender.js?");

/***/ }),

/***/ "./node_modules/ws/lib/Validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/Validation.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\ntry {\n  const isValidUTF8 = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"utf-8-validate\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\n  module.exports = typeof isValidUTF8 === 'object'\n    ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0\n    : isValidUTF8;\n} catch (e) /* istanbul ignore next */ {\n  module.exports = () => true;\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ws/lib/Validation.js?");

/***/ }),

/***/ "./node_modules/ws/lib/WebSocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/WebSocket.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst Ultron = __webpack_require__(/*! ultron */ \"./node_modules/ultron/index.js\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst url = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./PerMessageDeflate */ \"./node_modules/ws/lib/PerMessageDeflate.js\");\nconst EventTarget = __webpack_require__(/*! ./EventTarget */ \"./node_modules/ws/lib/EventTarget.js\");\nconst Extensions = __webpack_require__(/*! ./Extensions */ \"./node_modules/ws/lib/Extensions.js\");\nconst constants = __webpack_require__(/*! ./Constants */ \"./node_modules/ws/lib/Constants.js\");\nconst Receiver = __webpack_require__(/*! ./Receiver */ \"./node_modules/ws/lib/Receiver.js\");\nconst Sender = __webpack_require__(/*! ./Sender */ \"./node_modules/ws/lib/Sender.js\");\n\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000; // Allow 30 seconds to terminate the connection cleanly.\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {String} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  constructor (address, protocols, options) {\n    super();\n\n    if (!protocols) {\n      protocols = [];\n    } else if (typeof protocols === 'string') {\n      protocols = [protocols];\n    } else if (!Array.isArray(protocols)) {\n      options = protocols;\n      protocols = [];\n    }\n\n    this.readyState = WebSocket.CONNECTING;\n    this.bytesReceived = 0;\n    this.extensions = {};\n    this.protocol = '';\n\n    this._binaryType = constants.BINARY_TYPES[0];\n    this._finalize = this.finalize.bind(this);\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._finalized = false;\n    this._closeCode = 1006;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n    this._ultron = null;\n\n    if (Array.isArray(address)) {\n      initAsServerClient.call(this, address[0], address[1], options);\n    } else {\n      initAsClient.call(this, address, protocols, options);\n    }\n  }\n\n  get CONNECTING () { return WebSocket.CONNECTING; }\n  get CLOSING () { return WebSocket.CLOSING; }\n  get CLOSED () { return WebSocket.CLOSED; }\n  get OPEN () { return WebSocket.OPEN; }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount () {\n    var amount = 0;\n\n    if (this._socket) {\n      amount = this._socket.bufferSize + this._sender._bufferedBytes;\n    }\n    return amount;\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the required\n   * default \"blob\" type (instead we define a custom \"nodebuffer\" type).\n   *\n   * @type {String}\n   */\n  get binaryType () {\n    return this._binaryType;\n  }\n\n  set binaryType (type) {\n    if (constants.BINARY_TYPES.indexOf(type) < 0) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @private\n   */\n  setSocket (socket, head) {\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    this._receiver = new Receiver(this.extensions, this._maxPayload, this.binaryType);\n    this._sender = new Sender(socket, this.extensions);\n    this._ultron = new Ultron(socket);\n    this._socket = socket;\n\n    this._ultron.on('close', this._finalize);\n    this._ultron.on('error', this._finalize);\n    this._ultron.on('end', this._finalize);\n\n    if (head.length > 0) socket.unshift(head);\n\n    this._ultron.on('data', (data) => {\n      this.bytesReceived += data.length;\n      this._receiver.add(data);\n    });\n\n    this._receiver.onmessage = (data) => this.emit('message', data);\n    this._receiver.onping = (data) => {\n      this.pong(data, !this._isServer, true);\n      this.emit('ping', data);\n    };\n    this._receiver.onpong = (data) => this.emit('pong', data);\n    this._receiver.onclose = (code, reason) => {\n      this._closeFrameReceived = true;\n      this._closeMessage = reason;\n      this._closeCode = code;\n      if (!this._finalized) this.close(code, reason);\n    };\n    this._receiver.onerror = (error, code) => {\n      this._closeMessage = '';\n      this._closeCode = code;\n\n      //\n      // Ensure that the error is emitted even if `WebSocket#finalize()` has\n      // already been called.\n      //\n      this.readyState = WebSocket.CLOSING;\n      this.emit('error', error);\n      this.finalize(true);\n    };\n\n    this.readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Clean up and release internal resources.\n   *\n   * @param {(Boolean|Error)} error Indicates whether or not an error occurred\n   * @private\n   */\n  finalize (error) {\n    if (this._finalized) return;\n\n    this.readyState = WebSocket.CLOSING;\n    this._finalized = true;\n\n    if (typeof error === 'object') this.emit('error', error);\n    if (!this._socket) return this.emitClose();\n\n    clearTimeout(this._closeTimer);\n    this._closeTimer = null;\n\n    this._ultron.destroy();\n    this._ultron = null;\n\n    this._socket.on('error', constants.NOOP);\n\n    if (!error) this._socket.end();\n    else this._socket.destroy();\n\n    this._socket = null;\n    this._sender = null;\n\n    this._receiver.cleanup(() => this.emitClose());\n    this._receiver = null;\n  }\n\n  /**\n   * Emit the `close` event.\n   *\n   * @private\n   */\n  emitClose () {\n    this.readyState = WebSocket.CLOSED;\n\n    this.emit('close', this._closeCode, this._closeMessage);\n\n    if (this.extensions[PerMessageDeflate.extensionName]) {\n      this.extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this.extensions = null;\n\n    this.removeAllListeners();\n  }\n\n  /**\n   * Pause the socket stream.\n   *\n   * @public\n   */\n  pause () {\n    if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n    this._socket.pause();\n  }\n\n  /**\n   * Resume the socket stream\n   *\n   * @public\n   */\n  resume () {\n    if (this.readyState !== WebSocket.OPEN) throw new Error('not opened');\n\n    this._socket.resume();\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *            +----------+     +-----------+   +----------+\n   *     + - - -|ws.close()|---->|close frame|-->|ws.close()|- - - -\n   *            +----------+     +-----------+   +----------+       |\n   *     |      +----------+     +-----------+         |\n   *            |ws.close()|<----|close frame|<--------+            |\n   *            +----------+     +-----------+         |\n   *  CLOSING         |              +---+             |         CLOSING\n   *                  |          +---|fin|<------------+\n   *     |            |          |   +---+                          |\n   *                  |          |   +---+      +-------------+\n   *     |            +----------+-->|fin|----->|ws.finalize()| - - +\n   *                             |   +---+      +-------------+\n   *     |     +-------------+   |\n   *      - - -|ws.finalize()|<--+\n   *           +-------------+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */\n  close (code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      this._req.abort();\n      this.finalize(new Error('closed before the connection is established'));\n      return;\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n      return;\n    }\n\n    this.readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (!this._finalized) {\n        if (this._closeFrameReceived) this._socket.end();\n\n        //\n        // Ensure that the connection is cleaned up even when the closing\n        // handshake fails.\n        //\n        this._closeTimer = setTimeout(this._finalize, closeTimeout, true);\n      }\n    });\n  }\n\n  /**\n   * Send a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\n   * @public\n   */\n  ping (data, mask, failSilently) {\n    if (this.readyState !== WebSocket.OPEN) {\n      if (failSilently) return;\n      throw new Error('not opened');\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || constants.EMPTY_BUFFER, mask);\n  }\n\n  /**\n   * Send a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Boolean} failSilently Indicates whether or not to throw if `readyState` isn't `OPEN`\n   * @public\n   */\n  pong (data, mask, failSilently) {\n    if (this.readyState !== WebSocket.OPEN) {\n      if (failSilently) return;\n      throw new Error('not opened');\n    }\n\n    if (typeof data === 'number') data = data.toString();\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || constants.EMPTY_BUFFER, mask);\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */\n  send (data, options, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (this.readyState !== WebSocket.OPEN) {\n      if (cb) cb(new Error('not opened'));\n      else throw new Error('not opened');\n      return;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    const opts = Object.assign({\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true\n    }, options);\n\n    if (!this.extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate () {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      this._req.abort();\n      this.finalize(new Error('closed before the connection is established'));\n      return;\n    }\n\n    this.finalize(true);\n  }\n}\n\nWebSocket.CONNECTING = 0;\nWebSocket.OPEN = 1;\nWebSocket.CLOSING = 2;\nWebSocket.CLOSED = 3;\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get () {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n    },\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set (listener) {\n      const listeners = this.listeners(method);\n      for (var i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = EventTarget.addEventListener;\nWebSocket.prototype.removeEventListener = EventTarget.removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket server client.\n *\n * @param {http.IncomingMessage} req The request object\n * @param {net.Socket} socket The network socket between the server and client\n * @param {Buffer} head The first packet of the upgraded stream\n * @param {Object} options WebSocket attributes\n * @param {Number} options.protocolVersion The WebSocket protocol version\n * @param {Object} options.extensions The negotiated extensions\n * @param {Number} options.maxPayload The maximum allowed message size\n * @param {String} options.protocol The chosen subprotocol\n * @private\n */\nfunction initAsServerClient (socket, head, options) {\n  this.protocolVersion = options.protocolVersion;\n  this._maxPayload = options.maxPayload;\n  this.extensions = options.extensions;\n  this.protocol = options.protocol;\n\n  this._isServer = true;\n\n  this.setSocket(socket, head);\n}\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {String} address The URL to which to connect\n * @param {String[]} protocols The list of subprotocols\n * @param {Object} options Connection options\n * @param {String} options.protocol Value of the `Sec-WebSocket-Protocol` header\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the handshake request\n * @param {String} options.localAddress Local interface to bind for network connections\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version` header\n * @param {Object} options.headers An object containing request headers\n * @param {String} options.origin Value of the `Origin` or `Sec-WebSocket-Origin` header\n * @param {http.Agent} options.agent Use the specified Agent\n * @param {String} options.host Value of the `Host` header\n * @param {Number} options.family IP address family to use during hostname lookup (4 or 6).\n * @param {Function} options.checkServerIdentity A function to validate the server hostname\n * @param {Boolean} options.rejectUnauthorized Verify or not the server certificate\n * @param {String} options.passphrase The passphrase for the private key or pfx\n * @param {String} options.ciphers The ciphers to use or exclude\n * @param {String} options.ecdhCurve The curves for ECDH key agreement to use or exclude\n * @param {(String|String[]|Buffer|Buffer[])} options.cert The certificate key\n * @param {(String|String[]|Buffer|Buffer[])} options.key The private key\n * @param {(String|Buffer)} options.pfx The private key, certificate, and CA certs\n * @param {(String|String[]|Buffer|Buffer[])} options.ca Trusted certificates\n * @private\n */\nfunction initAsClient (address, protocols, options) {\n  options = Object.assign({\n    protocolVersion: protocolVersions[1],\n    protocol: protocols.join(','),\n    perMessageDeflate: true,\n    handshakeTimeout: null,\n    localAddress: null,\n    headers: null,\n    family: null,\n    origin: null,\n    agent: null,\n    host: null,\n\n    //\n    // SSL options.\n    //\n    checkServerIdentity: null,\n    rejectUnauthorized: null,\n    passphrase: null,\n    ciphers: null,\n    ecdhCurve: null,\n    cert: null,\n    key: null,\n    pfx: null,\n    ca: null\n  }, options);\n\n  if (protocolVersions.indexOf(options.protocolVersion) === -1) {\n    throw new Error(\n      `unsupported protocol version: ${options.protocolVersion} ` +\n      `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  this.protocolVersion = options.protocolVersion;\n  this._isServer = false;\n  this.url = address;\n\n  const serverUrl = url.parse(address);\n  const isUnixSocket = serverUrl.protocol === 'ws+unix:';\n\n  if (!serverUrl.host && (!isUnixSocket || !serverUrl.path)) {\n    throw new Error('invalid url');\n  }\n\n  const isSecure = serverUrl.protocol === 'wss:' || serverUrl.protocol === 'https:';\n  const key = crypto.randomBytes(16).toString('base64');\n  const httpObj = isSecure ? https : http;\n  var perMessageDeflate;\n\n  const requestOptions = {\n    port: serverUrl.port || (isSecure ? 443 : 80),\n    host: serverUrl.hostname,\n    path: '/',\n    headers: {\n      'Sec-WebSocket-Version': options.protocolVersion,\n      'Sec-WebSocket-Key': key,\n      'Connection': 'Upgrade',\n      'Upgrade': 'websocket'\n    }\n  };\n\n  if (options.headers) Object.assign(requestOptions.headers, options.headers);\n  if (options.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      options.perMessageDeflate !== true ? options.perMessageDeflate : {},\n      false\n    );\n    requestOptions.headers['Sec-WebSocket-Extensions'] = Extensions.format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (options.protocol) {\n    requestOptions.headers['Sec-WebSocket-Protocol'] = options.protocol;\n  }\n  if (options.origin) {\n    if (options.protocolVersion < 13) {\n      requestOptions.headers['Sec-WebSocket-Origin'] = options.origin;\n    } else {\n      requestOptions.headers.Origin = options.origin;\n    }\n  }\n  if (options.host) requestOptions.headers.Host = options.host;\n  if (serverUrl.auth) requestOptions.auth = serverUrl.auth;\n\n  if (options.localAddress) requestOptions.localAddress = options.localAddress;\n  if (options.family) requestOptions.family = options.family;\n\n  if (isUnixSocket) {\n    const parts = serverUrl.path.split(':');\n\n    requestOptions.socketPath = parts[0];\n    requestOptions.path = parts[1];\n  } else if (serverUrl.path) {\n    //\n    // Make sure that path starts with `/`.\n    //\n    if (serverUrl.path.charAt(0) !== '/') {\n      requestOptions.path = `/${serverUrl.path}`;\n    } else {\n      requestOptions.path = serverUrl.path;\n    }\n  }\n\n  var agent = options.agent;\n\n  //\n  // A custom agent is required for these options.\n  //\n  if (\n    options.rejectUnauthorized != null ||\n    options.checkServerIdentity ||\n    options.passphrase ||\n    options.ciphers ||\n    options.ecdhCurve ||\n    options.cert ||\n    options.key ||\n    options.pfx ||\n    options.ca\n  ) {\n    if (options.passphrase) requestOptions.passphrase = options.passphrase;\n    if (options.ciphers) requestOptions.ciphers = options.ciphers;\n    if (options.ecdhCurve) requestOptions.ecdhCurve = options.ecdhCurve;\n    if (options.cert) requestOptions.cert = options.cert;\n    if (options.key) requestOptions.key = options.key;\n    if (options.pfx) requestOptions.pfx = options.pfx;\n    if (options.ca) requestOptions.ca = options.ca;\n    if (options.checkServerIdentity) {\n      requestOptions.checkServerIdentity = options.checkServerIdentity;\n    }\n    if (options.rejectUnauthorized != null) {\n      requestOptions.rejectUnauthorized = options.rejectUnauthorized;\n    }\n\n    if (!agent) agent = new httpObj.Agent(requestOptions);\n  }\n\n  if (agent) requestOptions.agent = agent;\n\n  this._req = httpObj.get(requestOptions);\n\n  if (options.handshakeTimeout) {\n    this._req.setTimeout(options.handshakeTimeout, () => {\n      this._req.abort();\n      this.finalize(new Error('opening handshake has timed out'));\n    });\n  }\n\n  this._req.on('error', (error) => {\n    if (this._req.aborted) return;\n\n    this._req = null;\n    this.finalize(error);\n  });\n\n  this._req.on('response', (res) => {\n    if (!this.emit('unexpected-response', this._req, res)) {\n      this._req.abort();\n      this.finalize(new Error(`unexpected server response (${res.statusCode})`));\n    }\n  });\n\n  this._req.on('upgrade', (res, socket, head) => {\n    this.emit('headers', res.headers, res);\n\n    //\n    // The user may have closed the connection from a listener of the `headers`\n    // event.\n    //\n    if (this.readyState !== WebSocket.CONNECTING) return;\n\n    this._req = null;\n\n    const digest = crypto.createHash('sha1')\n      .update(key + constants.GUID, 'binary')\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      socket.destroy();\n      return this.finalize(new Error('invalid server key'));\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (options.protocol || '').split(/, */);\n    var protError;\n\n    if (!options.protocol && serverProt) {\n      protError = 'server sent a subprotocol even though none requested';\n    } else if (options.protocol && !serverProt) {\n      protError = 'server sent no subprotocol even though requested';\n    } else if (serverProt && protList.indexOf(serverProt) === -1) {\n      protError = 'server responded with an invalid protocol';\n    }\n\n    if (protError) {\n      socket.destroy();\n      return this.finalize(new Error(protError));\n    }\n\n    if (serverProt) this.protocol = serverProt;\n\n    if (perMessageDeflate) {\n      try {\n        const serverExtensions = Extensions.parse(\n          res.headers['sec-websocket-extensions']\n        );\n\n        if (serverExtensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(\n            serverExtensions[PerMessageDeflate.extensionName]\n          );\n          this.extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        socket.destroy();\n        this.finalize(new Error('invalid Sec-WebSocket-Extensions header'));\n        return;\n      }\n    }\n\n    this.setSocket(socket, head);\n  });\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ws/lib/WebSocket.js?");

/***/ }),

/***/ "./node_modules/ws/lib/WebSocketServer.js":
/*!************************************************!*\
  !*** ./node_modules/ws/lib/WebSocketServer.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*!\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n\n\nconst safeBuffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\");\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst Ultron = __webpack_require__(/*! ultron */ \"./node_modules/ultron/index.js\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst url = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./PerMessageDeflate */ \"./node_modules/ws/lib/PerMessageDeflate.js\");\nconst Extensions = __webpack_require__(/*! ./Extensions */ \"./node_modules/ws/lib/Extensions.js\");\nconst constants = __webpack_require__(/*! ./Constants */ \"./node_modules/ws/lib/Constants.js\");\nconst WebSocket = __webpack_require__(/*! ./WebSocket */ \"./node_modules/ws/lib/WebSocket.js\");\n\nconst Buffer = safeBuffer.Buffer;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient An hook to reject connections\n   * @param {Function} options.handleProtocols An hook to handle protocols\n   * @param {String} options.path Accept only connections matching this path\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {Boolean} options.clientTracking Specifies whether or not to track clients\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable permessage-deflate\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor (options, callback) {\n    super();\n\n    options = Object.assign({\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null\n    }, options);\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError('missing or invalid options');\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._ultron = new Ultron(this._server);\n      this._ultron.on('listening', () => this.emit('listening'));\n      this._ultron.on('error', (err) => this.emit('error', err));\n      this._ultron.on('upgrade', (req, socket, head) => {\n        this.handleUpgrade(req, socket, head, (client) => {\n          this.emit('connection', client, req);\n        });\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  close (cb) {\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._ultron.destroy();\n      this._ultron = this._server = null;\n\n      //\n      // Close the http server if it was internally created.\n      //\n      if (this.options.port != null) return server.close(cb);\n    }\n\n    if (cb) cb();\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle (req) {\n    if (this.options.path && url.parse(req.url).pathname !== this.options.path) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade (req, socket, head, cb) {\n    socket.on('error', socketError);\n\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (\n      req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !req.headers['sec-websocket-key'] || (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortConnection(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = Extensions.parse(\n          req.headers['sec-websocket-extensions']\n        );\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortConnection(socket, 400);\n      }\n    }\n\n    var protocol = (req.headers['sec-websocket-protocol'] || '').split(/, */);\n\n    //\n    // Optionally call external protocol selection handler.\n    //\n    if (this.options.handleProtocols) {\n      protocol = this.options.handleProtocols(protocol, req);\n      if (protocol === false) return abortConnection(socket, 401);\n    } else {\n      protocol = protocol[0];\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message) => {\n          if (!verified) return abortConnection(socket, code || 401, message);\n\n          this.completeUpgrade(\n            protocol,\n            extensions,\n            version,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortConnection(socket, 401);\n    }\n\n    this.completeUpgrade(protocol, extensions, version, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} protocol The chosen subprotocol\n   * @param {Object} extensions The accepted extensions\n   * @param {Number} version The WebSocket protocol version\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */\n  completeUpgrade (protocol, extensions, version, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    const key = crypto.createHash('sha1')\n      .update(req.headers['sec-websocket-key'] + constants.GUID, 'binary')\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${key}`\n    ];\n\n    if (protocol) headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = Extensions.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n\n    const client = new WebSocket([socket, head], null, {\n      maxPayload: this.options.maxPayload,\n      protocolVersion: version,\n      extensions,\n      protocol\n    });\n\n    if (this.clients) {\n      this.clients.add(client);\n      client.on('close', () => this.clients.delete(client));\n    }\n\n    socket.removeListener('error', socketError);\n    cb(client);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketError () {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @private\n */\nfunction abortConnection (socket, code, message) {\n  if (socket.writable) {\n    message = message || http.STATUS_CODES[code];\n    socket.write(\n      `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      'Connection: close\\r\\n' +\n      'Content-type: text/html\\r\\n' +\n      `Content-Length: ${Buffer.byteLength(message)}\\r\\n` +\n      '\\r\\n' +\n      message\n    );\n  }\n\n  socket.removeListener('error', socketError);\n  socket.destroy();\n}\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/ws/lib/WebSocketServer.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/Utility.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/Utility.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var assign, isArray, isEmpty, isFunction, isObject, isPlainObject,\n    slice = [].slice,\n    hasProp = {}.hasOwnProperty;\n\n  assign = function() {\n    var i, key, len, source, sources, target;\n    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    if (isFunction(Object.assign)) {\n      Object.assign.apply(null, arguments);\n    } else {\n      for (i = 0, len = sources.length; i < len; i++) {\n        source = sources[i];\n        if (source != null) {\n          for (key in source) {\n            if (!hasProp.call(source, key)) continue;\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n\n  isFunction = function(val) {\n    return !!val && Object.prototype.toString.call(val) === '[object Function]';\n  };\n\n  isObject = function(val) {\n    var ref;\n    return !!val && ((ref = typeof val) === 'function' || ref === 'object');\n  };\n\n  isArray = function(val) {\n    if (isFunction(Array.isArray)) {\n      return Array.isArray(val);\n    } else {\n      return Object.prototype.toString.call(val) === '[object Array]';\n    }\n  };\n\n  isEmpty = function(val) {\n    var key;\n    if (isArray(val)) {\n      return !val.length;\n    } else {\n      for (key in val) {\n        if (!hasProp.call(val, key)) continue;\n        return false;\n      }\n      return true;\n    }\n  };\n\n  isPlainObject = function(val) {\n    var ctor, proto;\n    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));\n  };\n\n  module.exports.assign = assign;\n\n  module.exports.isFunction = isFunction;\n\n  module.exports.isObject = isObject;\n\n  module.exports.isArray = isArray;\n\n  module.exports.isEmpty = isEmpty;\n\n  module.exports.isPlainObject = isPlainObject;\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/Utility.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLAttribute.js":
/*!*****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLAttribute.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLAttribute;\n\n  module.exports = XMLAttribute = (function() {\n    function XMLAttribute(parent, name, value) {\n      this.options = parent.options;\n      this.stringify = parent.stringify;\n      if (name == null) {\n        throw new Error(\"Missing attribute name of element \" + parent.name);\n      }\n      if (value == null) {\n        throw new Error(\"Missing attribute value for attribute \" + name + \" of element \" + parent.name);\n      }\n      this.name = this.stringify.attName(name);\n      this.value = this.stringify.attValue(value);\n    }\n\n    XMLAttribute.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLAttribute.prototype.toString = function(options) {\n      return this.options.writer.set(options).attribute(this);\n    };\n\n    return XMLAttribute;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLAttribute.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLCData.js":
/*!*************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLCData.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLCData, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLCData = (function(superClass) {\n    extend(XMLCData, superClass);\n\n    function XMLCData(parent, text) {\n      XMLCData.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing CDATA text\");\n      }\n      this.text = this.stringify.cdata(text);\n    }\n\n    XMLCData.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLCData.prototype.toString = function(options) {\n      return this.options.writer.set(options).cdata(this);\n    };\n\n    return XMLCData;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLCData.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLComment.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLComment.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLComment, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLComment = (function(superClass) {\n    extend(XMLComment, superClass);\n\n    function XMLComment(parent, text) {\n      XMLComment.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing comment text\");\n      }\n      this.text = this.stringify.comment(text);\n    }\n\n    XMLComment.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLComment.prototype.toString = function(options) {\n      return this.options.writer.set(options).comment(this);\n    };\n\n    return XMLComment;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLComment.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDAttList.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDAttList.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDTDAttList, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLDTDAttList = (function(superClass) {\n    extend(XMLDTDAttList, superClass);\n\n    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      XMLDTDAttList.__super__.constructor.call(this, parent);\n      if (elementName == null) {\n        throw new Error(\"Missing DTD element name\");\n      }\n      if (attributeName == null) {\n        throw new Error(\"Missing DTD attribute name\");\n      }\n      if (!attributeType) {\n        throw new Error(\"Missing DTD attribute type\");\n      }\n      if (!defaultValueType) {\n        throw new Error(\"Missing DTD attribute default\");\n      }\n      if (defaultValueType.indexOf('#') !== 0) {\n        defaultValueType = '#' + defaultValueType;\n      }\n      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT\");\n      }\n      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Default value only applies to #FIXED or #DEFAULT\");\n      }\n      this.elementName = this.stringify.eleName(elementName);\n      this.attributeName = this.stringify.attName(attributeName);\n      this.attributeType = this.stringify.dtdAttType(attributeType);\n      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);\n      this.defaultValueType = defaultValueType;\n    }\n\n    XMLDTDAttList.prototype.toString = function(options) {\n      return this.options.writer.set(options).dtdAttList(this);\n    };\n\n    return XMLDTDAttList;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLDTDAttList.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDElement.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDElement.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDTDElement, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLDTDElement = (function(superClass) {\n    extend(XMLDTDElement, superClass);\n\n    function XMLDTDElement(parent, name, value) {\n      XMLDTDElement.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing DTD element name\");\n      }\n      if (!value) {\n        value = '(#PCDATA)';\n      }\n      if (Array.isArray(value)) {\n        value = '(' + value.join(',') + ')';\n      }\n      this.name = this.stringify.eleName(name);\n      this.value = this.stringify.dtdElementValue(value);\n    }\n\n    XMLDTDElement.prototype.toString = function(options) {\n      return this.options.writer.set(options).dtdElement(this);\n    };\n\n    return XMLDTDElement;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLDTDElement.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDEntity.js":
/*!*****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDEntity.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDTDEntity, XMLNode, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isObject = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\").isObject;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLDTDEntity = (function(superClass) {\n    extend(XMLDTDEntity, superClass);\n\n    function XMLDTDEntity(parent, pe, name, value) {\n      XMLDTDEntity.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing entity name\");\n      }\n      if (value == null) {\n        throw new Error(\"Missing entity value\");\n      }\n      this.pe = !!pe;\n      this.name = this.stringify.eleName(name);\n      if (!isObject(value)) {\n        this.value = this.stringify.dtdEntityValue(value);\n      } else {\n        if (!value.pubID && !value.sysID) {\n          throw new Error(\"Public and/or system identifiers are required for an external entity\");\n        }\n        if (value.pubID && !value.sysID) {\n          throw new Error(\"System identifier is required for a public external entity\");\n        }\n        if (value.pubID != null) {\n          this.pubID = this.stringify.dtdPubID(value.pubID);\n        }\n        if (value.sysID != null) {\n          this.sysID = this.stringify.dtdSysID(value.sysID);\n        }\n        if (value.nData != null) {\n          this.nData = this.stringify.dtdNData(value.nData);\n        }\n        if (this.pe && this.nData) {\n          throw new Error(\"Notation declaration is not allowed in a parameter entity\");\n        }\n      }\n    }\n\n    XMLDTDEntity.prototype.toString = function(options) {\n      return this.options.writer.set(options).dtdEntity(this);\n    };\n\n    return XMLDTDEntity;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLDTDEntity.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDTDNotation.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDTDNotation.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDTDNotation, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLDTDNotation = (function(superClass) {\n    extend(XMLDTDNotation, superClass);\n\n    function XMLDTDNotation(parent, name, value) {\n      XMLDTDNotation.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing notation name\");\n      }\n      if (!value.pubID && !value.sysID) {\n        throw new Error(\"Public or system identifiers are required for an external entity\");\n      }\n      this.name = this.stringify.eleName(name);\n      if (value.pubID != null) {\n        this.pubID = this.stringify.dtdPubID(value.pubID);\n      }\n      if (value.sysID != null) {\n        this.sysID = this.stringify.dtdSysID(value.sysID);\n      }\n    }\n\n    XMLDTDNotation.prototype.toString = function(options) {\n      return this.options.writer.set(options).dtdNotation(this);\n    };\n\n    return XMLDTDNotation;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLDTDNotation.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDeclaration.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDeclaration.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDeclaration, XMLNode, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isObject = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\").isObject;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLDeclaration = (function(superClass) {\n    extend(XMLDeclaration, superClass);\n\n    function XMLDeclaration(parent, version, encoding, standalone) {\n      var ref;\n      XMLDeclaration.__super__.constructor.call(this, parent);\n      if (isObject(version)) {\n        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;\n      }\n      if (!version) {\n        version = '1.0';\n      }\n      this.version = this.stringify.xmlVersion(version);\n      if (encoding != null) {\n        this.encoding = this.stringify.xmlEncoding(encoding);\n      }\n      if (standalone != null) {\n        this.standalone = this.stringify.xmlStandalone(standalone);\n      }\n    }\n\n    XMLDeclaration.prototype.toString = function(options) {\n      return this.options.writer.set(options).declaration(this);\n    };\n\n    return XMLDeclaration;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLDeclaration.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocType.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocType.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isObject = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\").isObject;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ \"./node_modules/xmlbuilder/lib/XMLDTDAttList.js\");\n\n  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ \"./node_modules/xmlbuilder/lib/XMLDTDEntity.js\");\n\n  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ \"./node_modules/xmlbuilder/lib/XMLDTDElement.js\");\n\n  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ \"./node_modules/xmlbuilder/lib/XMLDTDNotation.js\");\n\n  module.exports = XMLDocType = (function(superClass) {\n    extend(XMLDocType, superClass);\n\n    function XMLDocType(parent, pubID, sysID) {\n      var ref, ref1;\n      XMLDocType.__super__.constructor.call(this, parent);\n      this.documentObject = parent;\n      if (isObject(pubID)) {\n        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;\n      }\n      if (sysID == null) {\n        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];\n      }\n      if (pubID != null) {\n        this.pubID = this.stringify.dtdPubID(pubID);\n      }\n      if (sysID != null) {\n        this.sysID = this.stringify.dtdSysID(sysID);\n      }\n    }\n\n    XMLDocType.prototype.element = function(name, value) {\n      var child;\n      child = new XMLDTDElement(this, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var child;\n      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.entity = function(name, value) {\n      var child;\n      child = new XMLDTDEntity(this, false, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.pEntity = function(name, value) {\n      var child;\n      child = new XMLDTDEntity(this, true, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.notation = function(name, value) {\n      var child;\n      child = new XMLDTDNotation(this, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.toString = function(options) {\n      return this.options.writer.set(options).docType(this);\n    };\n\n    XMLDocType.prototype.ele = function(name, value) {\n      return this.element(name, value);\n    };\n\n    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);\n    };\n\n    XMLDocType.prototype.ent = function(name, value) {\n      return this.entity(name, value);\n    };\n\n    XMLDocType.prototype.pent = function(name, value) {\n      return this.pEntity(name, value);\n    };\n\n    XMLDocType.prototype.not = function(name, value) {\n      return this.notation(name, value);\n    };\n\n    XMLDocType.prototype.up = function() {\n      return this.root() || this.documentObject;\n    };\n\n    return XMLDocType;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLDocType.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocument.js":
/*!****************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocument.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isPlainObject = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\").isPlainObject;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ \"./node_modules/xmlbuilder/lib/XMLStringifier.js\");\n\n  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ \"./node_modules/xmlbuilder/lib/XMLStringWriter.js\");\n\n  module.exports = XMLDocument = (function(superClass) {\n    extend(XMLDocument, superClass);\n\n    function XMLDocument(options) {\n      XMLDocument.__super__.constructor.call(this, null);\n      options || (options = {});\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      }\n      this.options = options;\n      this.stringify = new XMLStringifier(options);\n      this.isDocument = true;\n    }\n\n    XMLDocument.prototype.end = function(writer) {\n      var writerOptions;\n      if (!writer) {\n        writer = this.options.writer;\n      } else if (isPlainObject(writer)) {\n        writerOptions = writer;\n        writer = this.options.writer.set(writerOptions);\n      }\n      return writer.document(this);\n    };\n\n    XMLDocument.prototype.toString = function(options) {\n      return this.options.writer.set(options).document(this);\n    };\n\n    return XMLDocument;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLDocument.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLDocumentCB.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLDocumentCB.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, isFunction, isObject, isPlainObject, ref,\n    hasProp = {}.hasOwnProperty;\n\n  ref = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\"), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;\n\n  XMLElement = __webpack_require__(/*! ./XMLElement */ \"./node_modules/xmlbuilder/lib/XMLElement.js\");\n\n  XMLCData = __webpack_require__(/*! ./XMLCData */ \"./node_modules/xmlbuilder/lib/XMLCData.js\");\n\n  XMLComment = __webpack_require__(/*! ./XMLComment */ \"./node_modules/xmlbuilder/lib/XMLComment.js\");\n\n  XMLRaw = __webpack_require__(/*! ./XMLRaw */ \"./node_modules/xmlbuilder/lib/XMLRaw.js\");\n\n  XMLText = __webpack_require__(/*! ./XMLText */ \"./node_modules/xmlbuilder/lib/XMLText.js\");\n\n  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ \"./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js\");\n\n  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ \"./node_modules/xmlbuilder/lib/XMLDeclaration.js\");\n\n  XMLDocType = __webpack_require__(/*! ./XMLDocType */ \"./node_modules/xmlbuilder/lib/XMLDocType.js\");\n\n  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ \"./node_modules/xmlbuilder/lib/XMLDTDAttList.js\");\n\n  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ \"./node_modules/xmlbuilder/lib/XMLDTDEntity.js\");\n\n  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ \"./node_modules/xmlbuilder/lib/XMLDTDElement.js\");\n\n  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ \"./node_modules/xmlbuilder/lib/XMLDTDNotation.js\");\n\n  XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ \"./node_modules/xmlbuilder/lib/XMLAttribute.js\");\n\n  XMLStringifier = __webpack_require__(/*! ./XMLStringifier */ \"./node_modules/xmlbuilder/lib/XMLStringifier.js\");\n\n  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ \"./node_modules/xmlbuilder/lib/XMLStringWriter.js\");\n\n  module.exports = XMLDocumentCB = (function() {\n    function XMLDocumentCB(options, onData, onEnd) {\n      var writerOptions;\n      options || (options = {});\n      if (!options.writer) {\n        options.writer = new XMLStringWriter(options);\n      } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter(writerOptions);\n      }\n      this.options = options;\n      this.writer = options.writer;\n      this.stringify = new XMLStringifier(options);\n      this.onDataCallback = onData || function() {};\n      this.onEndCallback = onEnd || function() {};\n      this.currentNode = null;\n      this.currentLevel = -1;\n      this.openTags = {};\n      this.documentStarted = false;\n      this.documentCompleted = false;\n      this.root = null;\n    }\n\n    XMLDocumentCB.prototype.node = function(name, attributes, text) {\n      var ref1;\n      if (name == null) {\n        throw new Error(\"Missing node name\");\n      }\n      if (this.root && this.currentLevel === -1) {\n        throw new Error(\"Document can only have one root node\");\n      }\n      this.openCurrent();\n      name = name.valueOf();\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = attributes.valueOf();\n      if (!isObject(attributes)) {\n        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];\n      }\n      this.currentNode = new XMLElement(this, name, attributes);\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      if (text != null) {\n        this.text(text);\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.element = function(name, attributes, text) {\n      if (this.currentNode && this.currentNode instanceof XMLDocType) {\n        return this.dtdElement.apply(this, arguments);\n      } else {\n        return this.node(name, attributes, text);\n      }\n    };\n\n    XMLDocumentCB.prototype.attribute = function(name, value) {\n      var attName, attValue;\n      if (!this.currentNode || this.currentNode.children) {\n        throw new Error(\"att() can only be used immediately after an ele() call in callback mode\");\n      }\n      if (name != null) {\n        name = name.valueOf();\n      }\n      if (isObject(name)) {\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (!this.options.skipNullAttributes || (value != null)) {\n          this.currentNode.attributes[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.text = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLText(this, value);\n      this.onData(this.writer.text(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.cdata = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLCData(this, value);\n      this.onData(this.writer.cdata(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.comment = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLComment(this, value);\n      this.onData(this.writer.comment(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.raw = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLRaw(this, value);\n      this.onData(this.writer.raw(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.instruction = function(target, value) {\n      var i, insTarget, insValue, len, node;\n      this.openCurrent();\n      if (target != null) {\n        target = target.valueOf();\n      }\n      if (value != null) {\n        value = value.valueOf();\n      }\n      if (Array.isArray(target)) {\n        for (i = 0, len = target.length; i < len; i++) {\n          insTarget = target[i];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) {\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        node = new XMLProcessingInstruction(this, target, value);\n        this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {\n      var node;\n      this.openCurrent();\n      if (this.documentStarted) {\n        throw new Error(\"declaration() must be the first node\");\n      }\n      node = new XMLDeclaration(this, version, encoding, standalone);\n      this.onData(this.writer.declaration(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {\n      this.openCurrent();\n      if (root == null) {\n        throw new Error(\"Missing root node name\");\n      }\n      if (this.root) {\n        throw new Error(\"dtd() must come before the root node\");\n      }\n      this.currentNode = new XMLDocType(this, pubID, sysID);\n      this.currentNode.rootNodeName = root;\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      return this;\n    };\n\n    XMLDocumentCB.prototype.dtdElement = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDElement(this, name, value);\n      this.onData(this.writer.dtdElement(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.onData(this.writer.dtdAttList(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.entity = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, false, name, value);\n      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.pEntity = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, true, name, value);\n      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.notation = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDNotation(this, name, value);\n      this.onData(this.writer.dtdNotation(node, this.currentLevel + 1));\n      return this;\n    };\n\n    XMLDocumentCB.prototype.up = function() {\n      if (this.currentLevel < 0) {\n        throw new Error(\"The document node has no parent\");\n      }\n      if (this.currentNode) {\n        if (this.currentNode.children) {\n          this.closeNode(this.currentNode);\n        } else {\n          this.openNode(this.currentNode);\n        }\n        this.currentNode = null;\n      } else {\n        this.closeNode(this.openTags[this.currentLevel]);\n      }\n      delete this.openTags[this.currentLevel];\n      this.currentLevel--;\n      return this;\n    };\n\n    XMLDocumentCB.prototype.end = function() {\n      while (this.currentLevel >= 0) {\n        this.up();\n      }\n      return this.onEnd();\n    };\n\n    XMLDocumentCB.prototype.openCurrent = function() {\n      if (this.currentNode) {\n        this.currentNode.children = true;\n        return this.openNode(this.currentNode);\n      }\n    };\n\n    XMLDocumentCB.prototype.openNode = function(node) {\n      if (!node.isOpen) {\n        if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {\n          this.root = node;\n        }\n        this.onData(this.writer.openNode(node, this.currentLevel));\n        return node.isOpen = true;\n      }\n    };\n\n    XMLDocumentCB.prototype.closeNode = function(node) {\n      if (!node.isClosed) {\n        this.onData(this.writer.closeNode(node, this.currentLevel));\n        return node.isClosed = true;\n      }\n    };\n\n    XMLDocumentCB.prototype.onData = function(chunk) {\n      this.documentStarted = true;\n      return this.onDataCallback(chunk);\n    };\n\n    XMLDocumentCB.prototype.onEnd = function() {\n      this.documentCompleted = true;\n      return this.onEndCallback();\n    };\n\n    XMLDocumentCB.prototype.ele = function() {\n      return this.element.apply(this, arguments);\n    };\n\n    XMLDocumentCB.prototype.nod = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLDocumentCB.prototype.txt = function(value) {\n      return this.text(value);\n    };\n\n    XMLDocumentCB.prototype.dat = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLDocumentCB.prototype.com = function(value) {\n      return this.comment(value);\n    };\n\n    XMLDocumentCB.prototype.ins = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    };\n\n    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {\n      return this.doctype(root, pubID, sysID);\n    };\n\n    XMLDocumentCB.prototype.e = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLDocumentCB.prototype.n = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLDocumentCB.prototype.t = function(value) {\n      return this.text(value);\n    };\n\n    XMLDocumentCB.prototype.d = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLDocumentCB.prototype.c = function(value) {\n      return this.comment(value);\n    };\n\n    XMLDocumentCB.prototype.r = function(value) {\n      return this.raw(value);\n    };\n\n    XMLDocumentCB.prototype.i = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLDocumentCB.prototype.att = function() {\n      if (this.currentNode && this.currentNode instanceof XMLDocType) {\n        return this.attList.apply(this, arguments);\n      } else {\n        return this.attribute.apply(this, arguments);\n      }\n    };\n\n    XMLDocumentCB.prototype.a = function() {\n      if (this.currentNode && this.currentNode instanceof XMLDocType) {\n        return this.attList.apply(this, arguments);\n      } else {\n        return this.attribute.apply(this, arguments);\n      }\n    };\n\n    XMLDocumentCB.prototype.ent = function(name, value) {\n      return this.entity(name, value);\n    };\n\n    XMLDocumentCB.prototype.pent = function(name, value) {\n      return this.pEntity(name, value);\n    };\n\n    XMLDocumentCB.prototype.not = function(name, value) {\n      return this.notation(name, value);\n    };\n\n    return XMLDocumentCB;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLDocumentCB.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLElement.js":
/*!***************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLElement.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLAttribute, XMLElement, XMLNode, isFunction, isObject, ref,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  ref = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\"), isObject = ref.isObject, isFunction = ref.isFunction;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  XMLAttribute = __webpack_require__(/*! ./XMLAttribute */ \"./node_modules/xmlbuilder/lib/XMLAttribute.js\");\n\n  module.exports = XMLElement = (function(superClass) {\n    extend(XMLElement, superClass);\n\n    function XMLElement(parent, name, attributes) {\n      XMLElement.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing element name\");\n      }\n      this.name = this.stringify.eleName(name);\n      this.attributes = {};\n      if (attributes != null) {\n        this.attribute(attributes);\n      }\n      if (parent.isDocument) {\n        this.isRoot = true;\n        this.documentObject = parent;\n        parent.rootObject = this;\n      }\n    }\n\n    XMLElement.prototype.clone = function() {\n      var att, attName, clonedSelf, ref1;\n      clonedSelf = Object.create(this);\n      if (clonedSelf.isRoot) {\n        clonedSelf.documentObject = null;\n      }\n      clonedSelf.attributes = {};\n      ref1 = this.attributes;\n      for (attName in ref1) {\n        if (!hasProp.call(ref1, attName)) continue;\n        att = ref1[attName];\n        clonedSelf.attributes[attName] = att.clone();\n      }\n      clonedSelf.children = [];\n      this.children.forEach(function(child) {\n        var clonedChild;\n        clonedChild = child.clone();\n        clonedChild.parent = clonedSelf;\n        return clonedSelf.children.push(clonedChild);\n      });\n      return clonedSelf;\n    };\n\n    XMLElement.prototype.attribute = function(name, value) {\n      var attName, attValue;\n      if (name != null) {\n        name = name.valueOf();\n      }\n      if (isObject(name)) {\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (!this.options.skipNullAttributes || (value != null)) {\n          this.attributes[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    };\n\n    XMLElement.prototype.removeAttribute = function(name) {\n      var attName, i, len;\n      if (name == null) {\n        throw new Error(\"Missing attribute name\");\n      }\n      name = name.valueOf();\n      if (Array.isArray(name)) {\n        for (i = 0, len = name.length; i < len; i++) {\n          attName = name[i];\n          delete this.attributes[attName];\n        }\n      } else {\n        delete this.attributes[name];\n      }\n      return this;\n    };\n\n    XMLElement.prototype.toString = function(options) {\n      return this.options.writer.set(options).element(this);\n    };\n\n    XMLElement.prototype.att = function(name, value) {\n      return this.attribute(name, value);\n    };\n\n    XMLElement.prototype.a = function(name, value) {\n      return this.attribute(name, value);\n    };\n\n    return XMLElement;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLElement.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLNode.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLNode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLProcessingInstruction, XMLRaw, XMLText, isEmpty, isFunction, isObject, ref,\n    hasProp = {}.hasOwnProperty;\n\n  ref = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\"), isObject = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty;\n\n  XMLElement = null;\n\n  XMLCData = null;\n\n  XMLComment = null;\n\n  XMLDeclaration = null;\n\n  XMLDocType = null;\n\n  XMLRaw = null;\n\n  XMLText = null;\n\n  XMLProcessingInstruction = null;\n\n  module.exports = XMLNode = (function() {\n    function XMLNode(parent) {\n      this.parent = parent;\n      if (this.parent) {\n        this.options = this.parent.options;\n        this.stringify = this.parent.stringify;\n      }\n      this.children = [];\n      if (!XMLElement) {\n        XMLElement = __webpack_require__(/*! ./XMLElement */ \"./node_modules/xmlbuilder/lib/XMLElement.js\");\n        XMLCData = __webpack_require__(/*! ./XMLCData */ \"./node_modules/xmlbuilder/lib/XMLCData.js\");\n        XMLComment = __webpack_require__(/*! ./XMLComment */ \"./node_modules/xmlbuilder/lib/XMLComment.js\");\n        XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ \"./node_modules/xmlbuilder/lib/XMLDeclaration.js\");\n        XMLDocType = __webpack_require__(/*! ./XMLDocType */ \"./node_modules/xmlbuilder/lib/XMLDocType.js\");\n        XMLRaw = __webpack_require__(/*! ./XMLRaw */ \"./node_modules/xmlbuilder/lib/XMLRaw.js\");\n        XMLText = __webpack_require__(/*! ./XMLText */ \"./node_modules/xmlbuilder/lib/XMLText.js\");\n        XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ \"./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js\");\n      }\n    }\n\n    XMLNode.prototype.element = function(name, attributes, text) {\n      var childNode, item, j, k, key, lastChild, len, len1, ref1, val;\n      lastChild = null;\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = attributes.valueOf();\n      if (!isObject(attributes)) {\n        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];\n      }\n      if (name != null) {\n        name = name.valueOf();\n      }\n      if (Array.isArray(name)) {\n        for (j = 0, len = name.length; j < len; j++) {\n          item = name[j];\n          lastChild = this.element(item);\n        }\n      } else if (isFunction(name)) {\n        lastChild = this.element(name.apply());\n      } else if (isObject(name)) {\n        for (key in name) {\n          if (!hasProp.call(name, key)) continue;\n          val = name[key];\n          if (isFunction(val)) {\n            val = val.apply();\n          }\n          if ((isObject(val)) && (isEmpty(val))) {\n            val = null;\n          }\n          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);\n          } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n            for (k = 0, len1 = val.length; k < len1; k++) {\n              item = val[k];\n              childNode = {};\n              childNode[key] = item;\n              lastChild = this.element(childNode);\n            }\n          } else if (isObject(val)) {\n            lastChild = this.element(key);\n            lastChild.element(val);\n          } else {\n            lastChild = this.element(key, val);\n          }\n        }\n      } else {\n        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n          lastChild = this.text(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n          lastChild = this.cdata(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n          lastChild = this.comment(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n          lastChild = this.raw(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n        } else {\n          lastChild = this.node(name, attributes, text);\n        }\n      }\n      if (lastChild == null) {\n        throw new Error(\"Could not create any elements with: \" + name);\n      }\n      return lastChild;\n    };\n\n    XMLNode.prototype.insertBefore = function(name, attributes, text) {\n      var child, i, removed;\n      if (this.isRoot) {\n        throw new Error(\"Cannot insert elements at root level\");\n      }\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i);\n      child = this.parent.element(name, attributes, text);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return child;\n    };\n\n    XMLNode.prototype.insertAfter = function(name, attributes, text) {\n      var child, i, removed;\n      if (this.isRoot) {\n        throw new Error(\"Cannot insert elements at root level\");\n      }\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.element(name, attributes, text);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return child;\n    };\n\n    XMLNode.prototype.remove = function() {\n      var i, ref1;\n      if (this.isRoot) {\n        throw new Error(\"Cannot remove the root element\");\n      }\n      i = this.parent.children.indexOf(this);\n      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;\n      return this.parent;\n    };\n\n    XMLNode.prototype.node = function(name, attributes, text) {\n      var child, ref1;\n      if (name != null) {\n        name = name.valueOf();\n      }\n      attributes || (attributes = {});\n      attributes = attributes.valueOf();\n      if (!isObject(attributes)) {\n        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];\n      }\n      child = new XMLElement(this, name, attributes);\n      if (text != null) {\n        child.text(text);\n      }\n      this.children.push(child);\n      return child;\n    };\n\n    XMLNode.prototype.text = function(value) {\n      var child;\n      child = new XMLText(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.cdata = function(value) {\n      var child;\n      child = new XMLCData(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.comment = function(value) {\n      var child;\n      child = new XMLComment(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.commentBefore = function(value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i);\n      child = this.parent.comment(value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.commentAfter = function(value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.comment(value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.raw = function(value) {\n      var child;\n      child = new XMLRaw(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.instruction = function(target, value) {\n      var insTarget, insValue, instruction, j, len;\n      if (target != null) {\n        target = target.valueOf();\n      }\n      if (value != null) {\n        value = value.valueOf();\n      }\n      if (Array.isArray(target)) {\n        for (j = 0, len = target.length; j < len; j++) {\n          insTarget = target[j];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) {\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        instruction = new XMLProcessingInstruction(this, target, value);\n        this.children.push(instruction);\n      }\n      return this;\n    };\n\n    XMLNode.prototype.instructionBefore = function(target, value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i);\n      child = this.parent.instruction(target, value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.instructionAfter = function(target, value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.instruction(target, value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.declaration = function(version, encoding, standalone) {\n      var doc, xmldec;\n      doc = this.document();\n      xmldec = new XMLDeclaration(doc, version, encoding, standalone);\n      if (doc.children[0] instanceof XMLDeclaration) {\n        doc.children[0] = xmldec;\n      } else {\n        doc.children.unshift(xmldec);\n      }\n      return doc.root() || doc;\n    };\n\n    XMLNode.prototype.doctype = function(pubID, sysID) {\n      var child, doc, doctype, i, j, k, len, len1, ref1, ref2;\n      doc = this.document();\n      doctype = new XMLDocType(doc, pubID, sysID);\n      ref1 = doc.children;\n      for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n        child = ref1[i];\n        if (child instanceof XMLDocType) {\n          doc.children[i] = doctype;\n          return doctype;\n        }\n      }\n      ref2 = doc.children;\n      for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {\n        child = ref2[i];\n        if (child.isRoot) {\n          doc.children.splice(i, 0, doctype);\n          return doctype;\n        }\n      }\n      doc.children.push(doctype);\n      return doctype;\n    };\n\n    XMLNode.prototype.up = function() {\n      if (this.isRoot) {\n        throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n      }\n      return this.parent;\n    };\n\n    XMLNode.prototype.root = function() {\n      var node;\n      node = this;\n      while (node) {\n        if (node.isDocument) {\n          return node.rootObject;\n        } else if (node.isRoot) {\n          return node;\n        } else {\n          node = node.parent;\n        }\n      }\n    };\n\n    XMLNode.prototype.document = function() {\n      var node;\n      node = this;\n      while (node) {\n        if (node.isDocument) {\n          return node;\n        } else {\n          node = node.parent;\n        }\n      }\n    };\n\n    XMLNode.prototype.end = function(options) {\n      return this.document().end(options);\n    };\n\n    XMLNode.prototype.prev = function() {\n      var i;\n      i = this.parent.children.indexOf(this);\n      if (i < 1) {\n        throw new Error(\"Already at the first node\");\n      }\n      return this.parent.children[i - 1];\n    };\n\n    XMLNode.prototype.next = function() {\n      var i;\n      i = this.parent.children.indexOf(this);\n      if (i === -1 || i === this.parent.children.length - 1) {\n        throw new Error(\"Already at the last node\");\n      }\n      return this.parent.children[i + 1];\n    };\n\n    XMLNode.prototype.importDocument = function(doc) {\n      var clonedRoot;\n      clonedRoot = doc.root().clone();\n      clonedRoot.parent = this;\n      clonedRoot.isRoot = false;\n      this.children.push(clonedRoot);\n      return this;\n    };\n\n    XMLNode.prototype.ele = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLNode.prototype.nod = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLNode.prototype.txt = function(value) {\n      return this.text(value);\n    };\n\n    XMLNode.prototype.dat = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLNode.prototype.com = function(value) {\n      return this.comment(value);\n    };\n\n    XMLNode.prototype.ins = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLNode.prototype.doc = function() {\n      return this.document();\n    };\n\n    XMLNode.prototype.dec = function(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    };\n\n    XMLNode.prototype.dtd = function(pubID, sysID) {\n      return this.doctype(pubID, sysID);\n    };\n\n    XMLNode.prototype.e = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLNode.prototype.n = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLNode.prototype.t = function(value) {\n      return this.text(value);\n    };\n\n    XMLNode.prototype.d = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLNode.prototype.c = function(value) {\n      return this.comment(value);\n    };\n\n    XMLNode.prototype.r = function(value) {\n      return this.raw(value);\n    };\n\n    XMLNode.prototype.i = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLNode.prototype.u = function() {\n      return this.up();\n    };\n\n    XMLNode.prototype.importXMLBuilder = function(doc) {\n      return this.importDocument(doc);\n    };\n\n    return XMLNode;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLNode.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLNode, XMLProcessingInstruction,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLProcessingInstruction = (function(superClass) {\n    extend(XMLProcessingInstruction, superClass);\n\n    function XMLProcessingInstruction(parent, target, value) {\n      XMLProcessingInstruction.__super__.constructor.call(this, parent);\n      if (target == null) {\n        throw new Error(\"Missing instruction target\");\n      }\n      this.target = this.stringify.insTarget(target);\n      if (value) {\n        this.value = this.stringify.insValue(value);\n      }\n    }\n\n    XMLProcessingInstruction.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLProcessingInstruction.prototype.toString = function(options) {\n      return this.options.writer.set(options).processingInstruction(this);\n    };\n\n    return XMLProcessingInstruction;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLRaw.js":
/*!***********************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLRaw.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLNode, XMLRaw,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLRaw = (function(superClass) {\n    extend(XMLRaw, superClass);\n\n    function XMLRaw(parent, text) {\n      XMLRaw.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing raw text\");\n      }\n      this.value = this.stringify.raw(text);\n    }\n\n    XMLRaw.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLRaw.prototype.toString = function(options) {\n      return this.options.writer.set(options).raw(this);\n    };\n\n    return XMLRaw;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLRaw.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStreamWriter.js":
/*!********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStreamWriter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ \"./node_modules/xmlbuilder/lib/XMLDeclaration.js\");\n\n  XMLDocType = __webpack_require__(/*! ./XMLDocType */ \"./node_modules/xmlbuilder/lib/XMLDocType.js\");\n\n  XMLCData = __webpack_require__(/*! ./XMLCData */ \"./node_modules/xmlbuilder/lib/XMLCData.js\");\n\n  XMLComment = __webpack_require__(/*! ./XMLComment */ \"./node_modules/xmlbuilder/lib/XMLComment.js\");\n\n  XMLElement = __webpack_require__(/*! ./XMLElement */ \"./node_modules/xmlbuilder/lib/XMLElement.js\");\n\n  XMLRaw = __webpack_require__(/*! ./XMLRaw */ \"./node_modules/xmlbuilder/lib/XMLRaw.js\");\n\n  XMLText = __webpack_require__(/*! ./XMLText */ \"./node_modules/xmlbuilder/lib/XMLText.js\");\n\n  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ \"./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js\");\n\n  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ \"./node_modules/xmlbuilder/lib/XMLDTDAttList.js\");\n\n  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ \"./node_modules/xmlbuilder/lib/XMLDTDElement.js\");\n\n  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ \"./node_modules/xmlbuilder/lib/XMLDTDEntity.js\");\n\n  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ \"./node_modules/xmlbuilder/lib/XMLDTDNotation.js\");\n\n  XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ \"./node_modules/xmlbuilder/lib/XMLWriterBase.js\");\n\n  module.exports = XMLStreamWriter = (function(superClass) {\n    extend(XMLStreamWriter, superClass);\n\n    function XMLStreamWriter(stream, options) {\n      XMLStreamWriter.__super__.constructor.call(this, options);\n      this.stream = stream;\n    }\n\n    XMLStreamWriter.prototype.document = function(doc) {\n      var child, i, j, len, len1, ref, ref1, results;\n      ref = doc.children;\n      for (i = 0, len = ref.length; i < len; i++) {\n        child = ref[i];\n        child.isLastRootNode = false;\n      }\n      doc.children[doc.children.length - 1].isLastRootNode = true;\n      ref1 = doc.children;\n      results = [];\n      for (j = 0, len1 = ref1.length; j < len1; j++) {\n        child = ref1[j];\n        switch (false) {\n          case !(child instanceof XMLDeclaration):\n            results.push(this.declaration(child));\n            break;\n          case !(child instanceof XMLDocType):\n            results.push(this.docType(child));\n            break;\n          case !(child instanceof XMLComment):\n            results.push(this.comment(child));\n            break;\n          case !(child instanceof XMLProcessingInstruction):\n            results.push(this.processingInstruction(child));\n            break;\n          default:\n            results.push(this.element(child));\n        }\n      }\n      return results;\n    };\n\n    XMLStreamWriter.prototype.attribute = function(att) {\n      return this.stream.write(' ' + att.name + '=\"' + att.value + '\"');\n    };\n\n    XMLStreamWriter.prototype.cdata = function(node, level) {\n      return this.stream.write(this.space(level) + '<![CDATA[' + node.text + ']]>' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.comment = function(node, level) {\n      return this.stream.write(this.space(level) + '<!-- ' + node.text + ' -->' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.declaration = function(node, level) {\n      this.stream.write(this.space(level));\n      this.stream.write('<?xml version=\"' + node.version + '\"');\n      if (node.encoding != null) {\n        this.stream.write(' encoding=\"' + node.encoding + '\"');\n      }\n      if (node.standalone != null) {\n        this.stream.write(' standalone=\"' + node.standalone + '\"');\n      }\n      this.stream.write(this.spacebeforeslash + '?>');\n      return this.stream.write(this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.docType = function(node, level) {\n      var child, i, len, ref;\n      level || (level = 0);\n      this.stream.write(this.space(level));\n      this.stream.write('<!DOCTYPE ' + node.root().name);\n      if (node.pubID && node.sysID) {\n        this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n      } else if (node.sysID) {\n        this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n      }\n      if (node.children.length > 0) {\n        this.stream.write(' [');\n        this.stream.write(this.endline(node));\n        ref = node.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          switch (false) {\n            case !(child instanceof XMLDTDAttList):\n              this.dtdAttList(child, level + 1);\n              break;\n            case !(child instanceof XMLDTDElement):\n              this.dtdElement(child, level + 1);\n              break;\n            case !(child instanceof XMLDTDEntity):\n              this.dtdEntity(child, level + 1);\n              break;\n            case !(child instanceof XMLDTDNotation):\n              this.dtdNotation(child, level + 1);\n              break;\n            case !(child instanceof XMLCData):\n              this.cdata(child, level + 1);\n              break;\n            case !(child instanceof XMLComment):\n              this.comment(child, level + 1);\n              break;\n            case !(child instanceof XMLProcessingInstruction):\n              this.processingInstruction(child, level + 1);\n              break;\n            default:\n              throw new Error(\"Unknown DTD node type: \" + child.constructor.name);\n          }\n        }\n        this.stream.write(']');\n      }\n      this.stream.write(this.spacebeforeslash + '>');\n      return this.stream.write(this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.element = function(node, level) {\n      var att, child, i, len, name, ref, ref1, space;\n      level || (level = 0);\n      space = this.space(level);\n      this.stream.write(space + '<' + node.name);\n      ref = node.attributes;\n      for (name in ref) {\n        if (!hasProp.call(ref, name)) continue;\n        att = ref[name];\n        this.attribute(att);\n      }\n      if (node.children.length === 0 || node.children.every(function(e) {\n        return e.value === '';\n      })) {\n        if (this.allowEmpty) {\n          this.stream.write('></' + node.name + '>');\n        } else {\n          this.stream.write(this.spacebeforeslash + '/>');\n        }\n      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {\n        this.stream.write('>');\n        this.stream.write(node.children[0].value);\n        this.stream.write('</' + node.name + '>');\n      } else {\n        this.stream.write('>' + this.newline);\n        ref1 = node.children;\n        for (i = 0, len = ref1.length; i < len; i++) {\n          child = ref1[i];\n          switch (false) {\n            case !(child instanceof XMLCData):\n              this.cdata(child, level + 1);\n              break;\n            case !(child instanceof XMLComment):\n              this.comment(child, level + 1);\n              break;\n            case !(child instanceof XMLElement):\n              this.element(child, level + 1);\n              break;\n            case !(child instanceof XMLRaw):\n              this.raw(child, level + 1);\n              break;\n            case !(child instanceof XMLText):\n              this.text(child, level + 1);\n              break;\n            case !(child instanceof XMLProcessingInstruction):\n              this.processingInstruction(child, level + 1);\n              break;\n            default:\n              throw new Error(\"Unknown XML node type: \" + child.constructor.name);\n          }\n        }\n        this.stream.write(space + '</' + node.name + '>');\n      }\n      return this.stream.write(this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.processingInstruction = function(node, level) {\n      this.stream.write(this.space(level) + '<?' + node.target);\n      if (node.value) {\n        this.stream.write(' ' + node.value);\n      }\n      return this.stream.write(this.spacebeforeslash + '?>' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.raw = function(node, level) {\n      return this.stream.write(this.space(level) + node.value + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.text = function(node, level) {\n      return this.stream.write(this.space(level) + node.value + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.dtdAttList = function(node, level) {\n      this.stream.write(this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType);\n      if (node.defaultValueType !== '#DEFAULT') {\n        this.stream.write(' ' + node.defaultValueType);\n      }\n      if (node.defaultValue) {\n        this.stream.write(' \"' + node.defaultValue + '\"');\n      }\n      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.dtdElement = function(node, level) {\n      this.stream.write(this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value);\n      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.dtdEntity = function(node, level) {\n      this.stream.write(this.space(level) + '<!ENTITY');\n      if (node.pe) {\n        this.stream.write(' %');\n      }\n      this.stream.write(' ' + node.name);\n      if (node.value) {\n        this.stream.write(' \"' + node.value + '\"');\n      } else {\n        if (node.pubID && node.sysID) {\n          this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n        } else if (node.sysID) {\n          this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n        }\n        if (node.nData) {\n          this.stream.write(' NDATA ' + node.nData);\n        }\n      }\n      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.dtdNotation = function(node, level) {\n      this.stream.write(this.space(level) + '<!NOTATION ' + node.name);\n      if (node.pubID && node.sysID) {\n        this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n      } else if (node.pubID) {\n        this.stream.write(' PUBLIC \"' + node.pubID + '\"');\n      } else if (node.sysID) {\n        this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n      }\n      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));\n    };\n\n    XMLStreamWriter.prototype.endline = function(node) {\n      if (!node.isLastRootNode) {\n        return this.newline;\n      } else {\n        return '';\n      }\n    };\n\n    return XMLStreamWriter;\n\n  })(XMLWriterBase);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLStreamWriter.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStringWriter.js":
/*!********************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStringWriter.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLDeclaration = __webpack_require__(/*! ./XMLDeclaration */ \"./node_modules/xmlbuilder/lib/XMLDeclaration.js\");\n\n  XMLDocType = __webpack_require__(/*! ./XMLDocType */ \"./node_modules/xmlbuilder/lib/XMLDocType.js\");\n\n  XMLCData = __webpack_require__(/*! ./XMLCData */ \"./node_modules/xmlbuilder/lib/XMLCData.js\");\n\n  XMLComment = __webpack_require__(/*! ./XMLComment */ \"./node_modules/xmlbuilder/lib/XMLComment.js\");\n\n  XMLElement = __webpack_require__(/*! ./XMLElement */ \"./node_modules/xmlbuilder/lib/XMLElement.js\");\n\n  XMLRaw = __webpack_require__(/*! ./XMLRaw */ \"./node_modules/xmlbuilder/lib/XMLRaw.js\");\n\n  XMLText = __webpack_require__(/*! ./XMLText */ \"./node_modules/xmlbuilder/lib/XMLText.js\");\n\n  XMLProcessingInstruction = __webpack_require__(/*! ./XMLProcessingInstruction */ \"./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js\");\n\n  XMLDTDAttList = __webpack_require__(/*! ./XMLDTDAttList */ \"./node_modules/xmlbuilder/lib/XMLDTDAttList.js\");\n\n  XMLDTDElement = __webpack_require__(/*! ./XMLDTDElement */ \"./node_modules/xmlbuilder/lib/XMLDTDElement.js\");\n\n  XMLDTDEntity = __webpack_require__(/*! ./XMLDTDEntity */ \"./node_modules/xmlbuilder/lib/XMLDTDEntity.js\");\n\n  XMLDTDNotation = __webpack_require__(/*! ./XMLDTDNotation */ \"./node_modules/xmlbuilder/lib/XMLDTDNotation.js\");\n\n  XMLWriterBase = __webpack_require__(/*! ./XMLWriterBase */ \"./node_modules/xmlbuilder/lib/XMLWriterBase.js\");\n\n  module.exports = XMLStringWriter = (function(superClass) {\n    extend(XMLStringWriter, superClass);\n\n    function XMLStringWriter(options) {\n      XMLStringWriter.__super__.constructor.call(this, options);\n    }\n\n    XMLStringWriter.prototype.document = function(doc) {\n      var child, i, len, r, ref;\n      this.textispresent = false;\n      r = '';\n      ref = doc.children;\n      for (i = 0, len = ref.length; i < len; i++) {\n        child = ref[i];\n        r += (function() {\n          switch (false) {\n            case !(child instanceof XMLDeclaration):\n              return this.declaration(child);\n            case !(child instanceof XMLDocType):\n              return this.docType(child);\n            case !(child instanceof XMLComment):\n              return this.comment(child);\n            case !(child instanceof XMLProcessingInstruction):\n              return this.processingInstruction(child);\n            default:\n              return this.element(child, 0);\n          }\n        }).call(this);\n      }\n      if (this.pretty && r.slice(-this.newline.length) === this.newline) {\n        r = r.slice(0, -this.newline.length);\n      }\n      return r;\n    };\n\n    XMLStringWriter.prototype.attribute = function(att) {\n      return ' ' + att.name + '=\"' + att.value + '\"';\n    };\n\n    XMLStringWriter.prototype.cdata = function(node, level) {\n      return this.space(level) + '<![CDATA[' + node.text + ']]>' + this.newline;\n    };\n\n    XMLStringWriter.prototype.comment = function(node, level) {\n      return this.space(level) + '<!-- ' + node.text + ' -->' + this.newline;\n    };\n\n    XMLStringWriter.prototype.declaration = function(node, level) {\n      var r;\n      r = this.space(level);\n      r += '<?xml version=\"' + node.version + '\"';\n      if (node.encoding != null) {\n        r += ' encoding=\"' + node.encoding + '\"';\n      }\n      if (node.standalone != null) {\n        r += ' standalone=\"' + node.standalone + '\"';\n      }\n      r += this.spacebeforeslash + '?>';\n      r += this.newline;\n      return r;\n    };\n\n    XMLStringWriter.prototype.docType = function(node, level) {\n      var child, i, len, r, ref;\n      level || (level = 0);\n      r = this.space(level);\n      r += '<!DOCTYPE ' + node.root().name;\n      if (node.pubID && node.sysID) {\n        r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n      } else if (node.sysID) {\n        r += ' SYSTEM \"' + node.sysID + '\"';\n      }\n      if (node.children.length > 0) {\n        r += ' [';\n        r += this.newline;\n        ref = node.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          r += (function() {\n            switch (false) {\n              case !(child instanceof XMLDTDAttList):\n                return this.dtdAttList(child, level + 1);\n              case !(child instanceof XMLDTDElement):\n                return this.dtdElement(child, level + 1);\n              case !(child instanceof XMLDTDEntity):\n                return this.dtdEntity(child, level + 1);\n              case !(child instanceof XMLDTDNotation):\n                return this.dtdNotation(child, level + 1);\n              case !(child instanceof XMLCData):\n                return this.cdata(child, level + 1);\n              case !(child instanceof XMLComment):\n                return this.comment(child, level + 1);\n              case !(child instanceof XMLProcessingInstruction):\n                return this.processingInstruction(child, level + 1);\n              default:\n                throw new Error(\"Unknown DTD node type: \" + child.constructor.name);\n            }\n          }).call(this);\n        }\n        r += ']';\n      }\n      r += this.spacebeforeslash + '>';\n      r += this.newline;\n      return r;\n    };\n\n    XMLStringWriter.prototype.element = function(node, level) {\n      var att, child, i, j, len, len1, name, r, ref, ref1, ref2, space, textispresentwasset;\n      level || (level = 0);\n      textispresentwasset = false;\n      if (this.textispresent) {\n        this.newline = '';\n        this.pretty = false;\n      } else {\n        this.newline = this.newlinedefault;\n        this.pretty = this.prettydefault;\n      }\n      space = this.space(level);\n      r = '';\n      r += space + '<' + node.name;\n      ref = node.attributes;\n      for (name in ref) {\n        if (!hasProp.call(ref, name)) continue;\n        att = ref[name];\n        r += this.attribute(att);\n      }\n      if (node.children.length === 0 || node.children.every(function(e) {\n        return e.value === '';\n      })) {\n        if (this.allowEmpty) {\n          r += '></' + node.name + '>' + this.newline;\n        } else {\n          r += this.spacebeforeslash + '/>' + this.newline;\n        }\n      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {\n        r += '>';\n        r += node.children[0].value;\n        r += '</' + node.name + '>' + this.newline;\n      } else {\n        if (this.dontprettytextnodes) {\n          ref1 = node.children;\n          for (i = 0, len = ref1.length; i < len; i++) {\n            child = ref1[i];\n            if (child.value != null) {\n              this.textispresent++;\n              textispresentwasset = true;\n              break;\n            }\n          }\n        }\n        if (this.textispresent) {\n          this.newline = '';\n          this.pretty = false;\n          space = this.space(level);\n        }\n        r += '>' + this.newline;\n        ref2 = node.children;\n        for (j = 0, len1 = ref2.length; j < len1; j++) {\n          child = ref2[j];\n          r += (function() {\n            switch (false) {\n              case !(child instanceof XMLCData):\n                return this.cdata(child, level + 1);\n              case !(child instanceof XMLComment):\n                return this.comment(child, level + 1);\n              case !(child instanceof XMLElement):\n                return this.element(child, level + 1);\n              case !(child instanceof XMLRaw):\n                return this.raw(child, level + 1);\n              case !(child instanceof XMLText):\n                return this.text(child, level + 1);\n              case !(child instanceof XMLProcessingInstruction):\n                return this.processingInstruction(child, level + 1);\n              default:\n                throw new Error(\"Unknown XML node type: \" + child.constructor.name);\n            }\n          }).call(this);\n        }\n        if (textispresentwasset) {\n          this.textispresent--;\n        }\n        if (!this.textispresent) {\n          this.newline = this.newlinedefault;\n          this.pretty = this.prettydefault;\n        }\n        r += space + '</' + node.name + '>' + this.newline;\n      }\n      return r;\n    };\n\n    XMLStringWriter.prototype.processingInstruction = function(node, level) {\n      var r;\n      r = this.space(level) + '<?' + node.target;\n      if (node.value) {\n        r += ' ' + node.value;\n      }\n      r += this.spacebeforeslash + '?>' + this.newline;\n      return r;\n    };\n\n    XMLStringWriter.prototype.raw = function(node, level) {\n      return this.space(level) + node.value + this.newline;\n    };\n\n    XMLStringWriter.prototype.text = function(node, level) {\n      return this.space(level) + node.value + this.newline;\n    };\n\n    XMLStringWriter.prototype.dtdAttList = function(node, level) {\n      var r;\n      r = this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;\n      if (node.defaultValueType !== '#DEFAULT') {\n        r += ' ' + node.defaultValueType;\n      }\n      if (node.defaultValue) {\n        r += ' \"' + node.defaultValue + '\"';\n      }\n      r += this.spacebeforeslash + '>' + this.newline;\n      return r;\n    };\n\n    XMLStringWriter.prototype.dtdElement = function(node, level) {\n      return this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value + this.spacebeforeslash + '>' + this.newline;\n    };\n\n    XMLStringWriter.prototype.dtdEntity = function(node, level) {\n      var r;\n      r = this.space(level) + '<!ENTITY';\n      if (node.pe) {\n        r += ' %';\n      }\n      r += ' ' + node.name;\n      if (node.value) {\n        r += ' \"' + node.value + '\"';\n      } else {\n        if (node.pubID && node.sysID) {\n          r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n        } else if (node.sysID) {\n          r += ' SYSTEM \"' + node.sysID + '\"';\n        }\n        if (node.nData) {\n          r += ' NDATA ' + node.nData;\n        }\n      }\n      r += this.spacebeforeslash + '>' + this.newline;\n      return r;\n    };\n\n    XMLStringWriter.prototype.dtdNotation = function(node, level) {\n      var r;\n      r = this.space(level) + '<!NOTATION ' + node.name;\n      if (node.pubID && node.sysID) {\n        r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n      } else if (node.pubID) {\n        r += ' PUBLIC \"' + node.pubID + '\"';\n      } else if (node.sysID) {\n        r += ' SYSTEM \"' + node.sysID + '\"';\n      }\n      r += this.spacebeforeslash + '>' + this.newline;\n      return r;\n    };\n\n    XMLStringWriter.prototype.openNode = function(node, level) {\n      var att, name, r, ref;\n      level || (level = 0);\n      if (node instanceof XMLElement) {\n        r = this.space(level) + '<' + node.name;\n        ref = node.attributes;\n        for (name in ref) {\n          if (!hasProp.call(ref, name)) continue;\n          att = ref[name];\n          r += this.attribute(att);\n        }\n        r += (node.children ? '>' : '/>') + this.newline;\n        return r;\n      } else {\n        r = this.space(level) + '<!DOCTYPE ' + node.rootNodeName;\n        if (node.pubID && node.sysID) {\n          r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n        } else if (node.sysID) {\n          r += ' SYSTEM \"' + node.sysID + '\"';\n        }\n        r += (node.children ? ' [' : '>') + this.newline;\n        return r;\n      }\n    };\n\n    XMLStringWriter.prototype.closeNode = function(node, level) {\n      level || (level = 0);\n      switch (false) {\n        case !(node instanceof XMLElement):\n          return this.space(level) + '</' + node.name + '>' + this.newline;\n        case !(node instanceof XMLDocType):\n          return this.space(level) + ']>' + this.newline;\n      }\n    };\n\n    return XMLStringWriter;\n\n  })(XMLWriterBase);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLStringWriter.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLStringifier.js":
/*!*******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLStringifier.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLStringifier,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    hasProp = {}.hasOwnProperty;\n\n  module.exports = XMLStringifier = (function() {\n    function XMLStringifier(options) {\n      this.assertLegalChar = bind(this.assertLegalChar, this);\n      var key, ref, value;\n      options || (options = {});\n      this.noDoubleEncoding = options.noDoubleEncoding;\n      ref = options.stringify || {};\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[key] = value;\n      }\n    }\n\n    XMLStringifier.prototype.eleName = function(val) {\n      val = '' + val || '';\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.eleText = function(val) {\n      val = '' + val || '';\n      return this.assertLegalChar(this.elEscape(val));\n    };\n\n    XMLStringifier.prototype.cdata = function(val) {\n      val = '' + val || '';\n      val = val.replace(']]>', ']]]]><![CDATA[>');\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.comment = function(val) {\n      val = '' + val || '';\n      if (val.match(/--/)) {\n        throw new Error(\"Comment text cannot contain double-hypen: \" + val);\n      }\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.raw = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.attName = function(val) {\n      return val = '' + val || '';\n    };\n\n    XMLStringifier.prototype.attValue = function(val) {\n      val = '' + val || '';\n      return this.attEscape(val);\n    };\n\n    XMLStringifier.prototype.insTarget = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.insValue = function(val) {\n      val = '' + val || '';\n      if (val.match(/\\?>/)) {\n        throw new Error(\"Invalid processing instruction value: \" + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlVersion = function(val) {\n      val = '' + val || '';\n      if (!val.match(/1\\.[0-9]+/)) {\n        throw new Error(\"Invalid version number: \" + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlEncoding = function(val) {\n      val = '' + val || '';\n      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {\n        throw new Error(\"Invalid encoding: \" + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlStandalone = function(val) {\n      if (val) {\n        return \"yes\";\n      } else {\n        return \"no\";\n      }\n    };\n\n    XMLStringifier.prototype.dtdPubID = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdSysID = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdElementValue = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdAttType = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdAttDefault = function(val) {\n      if (val != null) {\n        return '' + val || '';\n      } else {\n        return val;\n      }\n    };\n\n    XMLStringifier.prototype.dtdEntityValue = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.dtdNData = function(val) {\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.convertAttKey = '@';\n\n    XMLStringifier.prototype.convertPIKey = '?';\n\n    XMLStringifier.prototype.convertTextKey = '#text';\n\n    XMLStringifier.prototype.convertCDataKey = '#cdata';\n\n    XMLStringifier.prototype.convertCommentKey = '#comment';\n\n    XMLStringifier.prototype.convertRawKey = '#raw';\n\n    XMLStringifier.prototype.assertLegalChar = function(str) {\n      var res;\n      res = str.match(/[\\0\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/);\n      if (res) {\n        throw new Error(\"Invalid character in string: \" + str + \" at index \" + res.index);\n      }\n      return str;\n    };\n\n    XMLStringifier.prototype.elEscape = function(str) {\n      var ampregex;\n      ampregex = this.noDoubleEncoding ? /(?!&\\S+;)&/g : /&/g;\n      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\r/g, '&#xD;');\n    };\n\n    XMLStringifier.prototype.attEscape = function(str) {\n      var ampregex;\n      ampregex = this.noDoubleEncoding ? /(?!&\\S+;)&/g : /&/g;\n      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/\"/g, '&quot;').replace(/\\t/g, '&#x9;').replace(/\\n/g, '&#xA;').replace(/\\r/g, '&#xD;');\n    };\n\n    return XMLStringifier;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLStringifier.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLText.js":
/*!************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLText.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLNode, XMLText,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = __webpack_require__(/*! ./XMLNode */ \"./node_modules/xmlbuilder/lib/XMLNode.js\");\n\n  module.exports = XMLText = (function(superClass) {\n    extend(XMLText, superClass);\n\n    function XMLText(parent, text) {\n      XMLText.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing element text\");\n      }\n      this.value = this.stringify.eleText(text);\n    }\n\n    XMLText.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLText.prototype.toString = function(options) {\n      return this.options.writer.set(options).text(this);\n    };\n\n    return XMLText;\n\n  })(XMLNode);\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLText.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/XMLWriterBase.js":
/*!******************************************************!*\
  !*** ./node_modules/xmlbuilder/lib/XMLWriterBase.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLWriterBase,\n    hasProp = {}.hasOwnProperty;\n\n  module.exports = XMLWriterBase = (function() {\n    function XMLWriterBase(options) {\n      var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;\n      options || (options = {});\n      this.pretty = options.pretty || false;\n      this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;\n      if (this.pretty) {\n        this.indent = (ref1 = options.indent) != null ? ref1 : '  ';\n        this.newline = (ref2 = options.newline) != null ? ref2 : '\\n';\n        this.offset = (ref3 = options.offset) != null ? ref3 : 0;\n        this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;\n      } else {\n        this.indent = '';\n        this.newline = '';\n        this.offset = 0;\n        this.dontprettytextnodes = 0;\n      }\n      this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : '';\n      if (this.spacebeforeslash === true) {\n        this.spacebeforeslash = ' ';\n      }\n      this.newlinedefault = this.newline;\n      this.prettydefault = this.pretty;\n      ref6 = options.writer || {};\n      for (key in ref6) {\n        if (!hasProp.call(ref6, key)) continue;\n        value = ref6[key];\n        this[key] = value;\n      }\n    }\n\n    XMLWriterBase.prototype.set = function(options) {\n      var key, ref, value;\n      options || (options = {});\n      if (\"pretty\" in options) {\n        this.pretty = options.pretty;\n      }\n      if (\"allowEmpty\" in options) {\n        this.allowEmpty = options.allowEmpty;\n      }\n      if (this.pretty) {\n        this.indent = \"indent\" in options ? options.indent : '  ';\n        this.newline = \"newline\" in options ? options.newline : '\\n';\n        this.offset = \"offset\" in options ? options.offset : 0;\n        this.dontprettytextnodes = \"dontprettytextnodes\" in options ? options.dontprettytextnodes : 0;\n      } else {\n        this.indent = '';\n        this.newline = '';\n        this.offset = 0;\n        this.dontprettytextnodes = 0;\n      }\n      this.spacebeforeslash = \"spacebeforeslash\" in options ? options.spacebeforeslash : '';\n      if (this.spacebeforeslash === true) {\n        this.spacebeforeslash = ' ';\n      }\n      this.newlinedefault = this.newline;\n      this.prettydefault = this.pretty;\n      ref = options.writer || {};\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[key] = value;\n      }\n      return this;\n    };\n\n    XMLWriterBase.prototype.space = function(level) {\n      var indent;\n      if (this.pretty) {\n        indent = (level || 0) + this.offset + 1;\n        if (indent > 0) {\n          return new Array(indent).join(this.indent);\n        } else {\n          return '';\n        }\n      } else {\n        return '';\n      }\n    };\n\n    return XMLWriterBase;\n\n  })();\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/XMLWriterBase.js?");

/***/ }),

/***/ "./node_modules/xmlbuilder/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/xmlbuilder/lib/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;\n\n  ref = __webpack_require__(/*! ./Utility */ \"./node_modules/xmlbuilder/lib/Utility.js\"), assign = ref.assign, isFunction = ref.isFunction;\n\n  XMLDocument = __webpack_require__(/*! ./XMLDocument */ \"./node_modules/xmlbuilder/lib/XMLDocument.js\");\n\n  XMLDocumentCB = __webpack_require__(/*! ./XMLDocumentCB */ \"./node_modules/xmlbuilder/lib/XMLDocumentCB.js\");\n\n  XMLStringWriter = __webpack_require__(/*! ./XMLStringWriter */ \"./node_modules/xmlbuilder/lib/XMLStringWriter.js\");\n\n  XMLStreamWriter = __webpack_require__(/*! ./XMLStreamWriter */ \"./node_modules/xmlbuilder/lib/XMLStreamWriter.js\");\n\n  module.exports.create = function(name, xmldec, doctype, options) {\n    var doc, root;\n    if (name == null) {\n      throw new Error(\"Root element needs a name\");\n    }\n    options = assign({}, xmldec, doctype, options);\n    doc = new XMLDocument(options);\n    root = doc.element(name);\n    if (!options.headless) {\n      doc.declaration(options);\n      if ((options.pubID != null) || (options.sysID != null)) {\n        doc.doctype(options);\n      }\n    }\n    return root;\n  };\n\n  module.exports.begin = function(options, onData, onEnd) {\n    var ref1;\n    if (isFunction(options)) {\n      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];\n      options = {};\n    }\n    if (onData) {\n      return new XMLDocumentCB(options, onData, onEnd);\n    } else {\n      return new XMLDocument(options);\n    }\n  };\n\n  module.exports.stringWriter = function(options) {\n    return new XMLStringWriter(options);\n  };\n\n  module.exports.streamWriter = function(stream, options) {\n    return new XMLStreamWriter(stream, options);\n  };\n\n}).call(this);\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlbuilder/lib/index.js?");

/***/ }),

/***/ "./node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js":
/*!***************************************************************!*\
  !*** ./node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.\n *\n * This can be used with JS designed for browsers to improve reuse of code and\n * allow the use of existing libraries.\n *\n * Usage: include(\"XMLHttpRequest.js\") and use XMLHttpRequest per W3C specs.\n *\n * @author Dan DeFelippi <dan@driverdan.com>\n * @contributor David Ellis <d.f.ellis@ieee.org>\n * @license MIT\n */\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar Url = __webpack_require__(/*! url */ \"url\");\nvar spawn = __webpack_require__(/*! child_process */ \"child_process\").spawn;\n\n/**\n * Module exports.\n */\n\nmodule.exports = XMLHttpRequest;\n\n// backwards-compat\nXMLHttpRequest.XMLHttpRequest = XMLHttpRequest;\n\n/**\n * `XMLHttpRequest` constructor.\n *\n * Supported options for the `opts` object are:\n *\n *  - `agent`: An http.Agent instance; http.globalAgent may be used; if 'undefined', agent usage is disabled\n *\n * @param {Object} opts optional \"options\" object\n */\n\nfunction XMLHttpRequest(opts) {\n  \"use strict\";\n\n  opts = opts || {};\n\n  /**\n   * Private variables\n   */\n  var self = this;\n  var http = __webpack_require__(/*! http */ \"http\");\n  var https = __webpack_require__(/*! https */ \"https\");\n\n  // Holds http.js objects\n  var request;\n  var response;\n\n  // Request settings\n  var settings = {};\n\n  // Disable header blacklist.\n  // Not part of XHR specs.\n  var disableHeaderCheck = false;\n\n  // Set some default headers\n  var defaultHeaders = {\n    \"User-Agent\": \"node-XMLHttpRequest\",\n    \"Accept\": \"*/*\"\n  };\n\n  var headers = Object.assign({}, defaultHeaders);\n\n  // These headers are not user setable.\n  // The following are allowed but banned in the spec:\n  // * user-agent\n  var forbiddenRequestHeaders = [\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"access-control-request-headers\",\n    \"access-control-request-method\",\n    \"connection\",\n    \"content-length\",\n    \"content-transfer-encoding\",\n    \"cookie\",\n    \"cookie2\",\n    \"date\",\n    \"expect\",\n    \"host\",\n    \"keep-alive\",\n    \"origin\",\n    \"referer\",\n    \"te\",\n    \"trailer\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"via\"\n  ];\n\n  // These request methods are not allowed\n  var forbiddenRequestMethods = [\n    \"TRACE\",\n    \"TRACK\",\n    \"CONNECT\"\n  ];\n\n  // Send flag\n  var sendFlag = false;\n  // Error flag, used when errors occur or abort is called\n  var errorFlag = false;\n\n  // Event listeners\n  var listeners = {};\n\n  /**\n   * Constants\n   */\n\n  this.UNSENT = 0;\n  this.OPENED = 1;\n  this.HEADERS_RECEIVED = 2;\n  this.LOADING = 3;\n  this.DONE = 4;\n\n  /**\n   * Public vars\n   */\n\n  // Current state\n  this.readyState = this.UNSENT;\n\n  // default ready state change handler in case one is not set or is set late\n  this.onreadystatechange = null;\n\n  // Result & response\n  this.responseText = \"\";\n  this.responseXML = \"\";\n  this.status = null;\n  this.statusText = null;\n\n  /**\n   * Private methods\n   */\n\n  /**\n   * Check if the specified header is allowed.\n   *\n   * @param string header Header to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpHeader = function(header) {\n    return disableHeaderCheck || (header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1);\n  };\n\n  /**\n   * Check if the specified method is allowed.\n   *\n   * @param string method Request method to validate\n   * @return boolean False if not allowed, otherwise true\n   */\n  var isAllowedHttpMethod = function(method) {\n    return (method && forbiddenRequestMethods.indexOf(method) === -1);\n  };\n\n  /**\n   * Public methods\n   */\n\n  /**\n   * Open the connection. Currently supports local server requests.\n   *\n   * @param string method Connection method (eg GET, POST)\n   * @param string url URL for the connection.\n   * @param boolean async Asynchronous connection. Default is true.\n   * @param string user Username for basic authentication (optional)\n   * @param string password Password for basic authentication (optional)\n   */\n  this.open = function(method, url, async, user, password) {\n    this.abort();\n    errorFlag = false;\n\n    // Check for valid request method\n    if (!isAllowedHttpMethod(method)) {\n      throw \"SecurityError: Request method not allowed\";\n    }\n\n    settings = {\n      \"method\": method,\n      \"url\": url.toString(),\n      \"async\": (typeof async !== \"boolean\" ? true : async),\n      \"user\": user || null,\n      \"password\": password || null\n    };\n\n    setState(this.OPENED);\n  };\n\n  /**\n   * Disables or enables isAllowedHttpHeader() check the request. Enabled by default.\n   * This does not conform to the W3C spec.\n   *\n   * @param boolean state Enable or disable header checking.\n   */\n  this.setDisableHeaderCheck = function(state) {\n    disableHeaderCheck = state;\n  };\n\n  /**\n   * Sets a header for the request.\n   *\n   * @param string header Header name\n   * @param string value Header value\n   * @return boolean Header added\n   */\n  this.setRequestHeader = function(header, value) {\n    if (this.readyState != this.OPENED) {\n      throw \"INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN\";\n      return false;\n    }\n    if (!isAllowedHttpHeader(header)) {\n      console.warn('Refused to set unsafe header \"' + header + '\"');\n      return false;\n    }\n    if (sendFlag) {\n      throw \"INVALID_STATE_ERR: send flag is true\";\n      return false;\n    }\n    headers[header] = value;\n    return true;\n  };\n\n  /**\n   * Gets a header from the server response.\n   *\n   * @param string header Name of header to get.\n   * @return string Text of the header or null if it doesn't exist.\n   */\n  this.getResponseHeader = function(header) {\n    if (typeof header === \"string\"\n      && this.readyState > this.OPENED\n      && response.headers[header.toLowerCase()]\n      && !errorFlag\n    ) {\n      return response.headers[header.toLowerCase()];\n    }\n\n    return null;\n  };\n\n  /**\n   * Gets all the response headers.\n   *\n   * @return string A string with all response headers separated by CR+LF\n   */\n  this.getAllResponseHeaders = function() {\n    if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {\n      return \"\";\n    }\n    var result = \"\";\n\n    for (var i in response.headers) {\n      // Cookie headers are excluded\n      if (i !== \"set-cookie\" && i !== \"set-cookie2\") {\n        result += i + \": \" + response.headers[i] + \"\\r\\n\";\n      }\n    }\n    return result.substr(0, result.length - 2);\n  };\n\n  /**\n   * Gets a request header\n   *\n   * @param string name Name of header to get\n   * @return string Returns the request header or empty string if not set\n   */\n  this.getRequestHeader = function(name) {\n    // @TODO Make this case insensitive\n    if (typeof name === \"string\" && headers[name]) {\n      return headers[name];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Sends the request to the server.\n   *\n   * @param string data Optional data to send as request body.\n   */\n  this.send = function(data) {\n    if (this.readyState != this.OPENED) {\n      throw \"INVALID_STATE_ERR: connection must be opened before send() is called\";\n    }\n\n    if (sendFlag) {\n      throw \"INVALID_STATE_ERR: send has already been called\";\n    }\n\n    var ssl = false, local = false;\n    var url = Url.parse(settings.url);\n    var host;\n    // Determine the server\n    switch (url.protocol) {\n      case 'https:':\n        ssl = true;\n        // SSL & non-SSL both need host, no break here.\n      case 'http:':\n        host = url.hostname;\n        break;\n\n      case 'file:':\n        local = true;\n        break;\n\n      case undefined:\n      case '':\n        host = \"localhost\";\n        break;\n\n      default:\n        throw \"Protocol not supported.\";\n    }\n\n    // Load files off the local filesystem (file://)\n    if (local) {\n      if (settings.method !== \"GET\") {\n        throw \"XMLHttpRequest: Only GET method is supported\";\n      }\n\n      if (settings.async) {\n        fs.readFile(url.pathname, 'utf8', function(error, data) {\n          if (error) {\n            self.handleError(error);\n          } else {\n            self.status = 200;\n            self.responseText = data;\n            setState(self.DONE);\n          }\n        });\n      } else {\n        try {\n          this.responseText = fs.readFileSync(url.pathname, 'utf8');\n          this.status = 200;\n          setState(self.DONE);\n        } catch(e) {\n          this.handleError(e);\n        }\n      }\n\n      return;\n    }\n\n    // Default to port 80. If accessing localhost on another port be sure\n    // to use http://localhost:port/path\n    var port = url.port || (ssl ? 443 : 80);\n    // Add query string if one is used\n    var uri = url.pathname + (url.search ? url.search : '');\n\n    // Set the Host header or the server may reject the request\n    headers[\"Host\"] = host;\n    if (!((ssl && port === 443) || port === 80)) {\n      headers[\"Host\"] += ':' + url.port;\n    }\n\n    // Set Basic Auth if necessary\n    if (settings.user) {\n      if (typeof settings.password == \"undefined\") {\n        settings.password = \"\";\n      }\n      var authBuf = new Buffer(settings.user + \":\" + settings.password);\n      headers[\"Authorization\"] = \"Basic \" + authBuf.toString(\"base64\");\n    }\n\n    // Set content length header\n    if (settings.method === \"GET\" || settings.method === \"HEAD\") {\n      data = null;\n    } else if (data) {\n      headers[\"Content-Length\"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);\n\n      if (!headers[\"Content-Type\"]) {\n        headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n      }\n    } else if (settings.method === \"POST\") {\n      // For a post with no data set Content-Length: 0.\n      // This is required by buggy servers that don't meet the specs.\n      headers[\"Content-Length\"] = 0;\n    }\n\n    var agent = opts.agent || false;\n    var options = {\n      host: host,\n      port: port,\n      path: uri,\n      method: settings.method,\n      headers: headers,\n      agent: agent\n    };\n\n    if (ssl) {\n      options.pfx = opts.pfx;\n      options.key = opts.key;\n      options.passphrase = opts.passphrase;\n      options.cert = opts.cert;\n      options.ca = opts.ca;\n      options.ciphers = opts.ciphers;\n      options.rejectUnauthorized = opts.rejectUnauthorized;\n    }\n\n    // Reset error flag\n    errorFlag = false;\n\n    // Handle async requests\n    if (settings.async) {\n      // Use the proper protocol\n      var doRequest = ssl ? https.request : http.request;\n\n      // Request is being sent, set send flag\n      sendFlag = true;\n\n      // As per spec, this is called here for historical reasons.\n      self.dispatchEvent(\"readystatechange\");\n\n      // Handler for the response\n      var responseHandler = function(resp) {\n        // Set response var to the response we got back\n        // This is so it remains accessable outside this scope\n        response = resp;\n        // Check for redirect\n        // @TODO Prevent looped redirects\n        if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {\n          // Change URL to the redirect location\n          settings.url = response.headers.location;\n          var url = Url.parse(settings.url);\n          // Set host var in case it's used later\n          host = url.hostname;\n          // Options for the new request\n          var newOptions = {\n            hostname: url.hostname,\n            port: url.port,\n            path: url.path,\n            method: response.statusCode === 303 ? 'GET' : settings.method,\n            headers: headers\n          };\n\n          if (ssl) {\n            newOptions.pfx = opts.pfx;\n            newOptions.key = opts.key;\n            newOptions.passphrase = opts.passphrase;\n            newOptions.cert = opts.cert;\n            newOptions.ca = opts.ca;\n            newOptions.ciphers = opts.ciphers;\n            newOptions.rejectUnauthorized = opts.rejectUnauthorized;\n          }\n\n          // Issue the new request\n          request = doRequest(newOptions, responseHandler).on('error', errorHandler);\n          request.end();\n          // @TODO Check if an XHR event needs to be fired here\n          return;\n        }\n\n        if (response && response.setEncoding) {\n          response.setEncoding(\"utf8\");\n        }\n\n        setState(self.HEADERS_RECEIVED);\n        self.status = response.statusCode;\n\n        response.on('data', function(chunk) {\n          // Make sure there's some data\n          if (chunk) {\n            self.responseText += chunk;\n          }\n          // Don't emit state changes if the connection has been aborted.\n          if (sendFlag) {\n            setState(self.LOADING);\n          }\n        });\n\n        response.on('end', function() {\n          if (sendFlag) {\n            // The sendFlag needs to be set before setState is called.  Otherwise if we are chaining callbacks\n            // there can be a timing issue (the callback is called and a new call is made before the flag is reset).\n            sendFlag = false;\n            // Discard the 'end' event if the connection has been aborted\n            setState(self.DONE);\n          }\n        });\n\n        response.on('error', function(error) {\n          self.handleError(error);\n        });\n      }\n\n      // Error handler for the request\n      var errorHandler = function(error) {\n        self.handleError(error);\n      }\n\n      // Create the request\n      request = doRequest(options, responseHandler).on('error', errorHandler);\n\n      // Node 0.4 and later won't accept empty data. Make sure it's needed.\n      if (data) {\n        request.write(data);\n      }\n\n      request.end();\n\n      self.dispatchEvent(\"loadstart\");\n    } else { // Synchronous\n      // Create a temporary file for communication with the other Node process\n      var contentFile = \".node-xmlhttprequest-content-\" + process.pid;\n      var syncFile = \".node-xmlhttprequest-sync-\" + process.pid;\n      fs.writeFileSync(syncFile, \"\", \"utf8\");\n      // The async request the other Node process executes\n      var execString = \"var http = require('http'), https = require('https'), fs = require('fs');\"\n        + \"var doRequest = http\" + (ssl ? \"s\" : \"\") + \".request;\"\n        + \"var options = \" + JSON.stringify(options) + \";\"\n        + \"var responseText = '';\"\n        + \"var req = doRequest(options, function(response) {\"\n        + \"response.setEncoding('utf8');\"\n        + \"response.on('data', function(chunk) {\"\n        + \"  responseText += chunk;\"\n        + \"});\"\n        + \"response.on('end', function() {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-STATUS:' + response.statusCode + ',' + responseText, 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + \"response.on('error', function(error) {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + \"}).on('error', function(error) {\"\n        + \"fs.writeFileSync('\" + contentFile + \"', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');\"\n        + \"fs.unlinkSync('\" + syncFile + \"');\"\n        + \"});\"\n        + (data ? \"req.write('\" + data.replace(/'/g, \"\\\\'\") + \"');\":\"\")\n        + \"req.end();\";\n      // Start the other Node Process, executing this string\n      var syncProc = spawn(process.argv[0], [\"-e\", execString]);\n      var statusText;\n      while(fs.existsSync(syncFile)) {\n        // Wait while the sync file is empty\n      }\n      self.responseText = fs.readFileSync(contentFile, 'utf8');\n      // Kill the child process once the file has data\n      syncProc.stdin.end();\n      // Remove the temporary file\n      fs.unlinkSync(contentFile);\n      if (self.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {\n        // If the file returned an error, handle it\n        var errorObj = self.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, \"\");\n        self.handleError(errorObj);\n      } else {\n        // If the file returned okay, parse its data and move to the DONE state\n        self.status = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, \"$1\");\n        self.responseText = self.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, \"$1\");\n        setState(self.DONE);\n      }\n    }\n  };\n\n  /**\n   * Called when an error is encountered to deal with it.\n   */\n  this.handleError = function(error) {\n    this.status = 503;\n    this.statusText = error;\n    this.responseText = error.stack;\n    errorFlag = true;\n    setState(this.DONE);\n  };\n\n  /**\n   * Aborts a request.\n   */\n  this.abort = function() {\n    if (request) {\n      request.abort();\n      request = null;\n    }\n\n    headers = Object.assign({}, defaultHeaders);\n    this.responseText = \"\";\n    this.responseXML = \"\";\n\n    errorFlag = true;\n\n    if (this.readyState !== this.UNSENT\n        && (this.readyState !== this.OPENED || sendFlag)\n        && this.readyState !== this.DONE) {\n      sendFlag = false;\n      setState(this.DONE);\n    }\n    this.readyState = this.UNSENT;\n  };\n\n  /**\n   * Adds an event listener. Preferred method of binding to events.\n   */\n  this.addEventListener = function(event, callback) {\n    if (!(event in listeners)) {\n      listeners[event] = [];\n    }\n    // Currently allows duplicate callbacks. Should it?\n    listeners[event].push(callback);\n  };\n\n  /**\n   * Remove an event callback that has already been bound.\n   * Only works on the matching funciton, cannot be a copy.\n   */\n  this.removeEventListener = function(event, callback) {\n    if (event in listeners) {\n      // Filter will return a new array with the callback removed\n      listeners[event] = listeners[event].filter(function(ev) {\n        return ev !== callback;\n      });\n    }\n  };\n\n  /**\n   * Dispatch any events, including both \"on\" methods and events attached using addEventListener.\n   */\n  this.dispatchEvent = function(event) {\n    if (typeof self[\"on\" + event] === \"function\") {\n      self[\"on\" + event]();\n    }\n    if (event in listeners) {\n      for (var i = 0, len = listeners[event].length; i < len; i++) {\n        listeners[event][i].call(self);\n      }\n    }\n  };\n\n  /**\n   * Changes readyState and calls onreadystatechange.\n   *\n   * @param int state New state\n   */\n  var setState = function(state) {\n    if (self.readyState !== state) {\n      self.readyState = state;\n\n      if (settings.async || self.readyState < self.OPENED || self.readyState === self.DONE) {\n        self.dispatchEvent(\"readystatechange\");\n      }\n\n      if (self.readyState === self.DONE && !errorFlag) {\n        self.dispatchEvent(\"load\");\n        // @TODO figure out InspectorInstrumentation::didLoadXHR(cookie)\n        self.dispatchEvent(\"loadend\");\n      }\n    }\n  };\n};\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js?");

/***/ }),

/***/ "./node_modules/yeast/index.js":
/*!*************************************!*\
  !*** ./node_modules/yeast/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')\n  , length = 64\n  , map = {}\n  , seed = 0\n  , i = 0\n  , prev;\n\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n  var encoded = '';\n\n  do {\n    encoded = alphabet[num % length] + encoded;\n    num = Math.floor(num / length);\n  } while (num > 0);\n\n  return encoded;\n}\n\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n  var decoded = 0;\n\n  for (i = 0; i < str.length; i++) {\n    decoded = decoded * length + map[str.charAt(i)];\n  }\n\n  return decoded;\n}\n\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n  var now = encode(+new Date());\n\n  if (now !== prev) return seed = 0, prev = now;\n  return now +'.'+ encode(seed++);\n}\n\n//\n// Map each character to its index.\n//\nfor (; i < length; i++) map[alphabet[i]] = i;\n\n//\n// Expose the `yeast`, `encode` and `decode` functions.\n//\nyeast.encode = encode;\nyeast.decode = decode;\nmodule.exports = yeast;\n\n\n//# sourceURL=webpack://ApolloSIP/./node_modules/yeast/index.js?");

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, title, description, version, homepage, author, contributors, main, browser, keywords, license, repository, dependencies, devDependencies, scripts, default */
/***/ (function(module) {

eval("module.exports = {\"name\":\"apollosip\",\"title\":\"ApolloSIP\",\"description\":\"The Javascript SIP library\",\"version\":\"0.1.0\",\"homepage\":\"http://www.yealink.com.cn/\",\"author\":\"Yealink Inc.\",\"contributors\":[\"ito\"],\"main\":\"./dist/apollosip.js\",\"browser\":{\"ws\":\"./lib/WebSocket.js\",\"./dist/apollosip.js\":\"./dist/apollosip-web.js\"},\"keywords\":[\"sip\",\"websocket\",\"webrtc\",\"node\",\"browser\",\"library\",\"javascript\"],\"license\":\"MIT\",\"repository\":{\"type\":\"git\",\"url\":\"\"},\"dependencies\":{\"bowser\":\"^1.9.2\",\"debug\":\"^3.1.0\",\"fast-xml-parser\":\"^3.3.3\",\"fecha\":\"^2.3.3\",\"js-base64\":\"^2.4.3\",\"sdp-transform\":\"file:./sdp-transform\",\"socket.io-client\":\"^2.0.4\",\"webrtc-adapter\":\"^6.1.3\",\"xmlbuilder\":\"^9.0.7\"},\"devDependencies\":{\"babel-core\":\"^6.26.0\",\"babel-loader\":\"^7.1.4\",\"babel-preset-env\":\"^1.6.1\",\"eslint\":\"^4.19.1\",\"pegjs\":\"^0.10.0\",\"pegjs-loader\":\"^0.5.4\",\"webpack\":\"^4.2.0\",\"webpack-cli\":\"^2.0.12\"},\"scripts\":{\"compile\":\"webpack --progress\"}};\n\n//# sourceURL=webpack://ApolloSIP/./package.json?");

/***/ }),

/***/ "./src/ApolloSIP.js":
/*!**************************!*\
  !*** ./src/ApolloSIP.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ApolloSIP = {\n  SIP: __webpack_require__(/*! ../lib/SIP */ \"./lib/SIP.js\"),\n  Utils: __webpack_require__(/*! ./Base/Utils */ \"./src/Base/Utils.js\"),\n  UA: __webpack_require__(/*! ./UA/UA */ \"./src/UA/UA.js\"),\n  Call: __webpack_require__(/*! ./Call/Call */ \"./src/Call/Call.js\"),\n  CallManager: __webpack_require__(/*! ./Call/CallManager */ \"./src/Call/CallManager.js\"),\n  Conference: __webpack_require__(/*! ./Conference/Conference */ \"./src/Conference/Conference.js\"),\n  ConferenceManager: __webpack_require__(/*! ./Conference/ConferenceManager */ \"./src/Conference/ConferenceManager.js\"),\n  debug: __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")\n};\n\nmodule.exports = ApolloSIP;\n\n//# sourceURL=webpack://ApolloSIP/./src/ApolloSIP.js?");

/***/ }),

/***/ "./src/Base/Debug.js":
/*!***************************!*\
  !*** ./src/Base/Debug.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ./SIP */ \"./src/Base/SIP.js\").debug;\n\n//# sourceURL=webpack://ApolloSIP/./src/Base/Debug.js?");

/***/ }),

/***/ "./src/Base/SIP.js":
/*!*************************!*\
  !*** ./src/Base/SIP.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = __webpack_require__(/*! ../../lib/SIP */ \"./lib/SIP.js\");\n\n//# sourceURL=webpack://ApolloSIP/./src/Base/SIP.js?");

/***/ }),

/***/ "./src/Base/Utils.js":
/*!***************************!*\
  !*** ./src/Base/Utils.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar toplevel = global.window || global;\nvar xmlparser = __webpack_require__(/*! fast-xml-parser */ \"./node_modules/fast-xml-parser/src/parser.js\");\nvar xmlbuilder = __webpack_require__(/*! xmlbuilder */ \"./node_modules/xmlbuilder/lib/index.js\");\nvar fecha = __webpack_require__(/*! fecha */ \"./node_modules/fecha/fecha.js\");\n\nfecha.masks.default = 'YYYY-MM-DD HH:mm:ss';\n\nexports.xmlify = function (obj) {\n  return xmlbuilder.create(obj).end();\n};\n\nexports.objectify = function (xml) {\n  return xmlparser.parse(xml, {\n    attributeNamePrefix: '@',\n    attrNodeName: false,\n    textNodeName: '#text',\n    ignoreAttributes: false,\n    ignoreNameSpace: false,\n    allowBooleanAttributes: false, // a tag can have attributes without any value\n    parseNodeValue: true,\n    parseAttributeValue: false,\n    arrayMode: false,\n    trimValues: true, // Trim string values of tag and attributes \n    decodeHTMLchar: false,\n    cdataTagName: false,\n    cdataPositionChar: '\\\\c'\n  });\n};\n\nexports.formatDate = fecha.format;\nexports.parseDate = fecha.format;\n\nexports.arrayfy = function (obj) {\n  var array = obj || [];\n\n  if (!Array.isArray(array)) {\n    array = [obj];\n  }\n\n  return array;\n};\n\nvar _defer = exports.defer = function () {\n  var deferred = {};\n\n  deferred.promise = new Promise(function (resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n\n  return deferred;\n};\n\nexports.timerDefer = function (timeout) {\n  timeout = timeout || 5000;\n\n  var defer = _defer();\n  var timer = setTimeout(function () {\n    if (defer) {\n      defer.reject('Defer timeout.');\n      defer = null;\n    }\n    clearTimeout(timer);\n    timer = null;\n  }, timeout);\n\n  return defer;\n};\n\nexports.setupEventHandlers = function (target, eventHandlers) {\n  if (!target) {\n    return;\n  }\n\n  for (var event in eventHandlers) {\n    if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {\n      target.on(event, eventHandlers[event]);\n    }\n  }\n};\nexports.removeEventHandlers = function (target, eventHandlers) {\n  if (!target) {\n    return;\n  }\n\n  for (var event in eventHandlers) {\n    if (Object.prototype.hasOwnProperty.call(eventHandlers, event)) {\n      target.removeListener(event, eventHandlers[event]);\n    }\n  }\n};\n\nvar _getPrefixedProperty = exports.getPrefixedProperty = function (object, name) {\n  if (object == null) {\n    return;\n  }\n  var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);\n  var prefixedNames = [name, 'webkit' + capitalizedName, 'moz' + capitalizedName];\n\n  for (var key in prefixedNames) {\n    if (prefixedNames.hasOwnProperty(key)) {\n      var prefixedName = prefixedNames[key];\n      var property = object[prefixedName];\n\n      if (property) {\n        return property.bind(object);\n      }\n    }\n  }\n};\n\nexports.addEventListener = _getPrefixedProperty(toplevel, 'addEventListener');\nexports.removeEventListener = _getPrefixedProperty(toplevel, 'removeEventListener');\n\nexports.isUndefined = function (obj) {\n  return obj === undefined || obj === null;\n};\n\n//# sourceURL=webpack://ApolloSIP/./src/Base/Utils.js?");

/***/ }),

/***/ "./src/Call/Call.js":
/*!**************************!*\
  !*** ./src/Call/Call.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar MediaChannel = __webpack_require__(/*! ../Channel/MediaChannel */ \"./src/Channel/MediaChannel.js\");\nvar Utils = __webpack_require__(/*! ../Base/Utils */ \"./src/Base/Utils.js\");\nvar SIP = __webpack_require__(/*! ../Base/SIP */ \"./src/Base/SIP.js\");\n\nvar debug = SIP.debug('Apollo:Call');\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(Call, _EventEmitter);\n\n  function Call() {\n    _classCallCheck(this, Call);\n\n    var _this = _possibleConstructorReturn(this, (Call.__proto__ || Object.getPrototypeOf(Call)).call(this));\n\n    _this._ua = undefined;\n    _this._session = undefined;\n    _this._target = undefined;\n\n    _this._mediaChannel = new MediaChannel();\n\n    var eventHandlers = {\n      uaChanged: function uaChanged() {\n        _this.mediaChannel.ua = _this.ua;\n      },\n      sessionChanged: function sessionChanged() {\n        _this.mediaChannel.session = _this.session;\n      },\n      targetChanged: function targetChanged() {\n        _this.mediaChannel.target = _this.target;\n      }\n    };\n\n    Utils.setupEventHandlers(_this, eventHandlers);\n    return _this;\n  }\n\n  _createClass(Call, [{\n    key: 'isAvariable',\n    value: function isAvariable() {\n      return this.ua && this.ua.isRegistered() && this.ua.get('iceServers');\n    }\n  }, {\n    key: 'connect',\n    value: function connect() {\n      this.mediaChannel.connect();\n    }\n  }, {\n    key: 'ua',\n    get: function get() {\n      return this._ua;\n    },\n    set: function set(ua) {\n      if (this._ua !== ua) {\n        this._ua = ua;\n        this.emit('uaChanged', ua);\n      }\n    }\n  }, {\n    key: 'session',\n    get: function get() {\n      return this._session;\n    },\n    set: function set(session) {\n      if (this._session !== session) {\n        this._session = session;\n        this.emit('sessionChanged', session);\n      }\n    }\n  }, {\n    key: 'target',\n    get: function get() {\n      return this._target;\n    },\n    set: function set(target) {\n      if (this._target !== target) {\n        this._target = target;\n        this.emit('targetChanged', target);\n      }\n    }\n  }, {\n    key: 'mediaChannel',\n    get: function get() {\n      return this._mediaChannel;\n    }\n  }, {\n    key: 'media',\n    get: function get() {\n      return this._mediaChannel.media;\n    }\n  }]);\n\n  return Call;\n}(EventEmitter);\n\n//# sourceURL=webpack://ApolloSIP/./src/Call/Call.js?");

/***/ }),

/***/ "./src/Call/CallManager.js":
/*!*********************************!*\
  !*** ./src/Call/CallManager.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Manager = __webpack_require__(/*! ../Manager/Manager */ \"./src/Manager/Manager.js\");\nvar Media = __webpack_require__(/*! ../Channel/Media */ \"./src/Channel/Media.js\");\nvar Call = __webpack_require__(/*! ./Call */ \"./src/Call/Call.js\");\n\nmodule.exports = function (_Manager) {\n  _inherits(CallManager, _Manager);\n\n  function CallManager() {\n    _classCallCheck(this, CallManager);\n\n    var _this = _possibleConstructorReturn(this, (CallManager.__proto__ || Object.getPrototypeOf(CallManager)).call(this));\n\n    _this._media = new Media();\n    _this._call = undefined;\n    return _this;\n  }\n\n  _createClass(CallManager, [{\n    key: 'outgoing',\n    value: function outgoing(target) {\n      var call = new Call();\n\n      call.ua = this.ua;\n      call.target = target;\n      call.media = this.media;\n\n      return call;\n    }\n  }, {\n    key: 'incoming',\n    value: function incoming(session) {\n      var call = new Call();\n\n      call.ua = this.ua;\n      call.session = session;\n      call.media = this.media;\n\n      return call;\n    }\n  }, {\n    key: 'refer',\n    value: function refer() {}\n  }, {\n    key: 'onNewRTCSession',\n    value: function onNewRTCSession(data) {\n      // incoming session\n      if (data.originator === 'remote') {\n        this.incoming(data.session);\n\n        this.emit('incoming');\n      }\n      // outgoing session\n      if (data.originator === 'local') {\n        this.emit('outgoing');\n      }\n    }\n  }, {\n    key: 'onNewMessage',\n    value: function onNewMessage(data) {\n      // incoming message\n      if (data.originator === 'remote') {\n        this.emit('incoming');\n      }\n      // outgoing message\n      if (data.originator === 'local') {\n        this.emit('outgoing');\n      }\n    }\n  }, {\n    key: 'media',\n    get: function get() {\n      return this._media;\n    }\n  }]);\n\n  return CallManager;\n}(Manager);\n\n//# sourceURL=webpack://ApolloSIP/./src/Call/CallManager.js?");

/***/ }),

/***/ "./src/Channel/Channel.js":
/*!********************************!*\
  !*** ./src/Channel/Channel.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar Error = __webpack_require__(/*! ../Error/Error */ \"./src/Error/Error.js\");\nvar Utils = __webpack_require__(/*! ../Base/Utils */ \"./src/Base/Utils.js\");\nvar SIP = __webpack_require__(/*! ../Base/SIP */ \"./src/Base/SIP.js\");\n\nvar debug = SIP.debug('Apollo:Channel');\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(Channel, _EventEmitter);\n\n  function Channel() {\n    _classCallCheck(this, Channel);\n\n    var _this = _possibleConstructorReturn(this, (Channel.__proto__ || Object.getPrototypeOf(Channel)).call(this));\n\n    _this._ua = undefined;\n    _this._target = undefined;\n    _this._session = undefined;\n    _this._options = {};\n\n    _this._conferenceId = {};\n    _this._eventHandlers = {\n      'peerconnection': _this._peerconnection.bind(_this),\n      'connecting': _this._connecting.bind(_this),\n      'sending': _this._sending.bind(_this),\n      'progress': _this._progress.bind(_this),\n      'accepted': _this._accepted.bind(_this),\n      'confirmed': _this._confirmed.bind(_this),\n      'ended': _this._ended.bind(_this),\n      'failed': _this._failed.bind(_this),\n      'newDTMF': _this._newDTMF.bind(_this),\n      'newInfo': _this._newInfo.bind(_this),\n      'hold': _this._hold.bind(_this),\n      'unhold': _this._unhold.bind(_this),\n      'muted': _this._muted.bind(_this),\n      'unmuted': _this._unmuted.bind(_this),\n      'reinvite': _this._reinvite.bind(_this),\n      'update': _this._update.bind(_this),\n      'refer': _this._refer.bind(_this),\n      'replaces': _this._replaces.bind(_this),\n      'sdp': _this._sdp.bind(_this),\n      'icecandidate': _this._icecandidate.bind(_this),\n      'getusermediafailed': _this._getusermediafailed.bind(_this),\n      'peerconnection:createofferfailed': _this._createofferfailed.bind(_this),\n      'peerconnection:createanswerfailed': _this._createanswerfailed.bind(_this),\n      'peerconnection:setlocaldescriptionfailed': _this._setlocaldescriptionfailed.bind(_this),\n      'peerconnection:setremotedescriptionfailed': _this._setremotedescriptionfailed.bind(_this)\n    };\n    return _this;\n  }\n\n  _createClass(Channel, [{\n    key: 'connect',\n    value: function connect() {\n      if (this.session) {\n        this.session.answer();\n      } else {\n        // make sure UA & Target\n        var options = Object.assign({}, this._fetchOptions(), this.options);\n\n        this.session = this.ua.call(this.target, options);\n      }\n    }\n  }, {\n    key: 'disconnect',\n    value: function disconnect() {\n      if (this.session) {\n        this.session.terminate();\n      }\n    }\n  }, {\n    key: '_fetchOptions',\n    value: function _fetchOptions() {\n      var extraHeaders = [];\n      var sessionTimersExpires = 120;\n\n      var options = {\n        mediaConstraints: null,\n        mediaStream: null,\n        pcConfig: {\n          iceServers: this._ua.get('iceServers'),\n          iceTransportPolicy: this._ua.get('iceTransportPolicy'),\n          iceCandidatePoolSize: this._ua.get('iceCandidatePoolSize')\n        },\n        rtcConstraints: {\n          optional: [{ DtlsSrtpKeyAgreement: this._ua.get('DtlsSrtpKeyAgreement') }, { googIPv6: this._ua.get('googIPv6') }]\n        },\n        rtcOfferConstraints: {\n          offerToReceiveAudio: this._ua.get('offerToReceiveAudio'),\n          offerToReceiveVideo: this._ua.get('offerToReceiveVideo')\n        },\n        rtcAnswerConstraints: {\n          offerToReceiveAudio: this._ua.get('offerToReceiveAudio'),\n          offerToReceiveVideo: this._ua.get('offerToReceiveVideo')\n        },\n        extraHeaders: extraHeaders,\n        anonymous: this._ua.get('anonymous'),\n        sessionTimersExpires: sessionTimersExpires\n      };\n\n      return options;\n    }\n  }, {\n    key: '_peerconnection',\n    value: function _peerconnection(data) {\n      debug('on peerconnection');\n\n      this.emit('peerconnection', data);\n    }\n  }, {\n    key: '_connecting',\n    value: function _connecting(data) {\n      debug('on connecting');\n\n      this.emit('connecting', data);\n    }\n  }, {\n    key: '_sending',\n    value: function _sending(data) {\n      debug('on sending');\n\n      this.emit('sending', data);\n    }\n  }, {\n    key: '_progress',\n    value: function _progress(data) {\n      debug('on progress: %s', data.originator);\n\n      this.emit('progress', data);\n    }\n  }, {\n    key: '_accepted',\n    value: function _accepted(data) {\n      debug('on accepted: %s', data.originator);\n\n      this.emit('accepted', data);\n    }\n  }, {\n    key: '_confirmed',\n    value: function _confirmed(data) {\n      debug('on confirmed: %s', data.originator);\n\n      this.emit('confirmed', data);\n    }\n  }, {\n    key: '_ended',\n    value: function _ended(data) {\n      debug('on ended: %s, cause: %s', data.originator, data.cause);\n\n      this.session = null;\n\n      this.emit('ended', new Error.FreeSwitchError(data));\n    }\n  }, {\n    key: '_failed',\n    value: function _failed(data) {\n      debug('on failed: %s, cause: %s', data.originator, data.cause);\n\n      this.session = null;\n\n      this.emit('failed', new Error.FreeSwitchError(data));\n    }\n  }, {\n    key: '_newDTMF',\n    value: function _newDTMF(data) {\n      debug('on newDTMF: %s, tone: %s, duration: %d', data.originator, data.dtmf.tone, data.dtmf.duration);\n\n      this.emit('newDTMF', data);\n    }\n  }, {\n    key: '_newInfo',\n    value: function _newInfo(data) {\n      debug('on newInfo: %s info: %o', data.originator, data.info);\n\n      var info = data.info;\n\n      if (data.originator === 'remote') {\n        switch (info.contentType) {\n          case 'application/apollo-keepalive':\n            break;\n        }\n      }\n\n      this.emit('newInfo', data);\n    }\n  }, {\n    key: '_hold',\n    value: function _hold(data) {\n      debug('on hold: %s', data.originator);\n\n      this.emit('hold', data);\n    }\n  }, {\n    key: '_unhold',\n    value: function _unhold(data) {\n      debug('on unhold: %s', data.originator);\n\n      this.emit('unhold', data);\n    }\n  }, {\n    key: '_muted',\n    value: function _muted(data) {\n      debug('on muted: audio: %s, video: %s', data.audio, data.video);\n\n      this.emit('muted', data);\n    }\n  }, {\n    key: '_unmuted',\n    value: function _unmuted(data) {\n      debug('on unmuted: audio: %s, video: %s', data.audio, data.video);\n\n      this.emit('unmuted', data);\n    }\n  }, {\n    key: '_reinvite',\n    value: function _reinvite(data) {\n      debug('on reinvite');\n\n      this.emit('reinvite', data);\n    }\n  }, {\n    key: '_update',\n    value: function _update(data) {\n      debug('on update');\n\n      this.emit('update', data);\n    }\n  }, {\n    key: '_refer',\n    value: function _refer(data) {\n      debug('on refer');\n\n      this.emit('refer', data);\n    }\n  }, {\n    key: '_replaces',\n    value: function _replaces(data) {\n      debug('on replaces');\n\n      this.emit('replaces', data);\n    }\n  }, {\n    key: '_sdp',\n    value: function _sdp(data) {\n      debug('on sdp: %s, type: %s', data.originator, data.type);\n\n      this.emit('sdp', data);\n    }\n  }, {\n    key: '_icecandidate',\n    value: function _icecandidate(data) {\n      debug('on icecandidate: %o', data.candidate);\n\n      this.emit('icecandidate', data);\n    }\n  }, {\n    key: '_getusermediafailed',\n    value: function _getusermediafailed(error) {\n      debug('on getusermediafailed: %o', error);\n\n      this.emit('getusermediafailed', error);\n    }\n  }, {\n    key: '_createofferfailed',\n    value: function _createofferfailed(error) {\n      debug('on createofferfailed: %o', error);\n\n      this.emit('createofferfailed', error);\n    }\n  }, {\n    key: '_createanswerfailed',\n    value: function _createanswerfailed(error) {\n      debug('on createanswerfailed: %o', error);\n\n      this.emit('createanswerfailed', error);\n    }\n  }, {\n    key: '_setlocaldescriptionfailed',\n    value: function _setlocaldescriptionfailed(error) {\n      debug('on setlocaldescriptionfailed: %o', error);\n\n      this.emit('setlocaldescriptionfailed', error);\n    }\n  }, {\n    key: '_setremotedescriptionfailed',\n    value: function _setremotedescriptionfailed(error) {\n      debug('on setremotedescriptionfailed: %o', error);\n\n      this.emit('setremotedescriptionfailed', error);\n    }\n  }, {\n    key: 'ua',\n    get: function get() {\n      return this._ua;\n    },\n    set: function set(ua) {\n      if (this._ua !== ua) {\n        this._ua = ua;\n        this.emit('uaChanged', ua);\n      }\n    }\n  }, {\n    key: 'target',\n    get: function get() {\n      return this._target;\n    },\n    set: function set(target) {\n      if (this._target !== target) {\n        this._target = target;\n        this.emit('targetChanged', target);\n      }\n    }\n  }, {\n    key: 'session',\n    get: function get() {\n      return this._session;\n    },\n    set: function set(session) {\n      if (this._session !== session) {\n        Utils.removeEventHandlers(this._session, this._eventHandlers);\n\n        this._session = session;\n\n        Utils.setupEventHandlers(this._session, this._eventHandlers);\n\n        this.emit('sessionChanged', session);\n      }\n    }\n  }, {\n    key: 'options',\n    get: function get() {\n      return this._options;\n    },\n    set: function set(options) {\n      if (this._options !== options) {\n        this._options = options;\n        this.emit('optionsChanged', options);\n      }\n    }\n  }]);\n\n  return Channel;\n}(EventEmitter);\n\n//# sourceURL=webpack://ApolloSIP/./src/Channel/Channel.js?");

/***/ }),

/***/ "./src/Channel/Media.js":
/*!******************************!*\
  !*** ./src/Channel/Media.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar debug = __webpack_require__(/*! ../Base/Debug */ \"./src/Base/Debug.js\")('Apollo:Media');\n\nmodule.exports = function () {\n  function Media() {\n    _classCallCheck(this, Media);\n\n    this._elements = {\n      remote: {\n        video: null,\n        audio: null\n      },\n      local: {\n        video: null,\n        audio: null\n      }\n    };\n\n    this._constraints = {\n      audio: {\n        deviceId: {\n          ideal: 'default'\n        },\n        groupId: '',\n        autoGainControl: true,\n        channelCount: 2,\n        echoCancellation: true,\n        latency: 3.0,\n        noiseSuppression: true,\n        sampleRate: 48000,\n        sampleSize: 32,\n        volume: 1.0\n      },\n      video: {\n        deviceId: {\n          ideal: 'default'\n        },\n        groupId: '',\n        aspectRatio: {\n          ideal: 16 / 9,\n          min: 4 / 3,\n          max: 16 / 9\n        },\n        facingMode: {\n          ideal: 'user' // user|environment|left|right\n        },\n        frameRate: {\n          ideal: 30,\n          min: 20,\n          max: 60\n        },\n        height: {\n          ideal: 720,\n          min: 480,\n          max: 1080\n        },\n        width: {\n          ideal: 1280,\n          min: 640,\n          max: 1920\n        }\n      }\n    };\n\n    this._stream = null;\n\n    this._remote = {\n      audio: true,\n      video: true\n    };\n  }\n\n  _createClass(Media, [{\n    key: '_setupElement',\n    value: function _setupElement(element) {\n      if (element.remote) {\n        element.autoplay = true;\n        element.onloadedmetadata = function () {\n          element.play().catch(function () {\n            debug('play was rejected.');\n          });\n        };\n      }\n    }\n  }, {\n    key: 'audioConstraints',\n    get: function get() {\n      return Object.assign({}, this._constraints.audio);\n    },\n    set: function set() {\n      var constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      debug('set audioConstraints()');\n\n      if ((typeof constraints === 'undefined' ? 'undefined' : _typeof(constraints)) === 'object') {\n        this._constraints.audio = Object.assign({}, constraints);\n      } else {\n        this._constraints.audio = constraints;\n      }\n    }\n  }, {\n    key: 'videoConstraints',\n    get: function get() {\n      return Object.assign({}, this._constraints.video);\n    },\n    set: function set() {\n      var constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      debug('set videoConstraints()');\n\n      if ((typeof constraints === 'undefined' ? 'undefined' : _typeof(constraints)) === 'object') {\n        this._constraints.video = Object.assign({}, constraints);\n      } else {\n        this._constraints.video = constraints;\n      }\n    }\n  }, {\n    key: 'constraints',\n    get: function get() {\n      return Object.assign({}, this._constraints);\n    },\n    set: function set() {\n      var constraints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._constraints = Object.assign({}, constraints);\n    }\n  }, {\n    key: 'receiveAudio',\n    get: function get() {\n      return this._remote.audio;\n    },\n    set: function set(receive) {\n      this._remote.audio = receive;\n    }\n  }, {\n    key: 'receiveVideo',\n    get: function get() {\n      return this._remote.video;\n    },\n    set: function set(receive) {\n      this._remote.video = receive;\n    }\n  }, {\n    key: 'stream',\n    get: function get() {\n      return this._stream;\n    },\n    set: function set(stream) {\n      this._stream = stream;\n    }\n  }, {\n    key: 'localElements',\n    get: function get() {\n      return Object.assign({}, this._elements.local);\n    },\n    set: function set() {\n      var local = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._elements.local = Object.assign({}, local);\n\n      if (local.audio) {\n        this._setupElement(local.audio);\n      }\n      if (local.video) {\n        local.video.muted = true;\n        this._setupElement(local.video);\n      }\n    }\n  }, {\n    key: 'remoteElements',\n    get: function get() {\n      return Object.assign({}, this._elements.remote);\n    },\n    set: function set() {\n      var remote = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._elements.remote = Object.assign({}, remote);\n\n      if (remote.audio) {\n        this._setupElement(remote.audio);\n      }\n      if (remote.video) {\n        this._setupElement(remote.video);\n      }\n    }\n  }, {\n    key: 'elements',\n    get: function get() {\n      return Object.assign({}, this._elements);\n    },\n    set: function set() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this._elements = Object.assign({}, elements);\n    }\n  }]);\n\n  return Media;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./src/Channel/Media.js?");

/***/ }),

/***/ "./src/Channel/MediaChannel.js":
/*!*************************************!*\
  !*** ./src/Channel/MediaChannel.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Channel = __webpack_require__(/*! ./Channel */ \"./src/Channel/Channel.js\");\nvar Browser = __webpack_require__(/*! bowser */ \"./node_modules/bowser/src/bowser.js\");\nvar SDPTransform = __webpack_require__(/*! sdp-transform */ \"./node_modules/sdp-transform/lib/index.js\");\nvar Utils = __webpack_require__(/*! ../Base/Utils */ \"./src/Base/Utils.js\");\nvar SIP = __webpack_require__(/*! ../Base/SIP */ \"./src/Base/SIP.js\");\nvar Media = __webpack_require__(/*! ./Media */ \"./src/Channel/Media.js\");\nvar MediaStats = __webpack_require__(/*! ./MediaStats */ \"./src/Channel/MediaStats.js\");\n\nvar debug = SIP.debug('Apollo:MediaChannel');\n\nvar TYPE = {\n  MAIN: 'main',\n  SLIDES: 'slides'\n};\n\nmodule.exports = function (_Channel) {\n  _inherits(MediaChannel, _Channel);\n\n  _createClass(MediaChannel, null, [{\n    key: 'TYPE',\n    get: function get() {\n      return TYPE;\n    }\n  }]);\n\n  function MediaChannel() {\n    _classCallCheck(this, MediaChannel);\n\n    var _this = _possibleConstructorReturn(this, (MediaChannel.__proto__ || Object.getPrototypeOf(MediaChannel)).call(this));\n\n    _this._type = TYPE.MAIN;\n    _this._focusUri = undefined;\n    _this._entity = undefined;\n    _this._media = new Media();\n    _this._stats = new MediaStats(_this);\n\n    _this._local_sdp = null;\n    _this._remote_sdp = null;\n\n    _this._local_ssrcs = [];\n    _this._remote_ssrcs = [];\n\n    _this._iceTimerOut = null;\n    return _this;\n  }\n\n  _createClass(MediaChannel, [{\n    key: 'setupLocalMedia',\n    value: function setupLocalMedia() {\n      var elements = this.media.localElements;\n      var stream = this.localStream;\n\n      if (elements.video) {\n        elements.video.srcObject = null;\n        elements.video.srcObject = stream;\n      } else if (elements.audio) {\n        elements.audio.srcObject = null;\n        elements.audio.srcObject = stream;\n      }\n    }\n  }, {\n    key: 'addLocalMedia',\n    value: function addLocalMedia(stream) {\n      var pc = this.session.connection;\n\n      if (!pc) return;\n\n      if (pc.addStream) {\n        pc.addStream(stream);\n      } else {\n        stream.getTracks().forEach(function (track) {\n          return pc.addTrack(track, stream);\n        });\n      }\n    }\n  }, {\n    key: 'removeLocalMedia',\n    value: function removeLocalMedia() {\n      var pc = this.session.connection;\n\n      if (!pc) return;\n\n      if (pc.getSenders) {\n        pc.getSenders().forEach(function (sender) {\n          if (sender.track) {\n            sender.track.stop();\n          }\n          pc.removeTrack(sender);\n        });\n      } else {\n        pc.getLocalStreams().forEach(function (stream) {\n          stream.getTracks().forEach(function (track) {\n            track.stop();\n          });\n          pc.removeStream(stream);\n        });\n      }\n    }\n  }, {\n    key: 'setupRemoteMedia',\n    value: function setupRemoteMedia() {\n      var elements = this.media.remoteElements;\n      var stream = this.remoteStream;\n\n      if (elements.video) {\n        elements.video.srcObject = stream;\n      } else if (elements.audio) {\n        elements.audio.srcObject = stream;\n      }\n    }\n  }, {\n    key: 'removeRemoteMedia',\n    value: function removeRemoteMedia() {\n      var pc = this.session.connection;\n\n      if (!pc) return;\n\n      if (pc.getReceivers) {\n        pc.getReceivers().forEach(function (sender) {\n          if (sender.track) {\n            sender.track.stop();\n          }\n          pc.removeTrack(sender);\n        });\n      } else {\n        pc.getRemoteStreams().forEach(function (stream) {\n          stream.getTracks().forEach(function (track) {\n            track.stop();\n          });\n          pc.removeStream(stream);\n        });\n      }\n    }\n  }, {\n    key: '_fetchOptions',\n    value: function _fetchOptions() {\n      var options = _get(MediaChannel.prototype.__proto__ || Object.getPrototypeOf(MediaChannel.prototype), '_fetchOptions', this).call(this);\n\n      options.mediaConstraints = this.media.constraints;\n      options.mediaStream = this.media.stream;\n\n      options.rtcOfferConstraints.offerToReceiveAudio = this.media.receiveAudio;\n      options.rtcOfferConstraints.offerToReceiveVideo = this.media.receiveVideo;\n\n      options.rtcAnswerConstraints.offerToReceiveAudio = this.media.receiveAudio;\n      options.rtcAnswerConstraints.offerToReceiveVideo = this.media.receiveAudio;\n\n      return options;\n    }\n  }, {\n    key: '_peerconnection',\n    value: function _peerconnection(data) {\n      var _this2 = this;\n\n      data.peerconnection.onconnectionstatechange = function (event) {\n        debug('peerconnection:onconnectionstatechange : %s', data.peerconnection.connectionState);\n      };\n\n      data.peerconnection.oniceconnectionstatechange = function (event) {\n        debug('peerconnection:oniceconnectionstatechange: %s', data.peerconnection.iceConnectionState);\n      };\n\n      data.peerconnection.onicegatheringstatechange = function (event) {\n        debug('peerconnection:onicegatheringstatechange: %s', data.peerconnection.iceGatheringState);\n      };\n\n      data.peerconnection.ontrack = function () {\n        debug('peerconnection:ontrack');\n        _this2.setupRemoteMedia();\n      };\n\n      data.peerconnection.onaddstream = function () {\n        debug('peerconnection:onaddstream');\n        _this2.setupRemoteMedia();\n      };\n\n      data.peerconnection.onremovestream = function () {\n        debug('peerconnection:onremovestream');\n        _this2.setupRemoteMedia();\n      };\n\n      /*\n      const datachannel = data.peerconnection.createDataChannel('chat');\n       datachannel.onerror = (error) => \n      {\n        debug('Data Channel Error: %o', error);\n      };\n       datachannel.onmessage = (event) => \n      {\n        debug('Data Channel Message: ', event.data);\n      };\n       datachannel.onopen = () => \n      {\n        debug('Data Channel Opened');\n      };\n       datachannel.onclose = () => \n      {\n        debug('Data Channel Closed');\n      };\n      */\n\n      _get(MediaChannel.prototype.__proto__ || Object.getPrototypeOf(MediaChannel.prototype), '_peerconnection', this).call(this, data);\n    }\n  }, {\n    key: '_accepted',\n    value: function _accepted(data) {\n      var response = data.response;\n\n      if (response.hasHeader('apollo-focus-uri')) {\n        var focusUri = response.getHeader('apollo-focus-uri');\n\n        this.focusUri = SIP.Grammar.parse(focusUri, 'Contact')[0].parsed.uri.toString();\n      }\n      if (response.hasHeader('Apollo-Conference-Entity')) {\n        this.entity = response.getHeader('Apollo-Conference-Entity');\n      }\n\n      this.setupLocalMedia();\n\n      _get(MediaChannel.prototype.__proto__ || Object.getPrototypeOf(MediaChannel.prototype), '_accepted', this).call(this, data);\n    }\n  }, {\n    key: '_sdp',\n    value: function _sdp(data) {\n      var sdp = SDPTransform.parse(data.sdp);\n\n      // Make sure sdp.media is an array, not the case if there is only one media.\n      if (!Array.isArray(sdp.media)) {\n        sdp.media = [sdp.media];\n      }\n\n      debug('sdp: %o', sdp);\n\n      var filter = void 0;\n\n      if (data.originator === 'local') {\n        this._local_sdp = sdp;\n        this._local_ssrcs = [];\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = sdp.media[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var m = _step.value;\n\n            if (m.type === 'video') {\n              m.content = this.type;\n            }\n\n            if (!m.ssrcs) {\n              continue;\n            }\n\n            filter = m.ssrcs.filter(function (value) {\n              return value.attribute === 'cname';\n            });\n\n            this._local_ssrcs = this._local_ssrcs.concat(filter);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      if (data.originator === 'remote') {\n        this._remote_sdp = sdp;\n        this._remote_ssrcs = [];\n\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = sdp.media[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _m = _step2.value;\n\n            if (!_m.ssrcs) {\n              continue;\n            }\n\n            filter = _m.ssrcs.filter(function (value) {\n              return value.attribute === 'cname';\n            });\n\n            this._remote_ssrcs = this._remote_ssrcs.concat(filter);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n\n      data.sdp = SDPTransform.write(sdp);\n\n      _get(MediaChannel.prototype.__proto__ || Object.getPrototypeOf(MediaChannel.prototype), '_sdp', this).call(this, data);\n    }\n  }, {\n    key: '_icecandidate',\n    value: function _icecandidate(data) {\n      // data.candidate\n      // RTCIceCandidate instance as described in the W3C specification.\n\n      // data.ready\n      // Function to be executed by the event callback if candidate is\n      // the last one to be gathered prior to retrieve the local description.\n      if (this._iceTimerOut) {\n        clearTimeout(this._iceTimerOut);\n        this._iceTimerOut = null;\n      }\n\n      this._iceTimerOut = setTimeout(function () {\n        debug('ICE gathering timeout.');\n        data.ready();\n      }, 2000);\n\n      _get(MediaChannel.prototype.__proto__ || Object.getPrototypeOf(MediaChannel.prototype), '_icecandidate', this).call(this, data);\n    }\n  }, {\n    key: '_newInfo',\n    value: function _newInfo(data) {\n      var info = data.info;\n\n      if (data.originator === 'remote') {\n        switch (info.contentType) {\n          case 'application/apollo-media-control+xml':\n            {\n              var body = Utils.objectify(info.body);\n\n              if (body && body['media_control']['yms_re_negotiation']) {\n                var media = body['media_control']['yms_re_negotiation']['media'];\n                var constraints = {};\n\n                if (!Array.isArray(media)) media = [media];\n\n                media.forEach(function (m) {\n                  if (m['@type'] === 'video') {\n                    constraints.video = {\n                      width: { exact: Number.parseInt(m['@width']) },\n                      height: { exact: Number.parseInt(m['@height']) }\n                    };\n                  }\n                });\n              }\n            }\n            break;\n          case 'application/apollo-keepalive':\n            // nothing to do\n            break;\n        }\n      }\n\n      _get(MediaChannel.prototype.__proto__ || Object.getPrototypeOf(MediaChannel.prototype), '_newInfo', this).call(this, data);\n    }\n  }, {\n    key: 'isMatchLocalSsrc',\n    value: function isMatchLocalSsrc(ssrcId) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this._local_ssrcs[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var ssrc = _step3.value;\n\n          if (ssrcId == ssrc.id) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: 'isMatchRemoteSsrc',\n    value: function isMatchRemoteSsrc(ssrcId) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this._remote_ssrcs[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var ssrc = _step4.value;\n\n          if (ssrcId == ssrc.id) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: 'type',\n    get: function get() {\n      return this._type;\n    },\n    set: function set(type) {\n      if (this._type !== type) {\n        this._type = type;\n        this.emit('typeChanged', type);\n      }\n    }\n  }, {\n    key: 'focusUri',\n    get: function get() {\n      return this._focusUri;\n    },\n    set: function set(focusUri) {\n      if (this._focusUri !== focusUri) {\n        this._focusUri = focusUri;\n        this.emit('focusUriChanged', focusUri);\n      }\n    }\n  }, {\n    key: 'entity',\n    get: function get() {\n      return this._entity;\n    },\n    set: function set(entity) {\n      if (this._entity !== entity) {\n        this._entity = entity;\n        this.emit('entityChanged', entity);\n      }\n    }\n  }, {\n    key: 'media',\n    get: function get() {\n      return this._media;\n    },\n    set: function set(media) {\n      if (this._media !== media) {\n        this._media = media;\n        this.emit('mediaChanged', media);\n      }\n    }\n  }, {\n    key: 'statistics',\n    get: function get() {\n      var _this3 = this;\n\n      if (!this._session) {\n        return null;\n      }\n\n      var pc = this.session.connection;\n\n      if (!pc) return null;\n\n      if (pc.signalingState !== 'closed') {\n        if (pc && pc.getStats) {\n          if (Browser.chrome || Browser.opera) {\n            pc.getStats(function (rawStats) {\n              _this3._stats.updateStats(rawStats.result());\n            });\n          } else if (Browser.firefox && Browser.version > 47) {\n            pc.getStats(null).then(function (rawStats) {\n              _this3._stats.updateStatsFF(rawStats);\n            });\n          }\n        }\n      }\n\n      var stats = this._stats.getStats();\n\n      calcCallQuality.call(this, stats);\n      calcAvailableBandWidth.call(this, stats);\n\n      function calcCallQuality(report) {\n        var audio_out = report.audio.send;\n        var audio_in = report.audio.recv;\n        var video_out = report.video.send;\n        var video_in = report.video.recv;\n        var hasVideoTaking = this.media.videoConstraints !== false ? true : false;\n        var totalCount = 2,\n            hasAudio = false;\n        var averagePercent = 0,\n            quality = -1;\n        var totalPercent = void 0,\n            screenPacketsLostRate = void 0;\n\n        if (!Utils.isUndefined(audio_out.packetsLostRate) && !Utils.isUndefined(audio_in.packetsLostRate)) {\n          totalPercent = parseInt(audio_out.packetsLostRate) + parseInt(audio_in.packetsLostRate);\n          hasAudio = true;\n        }\n        if (hasVideoTaking) {\n          // may be we need to determine if the camera is abnormal\n          if (!Utils.isUndefined(video_out.packetsLostRate) && !Utils.isUndefined(video_in.packetsLostRate)) {\n            totalCount += 2;\n            totalPercent += parseInt(video_out.packetsLostRate) + parseInt(video_in.packetsLostRate);\n          }\n        }\n\n        if (totalCount == 2 && hasAudio === false) {\n          // no data\n          return -1;\n        }\n        averagePercent = parseInt(totalPercent / totalCount);\n        if (averagePercent >= 12) {\n          quality = 0;\n        } else if (averagePercent >= 5) {\n          quality = 1;\n        } else if (averagePercent >= 3) {\n          quality = 2;\n        } else if (averagePercent >= 2) {\n          quality = 3;\n        } else {\n          quality = 4;\n        }\n\n        report.callQuality = quality;\n\n        return quality;\n      }\n\n      function calcAvailableBandWidth(report) {\n        var audio_out = report.audio.send;\n        var audio_in = report.audio.recv;\n        var video_out = report.video.send;\n        var video_in = report.video.recv;\n\n        if (!Utils.isUndefined(audio_out['availableBandWidth']) && !Utils.isUndefined(video_out['availableBandWidth'])) {\n          report.sendBandWidth = Math.round(audio_out['availableBandWidth'] + video_out['availableBandWidth']);\n        } else if (!Utils.isUndefined(audio_out['availableBandWidth'])) {\n          report.sendBandWidth = Math.round(audio_out['availableBandWidth']);\n        } else if (!Utils.isUndefined(video_out['availableBandWidth'])) {\n          report.sendBandWidth = Math.round(video_out['availableBandWidth']);\n        }\n\n        if (!Utils.isUndefined(audio_in['availableBandWidth']) && !Utils.isUndefined(video_in['availableBandWidth'])) {\n          report.recvBandWidth = parseFloat(audio_in['availableBandWidth']) + parseFloat(video_in['availableBandWidth']);\n        } else if (!Utils.isUndefined(audio_in['availableBandWidth'])) {\n          report.recvBandWidth = Math.round(audio_in['availableBandWidth']);\n        } else if (!Utils.isUndefined(video_in['availableBandWidth'])) {\n          report.recvBandWidth = Math.round(video_in['availableBandWidth']);\n        }\n      }\n\n      return stats;\n    }\n  }, {\n    key: 'localStream',\n    get: function get() {\n      var pc = this.session.connection;\n      var localStream = void 0;\n\n      if (!pc) return localStream;\n\n      if (pc.getLocalStreams) {\n        localStream = pc.getLocalStreams();\n\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = localStream[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var stream = _step5.value;\n\n            debug('Local streams: %o', stream);\n            stream.getTracks().forEach(function (track) {\n              return debug('Local Tracks: %o', track);\n            });\n          }\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n\n        localStream = pc.getLocalStreams()[0];\n      } else if (pc.getSenders) {\n        localStream = new global.window.MediaStream();\n        pc.getSenders().forEach(function (receiver) {\n          var track = receiver.track;\n\n          if (track) {\n            localStream.addTrack(track);\n          }\n        });\n      } else {\n        debug('No Remote streams');\n      }\n\n      return localStream;\n    }\n  }, {\n    key: 'remoteStream',\n    get: function get() {\n      var pc = this.session.connection;\n      var remoteStream = void 0;\n\n      if (!pc) return remoteStream;\n\n      if (pc.getRemoteStreams) {\n        remoteStream = pc.getRemoteStreams();\n\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = remoteStream[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var stream = _step6.value;\n\n            debug('Remote streams: %o', stream);\n            stream.getTracks().forEach(function (track) {\n              return debug('Remote Tracks: %o', track);\n            });\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n\n        remoteStream = pc.getRemoteStreams()[0];\n      } else if (pc.getReceivers) {\n        remoteStream = new global.window.MediaStream();\n        pc.getReceivers().forEach(function (receiver) {\n          var track = receiver.track;\n\n          if (track) {\n            remoteStream.addTrack(track);\n          }\n        });\n      } else {\n        debug('No Remote streams');\n      }\n\n      return remoteStream;\n    }\n  }]);\n\n  return MediaChannel;\n}(Channel);\n\n//# sourceURL=webpack://ApolloSIP/./src/Channel/MediaChannel.js?");

/***/ }),

/***/ "./src/Channel/MediaStats.js":
/*!***********************************!*\
  !*** ./src/Channel/MediaStats.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar StreamStats = function () {\n  function StreamStats() {\n    _classCallCheck(this, StreamStats);\n\n    this.lastPackets = 0;\n    this.lastLost = 0;\n    this.lastBytes = 0;\n    this.lastTimestamp = null;\n    this.recentTotal = 0;\n    this.recentLost = 0;\n    this.samples = [];\n    this.info = {};\n  }\n\n  _createClass(StreamStats, [{\n    key: 'getStats',\n    value: function getStats() {\n      return this.info;\n    }\n  }, {\n    key: 'updateBWEStats',\n    value: function updateBWEStats(result) {\n      this.info['configuredBitrate'] = (result.stat('googTargetEncBitrate') / 1000).toFixed(1);\n    }\n  }, {\n    key: 'updatePacketLossStats',\n    value: function updatePacketLossStats(currentTotal, currentLost) {\n      var self = this;\n      var sample = void 0;\n\n      if (currentTotal === 0) {\n        self.info['packetsLostRateTotal'] = null;\n      } else {\n        self.info['packetsLostRateTotal'] = ((1 - currentLost / (currentTotal + currentLost)) * 100).toFixed(0);\n      }\n\n      if (self.samples.length >= 10) {\n        sample = self.samples.shift();\n        self.recentLost -= sample[0];\n        self.recentTotal -= sample[1];\n      }\n      sample = [Math.max(currentLost - self.lastLost, 0), currentTotal - self.lastPackets];\n      self.recentLost += sample[0];\n      self.recentTotal += sample[1];\n      self.samples.push(sample);\n\n      if (self.recentTotal === 0 || self.recentLost < 0 || self.recentLost > self.recentTotal) {\n        self.info['packetsLostRate'] = null;\n      } else {\n        self.info['packetsLostRate'] = (self.recentLost / self.recentTotal * 100).toFixed(0);\n      }\n    }\n  }, {\n    key: 'updateRxStats',\n    value: function updateRxStats(result) {\n      var self = this;\n\n      self.info['packetsReceived'] = result.stat('packetsReceived');\n      self.info['packetsLost'] = result.stat('packetsLost');\n      self.info['packetsLostRateTotal'] = 0;\n      self.info['packetsLostRate'] = 0;\n      self.info['availableBandWidth'] = null;\n\n      var packetsReceived = parseInt(self.info['packetsReceived']) | 0;\n      var packetsLost = parseInt(self.info['packetsLost']) | 0;\n\n      self.updatePacketLossStats(packetsReceived, packetsLost);\n\n      if (self.lastTimestamp > 0) {\n        var kbps = Math.round((result.stat('bytesReceived') - self.lastBytes) * 8 / (result.timestamp - self.lastTimestamp));\n\n        self.info['availableBandWidth'] = kbps > 0 ? kbps : null;\n      }\n\n      if (result.stat('googFrameHeightReceived')) self.info['resolution'] = {\n        width: result.stat('googFrameWidthReceived'),\n        height: result.stat('googFrameHeightReceived')\n      };\n\n      if (result.stat('googCodecName')) self.info['codeName'] = result.stat('googCodecName');\n\n      if (result.stat('googDecodeMs')) self.info['decodeDelay'] = result.stat('googDecodeMs');\n\n      if (result.stat('googJitterBufferMs')) self.info['jitterBufferMs'] = result.stat('googJitterBufferMs');\n\n      if (result.stat('googFrameRateReceived')) self.info['frameRate'] = result.stat('googFrameRateReceived');\n\n      self.lastTimestamp = result.timestamp;\n      self.lastBytes = result.stat('bytesReceived');\n      self.lastPackets = packetsReceived;\n      self.lastLost = packetsLost;\n    }\n  }, {\n    key: 'updateTxStats',\n    value: function updateTxStats(result) {\n      var self = this;\n\n      self.info['packetsSent'] = result.stat('packetsSent');\n      self.info['packetsLost'] = result.stat('packetsLost');\n      self.info['packetsLostRateTotal'] = 0;\n      self.info['packetsLostRate'] = 0;\n      self.info['availableBandWidth'] = null;\n\n      var packetsSent = parseInt(self.info['packetsSent']) | 0;\n      var packetsLost = parseInt(self.info['packetsLost']) | 0;\n\n      self.updatePacketLossStats(packetsSent, packetsLost);\n\n      if (self.lastTimestamp > 0) {\n        var kbps = Math.round((result.stat('bytesSent') - self.lastBytes) * 8 / (result.timestamp - self.lastTimestamp));\n\n        self.info['availableBandWidth'] = kbps > 0 ? kbps : null;\n      }\n\n      if (result.stat('googFrameHeightSent')) self.info['resolution'] = {\n        width: result.stat('googFrameWidthSent'),\n        height: result.stat('googFrameHeightSent')\n      };\n\n      if (result.stat('googCodecName')) self.info['codeName'] = result.stat('googCodecName');\n\n      self.info['jitterBufferMs'] = '0';\n\n      if (result.stat('googFrameRateSent')) self.info['frameRate'] = result.stat('googFrameRateSent');\n\n      self.lastTimestamp = result.timestamp;\n      self.lastBytes = result.stat('bytesSent');\n      self.lastPackets = packetsSent;\n      self.lastLost = packetsLost;\n    }\n  }, {\n    key: 'updateRxStatsFF',\n    value: function updateRxStatsFF(result) {\n      var self = this;\n\n      self.info['packetsReceived'] = '' + result.packetsReceived; // to String\n      self.info['packetsLost'] = String(result.packetsLost); // to String\n      self.info['packetsLostRateTotal'] = 0;\n      self.info['availableBandWidth'] = null;\n\n      var packetsReceived = parseInt(self.info['packetsReceived']) | 0;\n      var packetsLost = parseInt(self.info['packetsLost']) | 0;\n\n      self.updatePacketLossStats(packetsReceived, packetsLost);\n\n      if (self.lastTimestamp > 0) {\n        var kbps = Math.round((result.bytesReceived - self.lastBytes) * 8 / (result.timestamp - self.lastTimestamp));\n\n        self.info['availableBandWidth'] = kbps > 0 ? kbps : null;\n      }\n\n      if (result.jitter) self.info['jitterBufferMs'] = result.jitter.toFixed(1);\n\n      if (result.framerateMean) self.info['frameRate'] = Math.round(result.framerateMean);\n\n      self.lastTimestamp = result.timestamp;\n      self.lastBytes = result.bytesReceived;\n      self.lastPackets = packetsReceived;\n      self.lastLost = packetsLost;\n    }\n  }, {\n    key: 'updateTxStatsFF',\n    value: function updateTxStatsFF(result) {\n      var self = this;\n\n      self.info['packetsSent'] = result.packetsSent;\n      self.info['availableBandWidth'] = null;\n      var packetsSent = parseInt(self.info['packetsSent']) | 0;\n\n      if (self.lastTimestamp > 0) {\n        var kbps = Math.round((result.bytesSent - self.lastBytes) * 8 / (result.timestamp - self.lastTimestamp));\n\n        self.info['availableBandWidth'] = kbps > 0 ? kbps : null;\n      }\n\n      self.info['jitterBufferMs'] = '0';\n\n      if (result.framerateMean) self.info['frameRate'] = Math.round(result.framerateMean);\n\n      self.lastTimestamp = result.timestamp;\n      self.lastBytes = result.bytesSent;\n    }\n  }, {\n    key: 'updateRtcpTxStatsFF',\n    value: function updateRtcpTxStatsFF(result) {\n      var self = this;\n\n      self.info['packetsLost'] = '' + result.packetsLost; // to String\n\n      var packetsSent = parseInt(self.info['packetsSent']) | 0;\n      var packetsLost = parseInt(self.info['packetsLost']) | 0;\n\n      self.updatePacketLossStats(packetsSent, packetsLost);\n      self.lastPackets = packetsSent;\n      self.lastLost = packetsLost;\n    }\n  }]);\n\n  return StreamStats;\n}();\n\nvar MediaStats = function () {\n  function MediaStats(parent) {\n    _classCallCheck(this, MediaStats);\n\n    this.parent = parent;\n    this.audio_out = new StreamStats();\n    this.audio_in = new StreamStats();\n    this.video_out = new StreamStats();\n    this.video_in = new StreamStats();\n    this.googCpuLimitedResolution = 'false';\n  }\n\n  _createClass(MediaStats, [{\n    key: 'updateStats',\n    value: function updateStats(results) {\n      var self = this;\n\n      for (var i = 0; i < results.length; ++i) {\n        if (self.statIsOfType(results[i], 'audio', 'send')) {\n          if (self.parent.isMatchLocalSsrc(results[i].stat('ssrc'))) {\n            self.audio_out.updateTxStats(results[i]);\n          }\n        } else if (self.statIsOfType(results[i], 'audio', 'recv')) {\n          if (self.parent.isMatchRemoteSsrc(results[i].stat('ssrc'))) {\n            self.audio_in.updateRxStats(results[i]);\n          }\n        } else if (self.statIsOfType(results[i], 'video', 'send')) {\n          if (self.parent.isMatchLocalSsrc(results[i].stat('ssrc'))) {\n            self.video_out.updateTxStats(results[i]);\n          }\n          self.updateGoogCpuLimitedResolution(results[i]);\n        } else if (self.statIsOfType(results[i], 'video', 'recv')) {\n          if (self.parent.isMatchRemoteSsrc(results[i].stat('ssrc'))) {\n            self.video_in.updateRxStats(results[i]);\n          }\n        } else if (self.statIsBandwidthEstimation(results[i])) {\n          self.video_out.updateBWEStats(results[i]);\n        }\n      }\n    }\n  }, {\n    key: 'updateStatsFF',\n    value: function updateStatsFF(results) {\n      var self = this;\n\n      var keys = results.keys();\n\n      for (var key_i = keys.next(); !key_i.done; key_i = keys.next()) {\n        var key = key_i.value;\n\n        if (key.indexOf('outbound_rtp_audio') === 0) {\n          self.audio_out.updateTxStatsFF(results.get(key));\n        } else if (key.indexOf('outbound_rtcp_audio') === 0) {\n          self.audio_out.updateRtcpTxStatsFF(results.get(key));\n        } else if (key.indexOf('inbound_rtp_audio') === 0) {\n          self.audio_in.updateRxStatsFF(results.get(key));\n        } else if (key.indexOf('outbound_rtp_video') === 0) {\n          self.video_out.updateTxStatsFF(results.get(key));\n        } else if (key.indexOf('outbound_rtcp_video') === 0) {\n          self.video_out.updateRtcpTxStatsFF(results.get(key));\n        } else if (key.indexOf('inbound_rtp_video') === 0) {\n          self.video_in.updateRxStatsFF(results.get(key));\n        }\n      }\n    }\n  }, {\n    key: 'statIsBandwidthEstimation',\n    value: function statIsBandwidthEstimation(result) {\n      return result.type == 'VideoBwe';\n    }\n  }, {\n    key: 'statIsOfType',\n    value: function statIsOfType(result, type, direction) {\n      return result.type == 'ssrc' && (result.stat('mediaType') == type || result.stat('transportId').indexOf(type) != -1) // Compatible with low version\n      && result.id.search(direction) != -1;\n    }\n  }, {\n    key: 'updateGoogCpuLimitedResolution',\n    value: function updateGoogCpuLimitedResolution(result) {\n      /*\n      const self = this;\n       const newLimit = result.stat('googCpuLimitedResolution');\n       if (newLimit == 'true' && newLimit != self.googCpuLimitedResolution &&\n       self.parent.chrome_ver > 55 &&\n       self.parent.h264_enabled == true) \n      {\n        self.googCpuLimitedResolution = newLimit;\n        self.parent.h264_enabled = false;\n        self.parent.renegotiate();\n      }\t\n      */\n    }\n  }, {\n    key: 'calcConnectionQuality',\n    value: function calcConnectionQuality(result) {\n      var totalCount = 2;\n      var quality = void 0;\n\n      var totalPercent = parseInt(result.audio.send.packetsLostRate) + parseInt(result.audio.recv.packetsLostRate);\n      // if (videoType === VideoType.CAMERA) {\n\n      totalCount += 2;\n      totalPercent += parseInt(result.video.send.packetsLostRate) + parseInt(result.video.recv.packetsLostRate);\n      // }\n      /* // Not currently, can use later\n          if (videoType === VideoType.DESKTOP) {\n              totalCount + 2;\n              totalPercent += result.video.send.packetsLostRate + result.video.recv.packetsLostRate;\n          }*/\n      var averagePercent = parseInt(totalPercent / totalCount);\n\n      if (averagePercent >= 12) {\n        quality = 0;\n      } else if (averagePercent >= 5) {\n        quality = 1;\n      } else if (averagePercent >= 3) {\n        quality = 2;\n      } else if (averagePercent >= 2) {\n        quality = 3;\n      } else {\n        quality = 4;\n      }\n\n      return quality;\n    }\n  }, {\n    key: 'getStats',\n    value: function getStats() {\n      var self = this;\n      var audio_out = self.audio_out.getStats();\n      var video_out = self.video_out.getStats();\n      var audio_in = self.audio_in.getStats();\n      var video_in = self.video_in.getStats();\n      var res = {\n        'audio': {\n          'send': audio_out,\n          'recv': audio_in\n        },\n        'video': {\n          'send': video_out,\n          'recv': video_in\n        }\n      };\n\n      return res;\n    }\n  }]);\n\n  return MediaStats;\n}();\n\nmodule.exports = MediaStats;\n\n//# sourceURL=webpack://ApolloSIP/./src/Channel/MediaStats.js?");

/***/ }),

/***/ "./src/Command/Command.js":
/*!********************************!*\
  !*** ./src/Command/Command.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Utils = __webpack_require__(/*! ../Base/Utils */ \"./src/Base/Utils.js\");\n\nvar VERSION = '1';\n\nmodule.exports = function () {\n  function COMMAND() {\n    _classCallCheck(this, COMMAND);\n  }\n\n  _createClass(COMMAND, null, [{\n    key: 'Make',\n    value: function Make(from, to, requestId, body) {\n      var request = {\n        '@version': VERSION,\n        '@from': from,\n        '@to': to,\n        '@requestId': requestId\n      };\n\n      Object.assign(request, body);\n\n      var obj = {\n        'request': request\n      };\n\n      return Utils.xmlify(obj);\n    }\n  }, {\n    key: 'Parse',\n    value: function Parse(xml) {\n      var obj = Utils.objectify(xml);\n\n      if (obj) {\n        var response = obj['response'];\n        var responseVersion = response['@version'];\n\n        if (responseVersion == VERSION) {\n          return response;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: 'Version',\n    get: function get() {\n      return VERSION;\n    }\n  }]);\n\n  return COMMAND;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./src/Command/Command.js?");

/***/ }),

/***/ "./src/Conference/Conference.js":
/*!**************************************!*\
  !*** ./src/Conference/Conference.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar Command = __webpack_require__(/*! ../Command/Command */ \"./src/Command/Command.js\");\nvar Information = __webpack_require__(/*! ./Info/Information */ \"./src/Conference/Info/Information.js\");\nvar Description = __webpack_require__(/*! ./Info/Description */ \"./src/Conference/Info/Description.js\");\nvar Error = __webpack_require__(/*! ../Error/Error */ \"./src/Error/Error.js\");\nvar Channel = __webpack_require__(/*! ../Channel/Channel */ \"./src/Channel/Channel.js\");\nvar MediaChannel = __webpack_require__(/*! ../Channel/MediaChannel */ \"./src/Channel/MediaChannel.js\");\nvar Utils = __webpack_require__(/*! ../Base/Utils */ \"./src/Base/Utils.js\");\nvar SIP = __webpack_require__(/*! ../Base/SIP */ \"./src/Base/SIP.js\");\n\nvar debug = SIP.debug('Apollo:Conference');\n\nvar C = {\n  GET_CONFERENCE: 'getConference',\n  GET_BOOK_CONFERENCE_TEMPLATE: 'getBookConferenceTemplate',\n  MODIFY_CONFERENCE: 'modifyConference',\n  MODIFY_CONFERNCE_LOCK: 'modifyConferenceLock',\n  ADD_USER: 'addUser',\n  DELETE_USER: 'deleteUser',\n  MODIFY_USER_ROLES: 'modifyUserRoles',\n  MODIFY_ENDPOINT_MEDIA: 'modifyEndpointMedia',\n  MODIFY_ENDPOINT_MEDIA_BATCH: 'modifyEndpointMediaBatch,',\n  SET_LOBBY_ACCESS: 'setLobbyAccess',\n  SET_DEMONSTRATOR: 'setDemonstrator',\n  SET_TITLE: 'setTitle',\n  CANCEL_TITLE: 'cancelTitle',\n  ADD_RTMP_USER_BATCH: 'addRtmpUserBatch',\n  MODIFY_RTMP_ENDPOINT_MEDIA: 'modifyRtmpEpMedia',\n  HOLD_RTMP_USER: 'holdRtmpUser',\n  RESUME_RTMP_USER: 'resumeRtmpUser',\n\n  LobbyAccess: {\n    GRANTED: 'granted',\n    DENIED: 'denied'\n  },\n  UserRole: {\n    OGANIZER: 'organizer',\n    ATTENDEE: 'attendee',\n    PRESENTER: 'presenter'\n  },\n  DemoSTATUS: {\n    ON: 'OnDemo',\n    OFF: 'OffDemo'\n  },\n  Layout: {\n    EQUALITY: 'Equality',\n    SPEECH_EXCITATION: 'SpeechExcitation',\n    EXCLUSIVE: 'Exclusive'\n  },\n  AdmissionPolicy: {\n    CLOSE: 'closedAuthenticated',\n    OPEN: 'openAuthenticated',\n    ANONYMOUS: 'anonymous'\n  }\n};\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(Conference, _EventEmitter);\n\n  _createClass(Conference, null, [{\n    key: 'parseInformation',\n    value: function parseInformation(xml) {\n      var information = new Information();\n\n      information.update(xml);\n\n      return information;\n    }\n  }]);\n\n  function Conference() {\n    _classCallCheck(this, Conference);\n\n    var _this = _possibleConstructorReturn(this, (Conference.__proto__ || Object.getPrototypeOf(Conference)).call(this));\n\n    _this._ua = undefined;\n    _this._number = undefined;\n    _this._pin = undefined;\n    _this._from = undefined;\n    _this._error = undefined;\n\n    _this._entity = undefined;\n\n    _this._information = new Information(_this);\n\n    _this._focusChannel = new Channel();\n    _this._mediaChannel = new MediaChannel();\n    _this._shareChannel = new MediaChannel();\n\n    _this._mediaChannel.type = MediaChannel.TYPE.MAIN;\n    _this._shareChannel.type = MediaChannel.TYPE.SLIDES;\n\n    _this._subscription = undefined;\n\n    _this.on('uaChanged', function (ua) {\n      _this.from = ua.get('uri').toString();\n      _this.focusChannel.ua = ua;\n      _this.mediaChannel.ua = ua;\n      _this.shareChannel.ua = ua;\n    });\n\n    var focusHandlers = {\n      'accepted': _this.onAccepted.bind(_this),\n      'ended': _this.onEnded.bind(_this),\n      'failed': _this.onFailed.bind(_this)\n    };\n    var mediaHandlers = {};\n    var shareHandlers = {};\n\n    Utils.setupEventHandlers(_this.focusChannel, focusHandlers);\n    return _this;\n  }\n\n  _createClass(Conference, [{\n    key: 'isAvariable',\n    value: function isAvariable() {\n      return this.ua && this.ua.isRegistered();\n    }\n  }, {\n    key: 'isEstablished',\n    value: function isEstablished() {\n      return this.focusChannel.session && this.focusChannel.session.isEstablished();\n    }\n  }, {\n    key: 'dialIn',\n    value: function dialIn() {\n      var _this2 = this;\n\n      debug('dialIn()');\n\n      var target = this.number + '**' + this.pin;\n\n      this._redirect(target).catch(function (error) {\n        debug('redirect error: %s', error.cause);\n        error.originator = 'redirect';\n        _this2.onFailed(error);\n        throw error;\n      }).then(function (targets) {\n        _this2.mediaChannel.target = targets[0];\n        _this2.mediaChannel.connect();\n\n        var listeners = {\n          'confirmed': function confirmed() {\n            Utils.removeEventHandlers(_this2.mediaChannel, listeners);\n            _this2.entity = _this2.mediaChannel.entity;\n            _this2.focusChannel.target = _this2.mediaChannel.focusUri;\n            _this2.connect();\n          },\n          'failed': function failed(error) {\n            Utils.removeEventHandlers(_this2.mediaChannel, listeners);\n            _this2.onFailed(error);\n          }\n        };\n\n        Utils.setupEventHandlers(_this2.mediaChannel, listeners);\n\n        return Promise.resolve();\n      }).catch(function () {});\n    }\n  }, {\n    key: 'connect',\n    value: function connect() {\n      debug('connect()');\n\n      var requestId = SIP.Utils.createRandomToken(10, 10);\n      var body = {};\n\n      body[C.ADD_USER] = {\n        'conferenceKeys': {\n          '@confEntity': this.entity\n        },\n        'user': {\n          '@requestUri': this.from\n        }\n      };\n\n      var xml = Command.Make(this.from, this.entity, requestId, body);\n\n      var options = {\n        contentType: 'application/conference-ctrl+xml',\n        body: xml,\n        withoutSDP: true\n      };\n\n      this.focusChannel.options = options;\n      this.focusChannel.connect();\n\n      this.emit('connecting');\n    }\n  }, {\n    key: 'disconnect',\n    value: function disconnect() {\n      this.focusChannel.disconnect();\n      this.mediaChannel.disconnect();\n      this.shareChannel.disconnect();\n      // reset error\n      this._error = null;\n    }\n  }, {\n    key: 'parseInformation',\n    value: function parseInformation(xml) {\n      return Conference.parseInformation(xml);\n    }\n  }, {\n    key: 'getConference',\n    value: function getConference() {\n      var body = {};\n\n      body[C.GET_CONFERENCE] = {\n        'conferenceKeys': {\n          '@confEntity': this.entity\n        }\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'getConferenceTemplate',\n    value: function getConferenceTemplate() {\n      var body = {};\n\n      body[C.GET_BOOK_CONFERENCE_TEMPLATE] = {\n        'conference-info': {\n          '@entity': this.entity\n        }\n      };\n\n      return this._deferSend(body);\n    }\n\n    // modify conference layout\n\n  }, {\n    key: 'modifyConference',\n    value: function modifyConference(layout) {\n      var conferenceInfo = {\n        '@entity': this.entity,\n        '@state': 'partial',\n        'conference-view': {\n          'entity-view': {\n            '@entity': this.mediaChannel.target,\n            '@state': 'partial',\n            'entity-state': {\n              'video-layout': layout,\n              'video-max-view': 5\n            }\n          }\n        }\n      };\n\n      var body = {};\n\n      body[C.GET_CONFERENCE_STATISTICS] = {\n        'conference-info': conferenceInfo\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'modifyConferenceLock',\n    value: function modifyConferenceLock(lock, admissionPolicy) {\n      var body = {};\n\n      body[C.GET_CONFERENCE_STATISTICS] = {\n        'conferenceKeys': {\n          '@confEntity': this.entity\n        },\n        'locked': lock,\n        'admission-policy': admissionPolicy\n      };\n\n      this._deferSend(body);\n    }\n  }, {\n    key: 'addUser',\n    value: function addUser(uri) {\n      var body = {};\n      var user = [];\n\n      if (Array.isArray(uri)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = uri[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var value = _step.value;\n\n            user.push({\n              '@requestUri': value\n            });\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        user.push({\n          '@requestUri': uri\n        });\n      }\n\n      body[C.ADD_USER] = {\n        'conferenceKeys': {\n          '@confEntity': this.entity\n        },\n        'user': user\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'deleteUser',\n    value: function deleteUser(entity) {\n      var body = {};\n\n      body[C.DELETE_USER] = {\n        'userKeys': {\n          '@confEntity': this.entity,\n          '@userEntity': entity\n        }\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'modifyUserRole',\n    value: function modifyUserRole(entity, role) {\n      var body = {};\n\n      body[C.MODIFY_USER_ROLES] = {\n        'userKeys': {\n          '@confEntity': this.entity,\n          '@userEntity': entity\n        },\n        'user-roles': {\n          'entry': role\n        }\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'modifyEndpointMedia',\n    value: function modifyEndpointMedia(entity, enable) {\n      var body = {};\n\n      var user = this.users.getUser(this.from);\n\n      if (!user) {\n        throw new Error('Missing User');\n      }\n\n      var endpoint = user['endpoint'];\n\n      if (!endpoint) {\n        throw new Error('Missing Endpoint');\n      }\n\n      endpoint = Utils.arrayfy(endpoint);\n\n      var avEndpoint = endpoint.find(function (e) {\n        return e['@session-type'] == 'audio-video';\n      });\n\n      if (!avEndpoint) {\n        throw new Error('Missing AV Endpoint');\n      }\n\n      var media = avEndpoint['media'];\n\n      if (!media) {\n        throw new Error('Missing Media');\n      }\n\n      media = Utils.arrayfy(media);\n\n      var audio = media.find(function (m) {\n        return m['type'] == 'audio';\n      });\n\n      var video = media.find(function (m) {\n        return m['type'] == 'video';\n      });\n\n      body[C.MODIFY_ENDPOINT_MEDIA] = {\n        '@mcuUri': this.mediaChannel.target,\n        'mediaKeys': {\n          '@confEntity': this.entity,\n          '@userEntity': entity,\n          '@endpointEntity': avEndpoint['@entity'],\n          '@mediaId': audio['@id']\n        },\n        'media': {\n          '@id': audio['@id'],\n          'type': audio['type'],\n          'status': enable ? 'sendrecv' : 'recvonly',\n          'media-ingress-filter': enable ? 'unblock' : 'block'\n        }\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'modifyEndpointMediaBatch',\n    value: function modifyEndpointMediaBatch(entityArray, options) {}\n  }, {\n    key: 'setLobbyAccess',\n    value: function setLobbyAccess(entity, enable) {\n      var body = {};\n      var userEntity = [];\n\n      if (!Array.isArray(entity)) {\n        entity = [entity];\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = entity[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var value = _step2.value;\n\n          userEntity.push({\n            '#text': value\n          });\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      body[C.SET_LOBBY_ACCESS] = {\n        'conferenceKeys': {\n          '@confEntity': this.entity\n        },\n        'userEntity': userEntity,\n        'access': enable ? C.LobbyAccess.GRANTED : C.LobbyAccess.DENIED\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'setDemonstrator',\n    value: function setDemonstrator(entity, enable) {\n      var body = {};\n      var userEntity = [];\n\n      if (Array.isArray(entity)) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = entity[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var value = _step3.value;\n\n            userEntity.push({\n              '#text': value\n            });\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      } else {\n        userEntity.push({\n          '#text': entity\n        });\n      }\n\n      body[C.SET_LOBBY_ACCESS] = {\n        'conferenceKeys': {\n          '@confEntity': this.entity\n        },\n        'userEntity': userEntity,\n        'demoState': enable ? C.DemoState.ON : C.DemoState.OFF\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'setTitle',\n    value: function setTitle(title) {\n      var skeleton = {\n        type: 'Static', // Static|Dynamic\n        repeatCount: 3,\n        repeatInterval: 5,\n        displayTime: 5,\n        displayText: 'title',\n        position: 'top', // top|medium|bottom\n        rollDirection: 'R2L' // R2L|L2R\n      };\n\n      for (var attr in title) {\n        if (title[attr] !== undefined) {\n          skeleton[attr] = title[attr];\n        }\n      }\n\n      var body = {};\n\n      body[C.SET_TITLE] = title;\n\n      Object.assign(body[C.SET_TITLE], {\n        'conferenceKeys': {\n          '@confEntity': this.entity\n        }\n      });\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'cancelTitle',\n    value: function cancelTitle() {\n      var body = {};\n\n      body[C.CANCEL_TITLE] = {};\n\n      Object.assign(body[C.SET_TITLE], {\n        'conferenceKeys': {\n          '@confEntity': this.entity\n        }\n      });\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'addRtmpUserBatch',\n    value: function addRtmpUserBatch() {\n      var rtmpUser = [];\n      var body = {};\n\n      body[C.ADD_RTMP_USER_BATCH] = {};\n\n      Object.assign(body[C.ADD_RTMP_USER_BATCH], {\n        'conferenceKeys': {\n          '@confEntity': this.entity\n        },\n        'rtmp-user': rtmpUser\n      });\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'modifyRtmpEndpointMedia',\n    value: function modifyRtmpEndpointMedia(entity, endpoint) {\n      var body = {};\n\n      body[C.MODIFY_RTMP_ENDPOINT_MEDIA] = {};\n\n      Object.assign(body[C.MODIFY_RTMP_ENDPOINT_MEDIA], {\n        'userKeys': {\n          '@confEntity': this.entity,\n          '@userEntity': entity\n        },\n        'endpoint': endpoint\n      });\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'holdRtmpUser',\n    value: function holdRtmpUser(entity) {\n      var body = {};\n\n      body[C.HOLD_RTMP_USER] = {};\n\n      Object.assign(body[C.HOLD_RTMP_USER], {\n        'userKeys': {\n          '@confEntity': this.entity,\n          '@userEntity': entity\n        }\n      });\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'resumeRtmpUser',\n    value: function resumeRtmpUser(entity) {\n      var body = {};\n\n      body[C.RESUME_RTMP_USER] = {};\n\n      Object.assign(body[C.RESUME_RTMP_USER], {\n        'userKeys': {\n          '@confEntity': this.entity,\n          '@userEntity': entity\n        }\n      });\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'onAccepted',\n    value: function onAccepted(data) {\n      var response = data.response;\n\n      if (!response.body) {\n        data.cause = 'Missing Body';\n        this.onFailed(data);\n        this.disconnect();\n\n        return;\n      }\n\n      response = Command.Parse(response.body);\n\n      if (!response) {\n        data.cause = 'Parse Response Failed';\n        this.onFailed(data);\n        this.disconnect();\n\n        return;\n      }\n\n      debug('focus response: %o', response);\n\n      this.from = response[C.ADD_USER]['user']['@entity'];\n\n      this._subscribe();\n\n      this.emit('connected');\n    }\n  }, {\n    key: 'onEnded',\n    value: function onEnded(data) {\n      if (this._subscription) {\n        this._subscription.terminate();\n      }\n\n      this.information.clear();\n\n      this.emit('disconnected', data);\n    }\n  }, {\n    key: 'onFailed',\n    value: function onFailed(data) {\n      this.error = data;\n\n      this.emit('connectFailed', data);\n    }\n  }, {\n    key: 'onNotify',\n    value: function onNotify(data) {\n      this.information.update(data.notify);\n      this.emit('informationUpdated', this.information);\n    }\n  }, {\n    key: '_descriptionUpdated',\n    value: function _descriptionUpdated() {\n      var uris = this.description.confUris;\n\n      uris = Utils.arrayfy(uris['entry']);\n\n      uris.forEach(function (entry) {\n        var purpose = entry.purpose,\n            uri = entry.uri;\n\n\n        debug('%s uri: %s', purpose, uri);\n\n        switch (purpose) {\n          case 'focus':\n            this.focusChannel.target = uri;\n            break;\n          case 'audio-video':\n            this.mediaChannel.target = uri;\n            break;\n          case 'applicationsharing':\n            this.shareChannel.target = uri;\n            break;\n        }\n      }, this);\n\n      this.emit('descriptionUpdated', this.description);\n    }\n  }, {\n    key: '_stateUpdated',\n    value: function _stateUpdated() {\n      this.emit('stateUpdated', this.state);\n    }\n  }, {\n    key: '_viewUpdated',\n    value: function _viewUpdated() {\n      this.emit('viewUpdated', this.view);\n    }\n  }, {\n    key: '_usersUpdated',\n    value: function _usersUpdated() {\n      this.emit('usersUpdated', this.users);\n    }\n  }, {\n    key: '_userUpdated',\n    value: function _userUpdated(user) {\n      this.emit('userUpdated', user);\n    }\n  }, {\n    key: '_userAdded',\n    value: function _userAdded(user) {\n      this.emit('userAdded', user);\n    }\n  }, {\n    key: '_userDeleted',\n    value: function _userDeleted(user) {\n      this.emit('userDeleted', user);\n    }\n  }, {\n    key: '_redirect',\n    value: function _redirect(target) {\n      debug('redirect()');\n\n      var defer = Utils.defer();\n\n      var session = this.ua.call(target, { withoutSDP: true });\n\n      session.once('failed', function (data) {\n        debug('Invite failed. cause: %s', data.cause);\n\n        var message = data.message;\n\n        if (!message) {\n          defer.reject(new Error.FreeSwitchError(data));\n\n          return;\n        }\n\n        switch (true) {\n          case /^30[1-2]$/.test(message.status_code):\n            {\n              var contacts = message.getHeaders('contact').length;\n              var contact = {};\n              var targets = [];\n\n              while (contacts--) {\n                contact = message.parseHeader('contact', contacts);\n                targets.push(contact.uri.toString());\n              }\n\n              debug('get conference uris: %o', targets);\n\n              // should have a least one contactUri.\n              if (targets.length) {\n                defer.resolve(targets);\n              } else {\n                data.cause = SIP.C.causes.NOT_FOUND;\n                defer.reject(new Error.FreeSwitchError(data));\n              }\n            }\n            break;\n          case /^480$/.test(message.status_code):\n            {\n              var info = Utils.objectify(message.body)['conference-info'];\n              var description = new Description();\n              var error = new Error.FreeSwitchError(data);\n\n              description.update(info['conference-description'], true);\n              error.code = message.status_code;\n              error.description = description;\n              defer.reject(error);\n            }\n            break;\n          default:\n            defer.reject(new Error.FreeSwitchError(data));\n            break;\n        }\n\n        session = null;\n      });\n\n      return defer.promise;\n    }\n  }, {\n    key: '_subscribe',\n    value: function _subscribe() {\n      var _this3 = this;\n\n      var event = 'conference';\n      var expires = 3600;\n      var extraHeaders = ['Accept: application/conference-info+xml'];\n\n      this._subscription = this._ua.subscribe(this.focusChannel.target, event, {\n        expires: expires,\n        extraHeaders: extraHeaders,\n        eventHandlers: {\n          progress: function progress() {\n            debug('subscription progress.');\n          },\n          successed: function successed() {\n            debug('subscription successed.');\n          },\n          failed: function failed(data) {\n            debug('subscription failed. %s', data.cause);\n          },\n          notify: function notify(data) {\n            _this3.onNotify(data);\n          }\n        }\n      });\n    }\n  }, {\n    key: '_deferSend',\n    value: function _deferSend(body) {\n      var defer = Utils.defer();\n      var requestId = SIP.Utils.createRandomToken(10, 10);\n      var xml = Command.Make(this.from, this.entity, requestId, body);\n      var options = {\n        eventHandlers: {\n          succeeded: function succeeded(data) {\n            debug('info succeeded: %s', data.originator);\n\n            var response = Command.Parse(data.response.body);\n\n            if (!response) {\n              data.cause = 'Missing Content';\n              defer.reject(data);\n\n              return;\n            }\n\n            for (var attr in response) {\n              if (!/^@/.test(attr)) {\n                debug('info command: %s', attr);\n                debug('info result: %o', response[attr]);\n                defer.resolve(response[attr]);\n              }\n            }\n          },\n          failed: function failed(data) {\n            data.cause = SIP.C.causes.SIP_FAILURE_CODE;\n            defer.reject(data);\n          }\n        }\n      };\n      var contentType = 'application/conference-ctrl+xml';\n\n      this.focusChannel.session.sendInfo(contentType, xml, options);\n\n      return defer.promise;\n    }\n  }, {\n    key: 'ua',\n    get: function get() {\n      return this._ua;\n    },\n    set: function set(ua) {\n      if (this._ua !== ua) {\n        this._ua = ua;\n        this.emit('uaChanged', ua);\n      }\n    }\n  }, {\n    key: 'number',\n    get: function get() {\n      return this._number;\n    },\n    set: function set(number) {\n      if (this._number !== number) {\n        this._number = number;\n        this.emit('numberChanged', number);\n      }\n    }\n  }, {\n    key: 'pin',\n    get: function get() {\n      return this._pin;\n    },\n    set: function set(pin) {\n      if (this._pin !== pin) {\n        this._pin = pin;\n        this.emit('pinChanged', pin);\n      }\n    }\n  }, {\n    key: 'from',\n    get: function get() {\n      return this._from;\n    },\n    set: function set(from) {\n      if (this._from !== from) {\n        this._from = from;\n        this.emit('fromChanged', from);\n      }\n    }\n  }, {\n    key: 'entity',\n    get: function get() {\n      return this._entity;\n    },\n    set: function set(entity) {\n      if (this._entity !== entity) {\n        this._entity = entity;\n        this.emit('entityChanged', entity);\n      }\n    }\n  }, {\n    key: 'information',\n    get: function get() {\n      return this._information;\n    }\n  }, {\n    key: 'description',\n    get: function get() {\n      return this.information.description;\n    }\n  }, {\n    key: 'state',\n    get: function get() {\n      return this.information.state;\n    }\n  }, {\n    key: 'view',\n    get: function get() {\n      return this.information.view;\n    }\n  }, {\n    key: 'users',\n    get: function get() {\n      return this.information.users;\n    }\n  }, {\n    key: 'statistics',\n    get: function get() {\n      var report = this.mediaChannel.statistics;\n\n      if (report) {\n        if (this.shareChannel.statistics) {\n          report.screen = this.shareChannel.statistics.video;\n        }\n\n        if (report.screen) {\n          report.screen.sender = report.screen.send.packetsSent ? true : false;\n        }\n      }\n\n      return report;\n    }\n  }, {\n    key: 'error',\n    get: function get() {\n      return this._error;\n    },\n    set: function set(error) {\n      if (this._error !== error) {\n        this._error = error;\n        this.emit('errorChanged', error);\n      }\n    }\n  }, {\n    key: 'focusChannel',\n    get: function get() {\n      return this._focusChannel;\n    }\n  }, {\n    key: 'mediaChannel',\n    get: function get() {\n      return this._mediaChannel;\n    }\n  }, {\n    key: 'shareChannel',\n    get: function get() {\n      return this._shareChannel;\n    }\n  }, {\n    key: 'media',\n    get: function get() {\n      return this._mediaChannel.media;\n    }\n  }]);\n\n  return Conference;\n}(EventEmitter);\n\n//# sourceURL=webpack://ApolloSIP/./src/Conference/Conference.js?");

/***/ }),

/***/ "./src/Conference/ConferenceManager.js":
/*!*********************************************!*\
  !*** ./src/Conference/ConferenceManager.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Manager = __webpack_require__(/*! ../Manager/Manager */ \"./src/Manager/Manager.js\");\nvar Conference = __webpack_require__(/*! ./Conference */ \"./src/Conference/Conference.js\");\nvar Command = __webpack_require__(/*! ../Command/Command */ \"./src/Command/Command.js\");\nvar Utils = __webpack_require__(/*! ../Base/Utils */ \"./src/Base/Utils.js\");\nvar SIP = __webpack_require__(/*! ../Base/SIP */ \"./src/Base/SIP.js\");\nvar debug = SIP.debug('Apollo:ConferenceManager');\n\nvar C = {\n  ADD_CONFERENCE: 'addConference',\n  DELETE_CONFERENCE: 'deleteConference',\n  ADD_VMR: 'addVMR',\n  BOOK_CONFERENCE: 'bookConference',\n  GET_CONFERENCE: 'getConference',\n  GET_CONFERENCE_BY_NUM: 'getConferenceByConfNumber',\n  GET_CONFERENCE_STATISTICS: 'getConferencesStatistics',\n  GET_BOOK_CONFERENCE_SCHEDULE: 'getBookConferenceSchedule',\n  GET_BOOK_CONFERENCE_POINT_RUNNING: 'getBookConferencePointRunning',\n  GET_BOOK_CONFERENCE_TEMPLATE: 'getBookConferenceTemplate'\n};\n\nmodule.exports = function (_Manager) {\n  _inherits(ConferenceManager, _Manager);\n\n  function ConferenceManager() {\n    _classCallCheck(this, ConferenceManager);\n\n    var _this = _possibleConstructorReturn(this, (ConferenceManager.__proto__ || Object.getPrototypeOf(ConferenceManager)).call(this));\n\n    _this._from = undefined;\n    _this._factoryUri = undefined;\n\n    _this.on('uaChanged', function (ua) {\n      _this.from = ua.get('uri');\n      _this.factoryUri = ua.get('conferenceFactoryUri');\n    });\n    return _this;\n  }\n\n  _createClass(ConferenceManager, [{\n    key: 'isAvariable',\n    value: function isAvariable() {\n      return _get(ConferenceManager.prototype.__proto__ || Object.getPrototypeOf(ConferenceManager.prototype), 'isAvariable', this).call(this) && (this.factoryUri ? true : false);\n    }\n  }, {\n    key: 'createConference',\n    value: function createConference(conferenceInfo) {\n      var _this2 = this;\n\n      return this.addConference(conferenceInfo).catch(function (e) {\n        debug('add conference failed. error: %o', e);\n        throw e;\n      }).then(function (xml) {\n        var conference = new Conference();\n        var information = Conference.parseInformation(xml);\n\n        conference.ua = _this2.ua;\n        conference.entity = information.entity;\n\n        var uris = information.description.confUris;\n\n        uris = Utils.arrayfy(uris['entry']);\n\n        uris.forEach(function (entry) {\n          var purpose = entry.purpose,\n              uri = entry.uri;\n\n\n          switch (purpose) {\n            case 'focus':\n              conference.focusChannel.target = uri;\n              break;\n            case 'audio-video':\n              conference.mediaChannel.target = uri;\n              break;\n            case 'applicationsharing':\n              conference.shareChannel.target = uri;\n              break;\n          }\n        });\n\n        return Promise.resolve(conference);\n      });\n    }\n  }, {\n    key: 'addConference',\n    value: function addConference(conferenceInfo) {\n      var body = {};\n      var defaultInfo = {\n        '@entity': '',\n        'conference-description': {\n          'organizer': {\n            'username': this.from._user,\n            'realm': this.from._host\n          },\n          'subject': 'Conference',\n          'profile': 'default' // default | demonstrator\n        },\n        'conference-view': {\n          'entity-view ': [{ '@entity': 'audio-video' }, { '@entity': 'chat' }, { '@entity': 'applicationsharing' }]\n        }\n      };\n\n      conferenceInfo = conferenceInfo || defaultInfo;\n\n      body[C.ADD_CONFERENCE] = {\n        'conference-info': conferenceInfo\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'deleteConference',\n    value: function deleteConference(conferenceEntity) {\n      var body = {};\n\n      body[C.DELETE_CONFERENCE] = {\n        'conferenceKeys': {\n          '@entity': conferenceEntity\n        }\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'addVMR',\n    value: function addVMR(conferenceInfo) {\n      var body = {};\n\n      body[C.ADD_VMR] = {\n        'conference-info': conferenceInfo\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'getConferenceStatistics',\n    value: function getConferenceStatistics() {\n      var body = {};\n\n      body[C.GET_CONFERENCE_STATISTICS] = {};\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'getConferenceByNumber',\n    value: function getConferenceByNumber(conferenceNumber) {\n      var body = {};\n\n      body[C.GET_CONFERENCE_BY_NUM] = {\n        'conferenceKeys': {\n          '@confNumber': conferenceNumber\n        }\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'bookConference',\n    value: function bookConference(conferenceInfo) {\n      var body = {};\n\n      body[C.BOOK_CONFERENCE] = {\n        'conference-info': conferenceInfo\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'cancelConference',\n    value: function cancelConference(conferenceEntity) {\n      var body = {};\n\n      body[C.BOOK_CONFERENCE] = {\n        'conference-info': {\n          '@entity': conferenceEntity,\n          '@state': 'deleted'\n        }\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'getConferenceSchedule',\n    value: function getConferenceSchedule(startDateTime, endDateTime) {\n      var body = {};\n\n      body[C.GET_BOOK_CONFERENCE_SCHEDULE] = {\n        'startDateTime': Utils.formatDate(startDateTime),\n        'endDateTime': Utils.formatDate(endDateTime)\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'getRunningConference',\n    value: function getRunningConference(dateTime) {\n      dateTime = dateTime || new Date();\n\n      var body = {};\n\n      body[C.GET_BOOK_CONFERENCE_POINT_RUNNING] = {\n        'DateTime': Utils.formatDate(dateTime)\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: 'getConferenceTemplate',\n    value: function getConferenceTemplate(conferenceEntity) {\n      if (!conferenceEntity || conferenceEntity === '') {\n        return Promise.reject('Conference entity is required.');\n      }\n      var body = {};\n\n      body[C.GET_BOOK_CONFERENCE_TEMPLATE] = {\n        'conference-info': {\n          '@entity': conferenceEntity\n        }\n      };\n\n      return this._deferSend(body);\n    }\n  }, {\n    key: '_deferSend',\n    value: function _deferSend(body) {\n      var defer = Utils.defer();\n      var requestId = SIP.Utils.createRandomToken(10, 10);\n      var from = this.from._host + '\\\\' + this.from._user;\n      var to = this.factoryUri;\n      var xml = Command.Make(from, to, requestId, body);\n      var event = 'conference';\n      var contentType = 'application/conference-ctrl+xml';\n      var options = {\n        contentType: contentType,\n        eventHandlers: {\n          'succeeded': function succeeded(data) {\n            debug('service succeeded: %s', data.originator);\n\n            var response = Command.Parse(data.response.body);\n\n            if (!response) {\n              data.cause = 'Missing Content';\n              defer.reject(data);\n\n              return;\n            }\n\n            for (var attr in response) {\n              if (!/^@/.test(attr)) {\n                debug('service command: %s', attr);\n                debug('service result: %o', response[attr]);\n                defer.resolve(response[attr]);\n              }\n            }\n          },\n          'failed': function failed(data) {\n            defer.reject(data);\n          }\n        }\n      };\n\n      this.ua.sendService(this.factoryUri, event, xml, options);\n\n      return defer.promise;\n    }\n  }, {\n    key: 'onConferenceFactoryUriUpdated',\n    value: function onConferenceFactoryUriUpdated(uri) {\n      this.factoryUri = uri;\n      _get(ConferenceManager.prototype.__proto__ || Object.getPrototypeOf(ConferenceManager.prototype), 'onConferenceFactoryUriUpdated', this).call(this, uri);\n    }\n  }, {\n    key: 'from',\n    get: function get() {\n      return this._from;\n    },\n    set: function set(from) {\n      if (this._from !== from) {\n        this._from = from;\n        this.emit('fromChanged', from);\n      }\n    }\n  }, {\n    key: 'factoryUri',\n    get: function get() {\n      return this._factoryUri;\n    },\n    set: function set(factoryUri) {\n      if (this._factoryUri !== factoryUri) {\n        this._factoryUri = factoryUri;\n        this.emit('factoryUriChanged', factoryUri);\n      }\n    }\n  }]);\n\n  return ConferenceManager;\n}(Manager);\n\n//# sourceURL=webpack://ApolloSIP/./src/Conference/ConferenceManager.js?");

/***/ }),

/***/ "./src/Conference/Info/Description.js":
/*!********************************************!*\
  !*** ./src/Conference/Info/Description.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Item = __webpack_require__(/*! ./Item */ \"./src/Conference/Info/Item.js\");\nvar Utils = __webpack_require__(/*! ../../Base/Utils */ \"./src/Base/Utils.js\");\n\nmodule.exports = function (_Item) {\n  _inherits(Description, _Item);\n\n  function Description(information) {\n    _classCallCheck(this, Description);\n\n    var _this = _possibleConstructorReturn(this, (Description.__proto__ || Object.getPrototypeOf(Description)).call(this));\n\n    _this._information = information;\n    return _this;\n  }\n\n  _createClass(Description, [{\n    key: 'getUri',\n    value: function getUri(purpose) {\n      var uris = this.confUris;\n\n      uris = Utils.arrayfy(uris['entry']);\n\n      var uri = uris.find(function (u) {\n        return u['purpose'] === purpose;\n      });\n\n      return uri['uri'];\n    }\n  }, {\n    key: 'admissionPolicy',\n    get: function get() {\n      return this.get('subject');\n    }\n  }, {\n    key: 'attendeePin',\n    get: function get() {\n      return this.get('attendee-pin');\n    }\n  }, {\n    key: 'autopromote',\n    get: function get() {\n      return this.get('autopromote');\n    }\n  }, {\n    key: 'bookExpiryTime',\n    get: function get() {\n      return this.get('book-expiry-time');\n    }\n  }, {\n    key: 'bookStartTime',\n    get: function get() {\n      return this.get('book-start-time');\n    }\n  }, {\n    key: 'remindEarly',\n    get: function get() {\n      return this.get('remind-early');\n    }\n  }, {\n    key: 'createEarly',\n    get: function get() {\n      return this.get('create-early');\n    }\n  }, {\n    key: 'confUris',\n    get: function get() {\n      return this.get('conf-uris');\n    }\n  }, {\n    key: 'conferenceId',\n    get: function get() {\n      return this.get('conference-id');\n    }\n  }, {\n    key: 'conferenceNumber',\n    get: function get() {\n      return this.get('conference-number');\n    }\n  }, {\n    key: 'conferenceType',\n    get: function get() {\n      return this.get('conference-type');\n    }\n  }, {\n    key: 'maximumUserCount',\n    get: function get() {\n      return this.get('maximum-user-count');\n    }\n  }, {\n    key: 'organizer',\n    get: function get() {\n      return this.get('organizer');\n    }\n  }, {\n    key: 'presenterPin',\n    get: function get() {\n      return this.get('presenter-pin');\n    }\n  }, {\n    key: 'profile',\n    get: function get() {\n      return this.get('profile');\n    }\n  }, {\n    key: 'scheduleId',\n    get: function get() {\n      return this.get('schedule-id');\n    }\n  }, {\n    key: 'serverMode',\n    get: function get() {\n      return this.get('server-mode');\n    }\n  }, {\n    key: 'startTime',\n    get: function get() {\n      return this.get('start-time');\n    }\n  }, {\n    key: 'subject',\n    get: function get() {\n      return this.get('subject');\n    }\n  }]);\n\n  return Description;\n}(Item);\n\n//# sourceURL=webpack://ApolloSIP/./src/Conference/Info/Description.js?");

/***/ }),

/***/ "./src/Conference/Info/Information.js":
/*!********************************************!*\
  !*** ./src/Conference/Info/Information.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar Debug = __webpack_require__(/*! ../../Base/Debug */ \"./src/Base/Debug.js\");\nvar Utils = __webpack_require__(/*! ../../Base/Utils */ \"./src/Base/Utils.js\");\nvar Description = __webpack_require__(/*! ./Description */ \"./src/Conference/Info/Description.js\");\nvar State = __webpack_require__(/*! ./State */ \"./src/Conference/Info/State.js\");\nvar View = __webpack_require__(/*! ./View */ \"./src/Conference/Info/View.js\");\nvar Users = __webpack_require__(/*! ./Users */ \"./src/Conference/Info/Users.js\");\n\nvar debug = Debug('Apollo:Information');\nvar warn = Debug('Apollo:Information:Warn');\n\nwarn.log = console.warn.bind(console);\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(Information, _EventEmitter);\n\n  function Information(conference) {\n    _classCallCheck(this, Information);\n\n    var _this = _possibleConstructorReturn(this, (Information.__proto__ || Object.getPrototypeOf(Information)).call(this));\n\n    _this._conference = conference;\n\n    _this._entity = undefined;\n    _this._version = -1;\n    _this._time = undefined;\n    _this._description = new Description(_this);\n    _this._state = new State(_this);\n    _this._view = new View(_this);\n    _this._users = new Users(_this);\n    return _this;\n  }\n\n  _createClass(Information, [{\n    key: 'update',\n    value: function update(xml) {\n      var info = void 0;\n\n      if (typeof xml === 'string') {\n        info = Utils.objectify(xml)['conference-info'];\n      } else if ((typeof xml === 'undefined' ? 'undefined' : _typeof(xml)) === 'object') {\n        info = xml['conference-info'];\n      } else {\n        warn('Only xml string or object is accepted.');\n\n        return;\n      }\n\n      debug('update information: %o', info);\n\n      if (!this.entity) {\n        this._entity = info['@entity'];\n      } else if (this.entity !== info['@entity']) {\n        warn('Entity unmatch!');\n\n        return;\n      }\n\n      if (this.version < info['@version']) {\n        switch (info['@state']) {\n          case 'full':\n            this._fullUpdate(info);\n            break;\n          case 'partial':\n            this._particalUpdate(info);\n            break;\n          case 'deleted':\n            this._deletedUpdate();\n            break;\n          default:\n            warn('Missing state. Fallback to partical update.');\n            this._particalUpdate(info);\n            break;\n        }\n\n        this._version = info['@version'];\n      }\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this._deletedUpdate();\n    }\n  }, {\n    key: 'isShareAvariable',\n    value: function isShareAvariable(userEntity) {\n      userEntity = userEntity || this._conference.from;\n\n      var sharePermission = false;\n\n      var profile = this.description.profile;\n      var user = this.users.getUser(userEntity);\n\n      if (!user) {\n        return false;\n      }\n\n      switch (profile) {\n        case 'default':\n          sharePermission = true;\n          break;\n        case 'demonstrator':\n          sharePermission = user.roles.demostate === 'demonstrator' ? true : user.roles.permission === 'presenter' || user.roles.permission === 'organizer' ? true : false;\n          break;\n      }\n\n      return sharePermission;\n    }\n  }, {\n    key: '_fullUpdate',\n    value: function _fullUpdate(info) {\n      this._time = info['now-time'];\n\n      this._description.update(info['conference-description'], true);\n      this._state.update(info['conference-state'], true);\n      this._view.update(info['conference-view'], true);\n      this._users.update(info['users'], true);\n\n      this._checkUpdate(info);\n    }\n  }, {\n    key: '_particalUpdate',\n    value: function _particalUpdate(info) {\n      var participantCount = this.users.participantCount;\n\n      this._time = info['now-time'];\n\n      this._description.update(info['conference-description']);\n      this._state.update(info['conference-state']);\n      this._view.update(info['conference-view']);\n      this._users.update(info['users']);\n\n      this._checkUpdate(info);\n\n      if (!this._conference) {\n        return;\n      }\n\n      var participantCountDiff = this.users.participantCount - participantCount;\n\n      if (participantCountDiff > 0) {\n        this._conference._userAdded(this.users.updatedUser);\n      } else if (participantCountDiff === 0) {\n        this._conference._userUpdated(this.users.updatedUser);\n      } else {\n        this._conference._userDeleted(this.users.updatedUser);\n      }\n    }\n  }, {\n    key: '_deletedUpdate',\n    value: function _deletedUpdate() {\n      this._version = 0;\n      this._time = '';\n\n      this._description.update({}, true);\n      this._state.update({}, true);\n      this._view.update({}, true);\n      this._users.update({}, true);\n    }\n  }, {\n    key: '_checkUpdate',\n    value: function _checkUpdate(info) {\n      if (!this._conference) {\n        return;\n      }\n\n      if (info['conference-description']) {\n        this._conference._descriptionUpdated();\n      }\n      if (info['conference-state']) {\n        this._conference._stateUpdated();\n      }\n      if (info['conference-view']) {\n        this._conference._viewUpdated();\n      }\n      if (info['users']) {\n        this._conference._usersUpdated();\n      }\n    }\n  }, {\n    key: 'from',\n    get: function get() {\n      return this._conference ? this._conference.from : null;\n    }\n  }, {\n    key: 'entity',\n    get: function get() {\n      return this._conference ? this._conference.entity : this._entity;\n    }\n  }, {\n    key: 'version',\n    get: function get() {\n      return this._version;\n    }\n  }, {\n    key: 'time',\n    get: function get() {\n      return this._time;\n    }\n  }, {\n    key: 'description',\n    get: function get() {\n      return this._description;\n    }\n  }, {\n    key: 'state',\n    get: function get() {\n      return this._state;\n    }\n  }, {\n    key: 'view',\n    get: function get() {\n      return this._view;\n    }\n  }, {\n    key: 'users',\n    get: function get() {\n      return this._users;\n    }\n  }]);\n\n  return Information;\n}(EventEmitter);\n\n//# sourceURL=webpack://ApolloSIP/./src/Conference/Info/Information.js?");

/***/ }),

/***/ "./src/Conference/Info/Item.js":
/*!*************************************!*\
  !*** ./src/Conference/Info/Item.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Debug = __webpack_require__(/*! ../../Base/Debug */ \"./src/Base/Debug.js\");\n\nvar debug = Debug('Apollo:Item');\n\nmodule.exports = function () {\n  function Item() {\n    var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Item);\n\n    this._internal = object;\n  }\n\n  _createClass(Item, [{\n    key: 'get',\n    value: function get(name) {\n      return this._internal[name];\n    }\n  }, {\n    key: 'update',\n    value: function update(obj) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!obj) {\n        return;\n      }\n\n      if (force) {\n        this._internal = obj;\n      } else {\n        this.mergeObjectToObject(this._internal, obj);\n      }\n    }\n  }, {\n    key: 'mergeObjectToObject',\n    value: function mergeObjectToObject(rhys, object) {\n      var merged = rhys;\n\n      if (rhys['@entity'] && rhys['@entity'] !== object['@entity'] || rhys['@id'] && rhys['@id'] !== object['@id']) {\n        debug('entity|id unmatch');\n        merged = [rhys, object];\n      } else {\n        Object.keys(object).forEach(function (key) {\n          if (merged[key]) {\n            if (Array.isArray(merged[key])) {\n              if (Array.isArray(object[key])) {\n                debug('merge ' + key);\n                merged[key] = this.mergeArrayToArray(merged[key], object[key]);\n                debug(merged[key]);\n              } else if (_typeof(object[key]) === 'object') {\n                debug('merge ' + key);\n                merged[key] = this.mergeObjectToArray(merged[key], object[key]);\n                debug(merged[key]);\n              }\n            } else if (_typeof(merged[key]) === 'object') {\n              if (Array.isArray(object[key])) {\n                debug('merge ' + key);\n                merged[key] = this.mergeArrayToObject(merged[key], object[key]);\n                debug(merged[key]);\n              } else if (_typeof(object[key]) === 'object') {\n                debug('merge ' + key);\n                merged[key] = this.mergeObjectToObject(merged[key], object[key]);\n                debug(merged[key]);\n              } else {\n                debug('merge ' + key);\n                debug('Assign #text: ' + merged[key] + '#' + merged[key]['#text'] + ' <- ' + object[key]);\n                merged[key]['#text'] = object[key];\n                debug(merged[key]);\n              }\n            } else if (key !== '@entity' && key !== '@id') {\n              debug('merge ' + key);\n              if (merged[key] !== object[key]) {\n                if (!(key === '@state' && object[key] === 'partial')) {\n                  debug('Assign: ' + merged[key] + ' <- ' + object[key]);\n                  merged[key] = object[key];\n                }\n              } else {\n                debug('Equal: ' + merged[key] + ' = ' + object[key]);\n              }\n            }\n          } else if (object[key] || object[key] !== '') {\n            debug('merge ' + key);\n            merged[key] = object[key];\n            debug('Assign new ' + key + ': <- ' + merged[key]);\n          }\n        }, this);\n      }\n\n      return merged;\n    }\n  }, {\n    key: 'mergeObjectToArray',\n    value: function mergeObjectToArray(array, object) {\n      var entity = object['@entity'] || object['@id'];\n\n      var merged = [];\n\n      var found = false;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var iterator = _step.value;\n\n          var iterEntity = iterator['@entity'] || iterator['@id'];\n\n          if (iterEntity === entity) {\n            found = true;\n            debug('found entity|id ' + entity);\n            iterator = this.mergeObjectToObject(iterator, object);\n          }\n          merged.push(iterator);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (!found) {\n        debug('Not found entity|id ' + entity);\n        merged.push(object);\n      }\n\n      merged = merged.filter(function (item) {\n        return item['@state'] !== 'deleted';\n      });\n\n      return merged;\n    }\n  }, {\n    key: 'mergeArrayToObject',\n    value: function mergeArrayToObject(object, array) {\n      var merged = [object];\n\n      merged = this.mergeArrayToArray(merged, array);\n\n      merged = merged.filter(function (item) {\n        return item['@state'] !== 'deleted';\n      });\n\n      return merged;\n    }\n  }, {\n    key: 'mergeArrayToArray',\n    value: function mergeArrayToArray(rhys, array) {\n      var merged = [];\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var iterator = _step2.value;\n\n          merged = this.mergeObjectToArray(rhys, iterator);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      merged = merged.filter(function (item) {\n        return item['@state'] !== 'deleted';\n      });\n\n      return merged;\n    }\n  }]);\n\n  return Item;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./src/Conference/Info/Item.js?");

/***/ }),

/***/ "./src/Conference/Info/State.js":
/*!**************************************!*\
  !*** ./src/Conference/Info/State.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Item = __webpack_require__(/*! ./Item */ \"./src/Conference/Info/Item.js\");\n\nmodule.exports = function (_Item) {\n  _inherits(State, _Item);\n\n  function State(information) {\n    _classCallCheck(this, State);\n\n    var _this = _possibleConstructorReturn(this, (State.__proto__ || Object.getPrototypeOf(State)).call(this));\n\n    _this._information = information;\n    return _this;\n  }\n\n  _createClass(State, [{\n    key: 'active',\n    get: function get() {\n      return this.get('active') === 'false' ? false : true;\n    }\n  }, {\n    key: 'locked',\n    get: function get() {\n      return this.get('locked') === 'false' ? false : true;\n    }\n  }]);\n\n  return State;\n}(Item);\n\n//# sourceURL=webpack://ApolloSIP/./src/Conference/Info/State.js?");

/***/ }),

/***/ "./src/Conference/Info/User.js":
/*!*************************************!*\
  !*** ./src/Conference/Info/User.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Item = __webpack_require__(/*! ./Item */ \"./src/Conference/Info/Item.js\");\nvar Utils = __webpack_require__(/*! ../../Base/Utils */ \"./src/Base/Utils.js\");\n\nmodule.exports = function (_Item) {\n  _inherits(User, _Item);\n\n  function User(obj) {\n    _classCallCheck(this, User);\n\n    return _possibleConstructorReturn(this, (User.__proto__ || Object.getPrototypeOf(User)).call(this, obj));\n  }\n\n  _createClass(User, [{\n    key: 'getMedia',\n\n\n    // main-audio | main-video | applicationsharing\n    value: function getMedia(label) {\n      var media = this.mediaList.find(function (m) {\n        return m['label'] === label;\n      });\n\n      return media;\n    }\n  }, {\n    key: 'isSharing',\n    value: function isSharing() {\n      var shareMedia = this.getMedia('applicationsharing');\n\n      return shareMedia && shareMedia['status'] === 'sendonly';\n    }\n  }, {\n    key: 'entity',\n    get: function get() {\n      return this.get('@entity');\n    }\n  }, {\n    key: 'displayText',\n    get: function get() {\n      return this.get('display-text');\n    }\n  }, {\n    key: 'endpoint',\n    get: function get() {\n      return Utils.arrayfy(this.get('endpoint'));\n    }\n  }, {\n    key: 'phone',\n    get: function get() {\n      return this.get('phone');\n    }\n  }, {\n    key: 'roles',\n    get: function get() {\n      var userRoles = {\n        permission: 'attendee', // attendee | presenter | organizer\n        demostate: 'audience' // audience | demonstrator\n      };\n      var rolesEntry = Utils.arrayfy(this.get('roles')['entry']);\n\n      rolesEntry.forEach(function (role) {\n        switch (role['@entity']) {\n          case 'permission':\n            userRoles.permission = role['#text'];\n            break;\n          case 'demostate':\n            userRoles.demostate = role['#text'];\n            break;\n        }\n      });\n\n      return userRoles;\n    }\n  }, {\n    key: 'uid',\n    get: function get() {\n      return this.get('uid');\n    }\n  }, {\n    key: 'userAgent',\n    get: function get() {\n      return this.get('user-agent');\n    }\n  }, {\n    key: 'mediaList',\n    get: function get() {\n      var list = [];\n\n      this.endpoint.forEach(function (endpoint) {\n        var media = endpoint['media'];\n\n        if (media && Array.isArray(media)) {\n          list = list.concat(media);\n        } else if (media && (typeof media === 'undefined' ? 'undefined' : _typeof(media)) === 'object') {\n          list.push(media);\n        }\n      });\n\n      return list;\n    }\n  }]);\n\n  return User;\n}(Item);\n\n//# sourceURL=webpack://ApolloSIP/./src/Conference/Info/User.js?");

/***/ }),

/***/ "./src/Conference/Info/Users.js":
/*!**************************************!*\
  !*** ./src/Conference/Info/Users.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Item = __webpack_require__(/*! ./Item */ \"./src/Conference/Info/Item.js\");\nvar Utils = __webpack_require__(/*! ../../Base/Utils */ \"./src/Base/Utils.js\");\nvar User = __webpack_require__(/*! ./User */ \"./src/Conference/Info/User.js\");\n\nmodule.exports = function (_Item) {\n  _inherits(Users, _Item);\n\n  function Users(information) {\n    _classCallCheck(this, Users);\n\n    var _this = _possibleConstructorReturn(this, (Users.__proto__ || Object.getPrototypeOf(Users)).call(this));\n\n    _this._information = information;\n    _this._userList = [];\n    _this._updatedUser = {};\n    return _this;\n  }\n\n  _createClass(Users, [{\n    key: 'getUser',\n    value: function getUser(entity) {\n      return this.userList.find(function (user) {\n        return user.entity == entity;\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update(obj) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!obj) {\n        return;\n      }\n\n      var entity = undefined;\n      var updatingUser = undefined;\n\n      var userObj = obj['user'];\n\n      if ((typeof userObj === 'undefined' ? 'undefined' : _typeof(userObj)) === 'object') {\n        entity = userObj['@entity'];\n      }\n\n      updatingUser = this.getUser(entity);\n\n      _get(Users.prototype.__proto__ || Object.getPrototypeOf(Users.prototype), 'update', this).call(this, obj, force);\n\n      var list = Utils.arrayfy(this.get('user'));\n\n      // TODO\n      // we should use the previous object instead of create new one every time.\n      this._userList = list.map(function (userInfo) {\n        var user = new User(userInfo);\n        var currentUserEntity = this._information.from;\n        var organizer = this._information.description.organizer;\n\n        // setup user's attached properties.\n        user.isCurrentUser = function () {\n          return this.entity === currentUserEntity;\n        };\n\n        user.isOrganizer = function () {\n          return user.uid === organizer.uid;\n        };\n\n        return user;\n      }, this);\n\n      this._updatedUser = this.getUser(entity) || updatingUser;\n    }\n  }, {\n    key: 'updatedUser',\n    get: function get() {\n      return this._updatedUser;\n    }\n  }, {\n    key: 'participantCount',\n    get: function get() {\n      return this.get('@participant-count');\n    }\n  }, {\n    key: 'userList',\n    get: function get() {\n      return this._userList;\n    }\n  }, {\n    key: 'sharingUser',\n    get: function get() {\n      var sharingUser = this.userList.find(function (user) {\n        return user.isSharing();\n      });\n\n      return sharingUser;\n    }\n  }, {\n    key: 'currentUser',\n    get: function get() {\n      var currentUser = this.userList.find(function (user) {\n        return user.isCurrentUser();\n      });\n\n      return currentUser;\n    }\n  }]);\n\n  return Users;\n}(Item);\n\n//# sourceURL=webpack://ApolloSIP/./src/Conference/Info/Users.js?");

/***/ }),

/***/ "./src/Conference/Info/View.js":
/*!*************************************!*\
  !*** ./src/Conference/Info/View.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Item = __webpack_require__(/*! ./Item */ \"./src/Conference/Info/Item.js\");\nvar Utils = __webpack_require__(/*! ../../Base/Utils */ \"./src/Base/Utils.js\");\n\nmodule.exports = function (_Item) {\n  _inherits(View, _Item);\n\n  function View(information) {\n    _classCallCheck(this, View);\n\n    var _this = _possibleConstructorReturn(this, (View.__proto__ || Object.getPrototypeOf(View)).call(this));\n\n    _this._information = information;\n    return _this;\n  }\n\n  _createClass(View, [{\n    key: 'getEntityView',\n    value: function getEntityView(entity) {\n      return this.entityViewList.find(function (entityView) {\n        return entityView['@entity'] == entity;\n      });\n    }\n  }, {\n    key: 'entityViewList',\n    get: function get() {\n      return Utils.arrayfy(this.get('entity-view'));\n    }\n  }]);\n\n  return View;\n}(Item);\n\n//# sourceURL=webpack://ApolloSIP/./src/Conference/Info/View.js?");

/***/ }),

/***/ "./src/Error/Error.js":
/*!****************************!*\
  !*** ./src/Error/Error.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ErrorMap = {\n  60001: 'Uri Unknown',\n  60002: 'Locked',\n  60003: 'User Count Exceed',\n  60004: 'User Duplicate',\n  60005: 'Send MSG To MCU Failed',\n  60006: 'MCU Request SESS Failed',\n  60007: 'MCU Response IP Invalid',\n  60008: 'GEN MCU SDP Failed',\n  60009: 'MCU Start Session Failed',\n  60010: 'MCU Notify QUIT',\n  60011: 'Endpoint Add Failed',\n  60012: 'User Deleted',\n  60013: 'Conference Deleted',\n  60014: 'Uri Invalid',\n  60015: 'MCU Start AUTH Session Failed',\n  60016: 'License Amount Limit',\n  60017: 'MCU Keep Alive Failed',\n  60018: 'MCU Create Failed',\n  60019: 'MCU Set Param Failed',\n  60020: 'MCU Not Connected',\n  60021: 'Alloc NUM Failed',\n  60022: 'Not Started',\n  60023: 'Has End',\n  60024: 'Join Multi Endpoint',\n  60025: 'Endpoint Duplicate',\n  60026: 'Invalid C3P Request',\n  60027: 'MCU Entry Not Found',\n  60028: 'User Resource Not Found',\n  60029: 'Permission Denied',\n  60030: 'Invalid PIN',\n  60031: 'Invite Miss User Entity',\n  60032: 'Miss Book Info By ID',\n  60033: 'New Failed',\n  60034: 'Run Failed',\n  60035: 'MCU Session Keep Alive Failed',\n  60036: 'New Share Joined',\n  60037: 'Broadcast Layout Not Found',\n  60038: 'Invite VMR Failed',\n  60039: 'Interactive Broadcast Disable',\n  60040: 'Broadcast License Amount Limit',\n  60041: 'Blacklist Limit',\n  60042: 'IP Direct Blacklist Limit',\n  60043: 'Sip Invite Trans H323'\n};\n\nvar FreeSwitchError = function (_Error) {\n  _inherits(FreeSwitchError, _Error);\n\n  function FreeSwitchError(data) {\n    _classCallCheck(this, FreeSwitchError);\n\n    var _this = _possibleConstructorReturn(this, (FreeSwitchError.__proto__ || Object.getPrototypeOf(FreeSwitchError)).call(this));\n\n    _this.name = 'FreeSwitch Error';\n    _this.originator = data.originator || 'local';\n    _this.code = data.code || 0;\n    _this.cause = data.cause || 'Unknown';\n    _this.message = data.message || 'Unknown Error';\n\n    if (data.message) {\n      var reason = data.message.getHeader('Reason');\n      // Reason Header\n      // APOLLO;cause=60032;text=\"Conference miss book info by id\"\n\n      if (reason) {\n        var code = reason.split(';')[1].split('=')[1];\n        var cause = ErrorMap[code];\n        var message = reason.split(';')[2].split('=')[1];\n\n        _this.code = Number.parseInt(code);\n        _this.cause = cause;\n        _this.message = message;\n      }\n    }\n    return _this;\n  }\n\n  return FreeSwitchError;\n}(Error);\n\nmodule.exports = {\n  FreeSwitchError: FreeSwitchError\n};\n\n//# sourceURL=webpack://ApolloSIP/./src/Error/Error.js?");

/***/ }),

/***/ "./src/Manager/Manager.js":
/*!********************************!*\
  !*** ./src/Manager/Manager.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar Utils = __webpack_require__(/*! ../Base/Utils */ \"./src/Base/Utils.js\");\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(Manager, _EventEmitter);\n\n  function Manager() {\n    _classCallCheck(this, Manager);\n\n    var _this = _possibleConstructorReturn(this, (Manager.__proto__ || Object.getPrototypeOf(Manager)).call(this));\n\n    _this._ua = undefined;\n    return _this;\n  }\n\n  _createClass(Manager, [{\n    key: 'isAvariable',\n    value: function isAvariable() {\n      return this.ua && this.ua.isRegistered();\n    }\n  }, {\n    key: 'onConnecting',\n    value: function onConnecting(data) {\n      this.emit('connecting', data);\n    }\n  }, {\n    key: 'onConnected',\n    value: function onConnected(data) {\n      this.emit('connected', data);\n    }\n  }, {\n    key: 'onDisconnected',\n    value: function onDisconnected(data) {\n      this.emit('disconnected', data);\n    }\n  }, {\n    key: 'onRegistered',\n    value: function onRegistered(data) {\n      this.emit('registered', data);\n    }\n  }, {\n    key: 'onUnregistered',\n    value: function onUnregistered(data) {\n      this.emit('unregistered', data);\n    }\n  }, {\n    key: 'onRegistrationFailed',\n    value: function onRegistrationFailed(data) {\n      this.emit('registrationFailed', data);\n    }\n  }, {\n    key: 'onNewRTCSession',\n    value: function onNewRTCSession(data) {\n      this.emit('newRTCSession', data);\n    }\n  }, {\n    key: 'onNewMessage',\n    value: function onNewMessage(data) {\n      this.emit('newMessage', data);\n    }\n  }, {\n    key: 'onConferenceFactoryUriUpdated',\n    value: function onConferenceFactoryUriUpdated(uri) {\n      this.emit('conferenceFactoryUriUpdated', uri);\n    }\n  }, {\n    key: 'ua',\n    get: function get() {\n      return this._ua;\n    },\n    set: function set(ua) {\n      if (this._ua !== ua) {\n        var eventHandlers = {\n          connecting: this.onConnecting.bind(this),\n          connected: this.onConnected.bind(this),\n          disconnected: this.onDisconnected.bind(this),\n          registered: this.onRegistered.bind(this),\n          unregistered: this.onUnregistered.bind(this),\n          registrationFailed: this.onRegistrationFailed.bind(this),\n          newRTCSession: this.onNewRTCSession.bind(this),\n          newMessage: this.onNewMessage.bind(this),\n          conferenceFactoryUriUpdated: this.onConferenceFactoryUriUpdated.bind(this)\n        };\n\n        Utils.removeEventHandlers(this._ua, eventHandlers);\n\n        this._ua = ua;\n\n        Utils.setupEventHandlers(this._ua, eventHandlers);\n\n        this.emit('uaChanged', ua);\n      }\n    }\n  }]);\n\n  return Manager;\n}(EventEmitter);\n\n//# sourceURL=webpack://ApolloSIP/./src/Manager/Manager.js?");

/***/ }),

/***/ "./src/Socket/SocketInterface.js":
/*!***************************************!*\
  !*** ./src/Socket/SocketInterface.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SIP = __webpack_require__(/*! ../Base/SIP */ \"./src/Base/SIP.js\");\nvar Url = __webpack_require__(/*! url */ \"url\");\n\nmodule.exports = function () {\n  _createClass(SocketInterface, null, [{\n    key: 'Create',\n    value: function Create(_ref) {\n      var server = _ref.server,\n          socketOptions = _ref.socketOptions,\n          proxy = _ref.proxy;\n\n      var serverUrl = Url.parse(server || '');\n      var proxyUrl = Url.parse(proxy || '');\n\n      serverUrl.pathname = serverUrl.pathname || '/';\n      proxyUrl.pathname = proxyUrl.pathname || '/';\n\n      var socketUrl = void 0;\n      var socketInterface = void 0;\n\n      switch (socketOptions.type) {\n        case 'socketio':\n          socketUrl = proxyUrl.href;\n          socketOptions.query = 'fsaddr=' + serverUrl.hostname;\n          socketInterface = new SIP.SocketIOInterface(socketUrl, socketOptions);\n          break;\n        case 'websocket':\n        default:\n          socketUrl = serverUrl.href;\n          if (!SIP.Utils.isEmpty(proxy)) {\n            socketUrl = Url.format({\n              protocol: proxyUrl.protocol,\n              hostname: proxyUrl.hostname,\n              port: proxyUrl.port,\n              pathname: proxyUrl.pathname + serverUrl.hostname,\n              slashes: true\n            });\n          }\n          socketInterface = new SIP.WebSocketInterface(socketUrl, socketOptions);\n          break;\n      }\n\n      return socketInterface;\n    }\n  }]);\n\n  function SocketInterface() {\n    _classCallCheck(this, SocketInterface);\n  }\n\n  return SocketInterface;\n}();\n\n//# sourceURL=webpack://ApolloSIP/./src/Socket/SocketInterface.js?");

/***/ }),

/***/ "./src/UA/ApolloControl.js":
/*!*********************************!*\
  !*** ./src/UA/ApolloControl.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar Utils = __webpack_require__(/*! ../Base/Utils */ \"./src/Base/Utils.js\");\nvar debug = __webpack_require__(/*! ../Base/Debug */ \"./src/Base/Debug.js\")('Apollo:Control');\n\nvar CONTROL_GROUP = {\n  DEVICE_CONTROL: 'deviceControl',\n  CONFIG_CONTROL: 'configControl',\n  NOTICE_CONTROL: 'noticeControl'\n};\n\nvar ApolloControl = function (_EventEmitter) {\n  _inherits(ApolloControl, _EventEmitter);\n\n  _createClass(ApolloControl, null, [{\n    key: 'CONTROL_GROUP',\n    get: function get() {\n      return CONTROL_GROUP;\n    }\n  }]);\n\n  function ApolloControl(ua) {\n    _classCallCheck(this, ApolloControl);\n\n    var _this = _possibleConstructorReturn(this, (ApolloControl.__proto__ || Object.getPrototypeOf(ApolloControl)).call(this));\n\n    _this._ua = ua;\n    _this._target = ua.get('uri');\n    _this._expires = 3600;\n    _this._event = 'apollo-control';\n    _this._contentType = 'application/apollo-ctrl+xml';\n    _this._extraHeaders = ['Accept: ' + _this._contentType];\n    _this._subscription = null;\n    return _this;\n  }\n\n  _createClass(ApolloControl, [{\n    key: 'subscribe',\n    value: function subscribe(controlGroup) {\n      var _this2 = this;\n\n      debug('subscribe()');\n\n      var body = {\n        controlGroupList: {\n          controlGroup: []\n        }\n      };\n\n      if (!Array.isArray(controlGroup)) {\n        controlGroup = [controlGroup];\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = controlGroup[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var control = _step.value;\n\n          body.controlGroupList.controlGroup.push({\n            '@name': control\n          });\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this._subscription = this._ua.subscribe(this._target, this._event, {\n        expires: this._expires,\n        extraHeaders: this._extraHeaders,\n        body: Utils.xmlify(body),\n        contentType: this._contentType,\n        eventHandlers: {\n          progress: function progress() {\n            debug('subscription progress.');\n          },\n          successed: function successed() {\n            debug('subscription successed.');\n          },\n          failed: function failed(data) {\n            debug('subscription failed. %s', data.cause);\n          },\n          notify: function notify(data) {\n            _this2.onNotify(data);\n          }\n        }\n      });\n    }\n  }, {\n    key: 'unsubscribe',\n    value: function unsubscribe() {\n      debug('unsubscribe()');\n\n      if (this._subscription) {\n        this._subscription.terminate();\n      }\n    }\n  }, {\n    key: 'onNotify',\n    value: function onNotify(data) {\n      debug('onNotify: %o', data);\n\n      var xml = data.notify;\n      var obj = Utils.objectify(xml);\n\n      if (obj && obj['request']) {\n        var request = obj['request'];\n        var descript = request['descript'];\n        var body = request['body'];\n\n        if (descript['method'] === 'apollo-control') {\n          var controlGroup = body['controlGroupList']['controlGroup'];\n          var controlGroupName = controlGroup['@name'];\n\n          switch (controlGroupName) {\n            case CONTROL_GROUP.CONFIG_CONTROL:\n              this.emit('notify', CONTROL_GROUP.CONFIG_CONTROL, controlGroup);\n              break;\n            case CONTROL_GROUP.DEVICE_CONTROL:\n              this.emit('notify', CONTROL_GROUP.DEVICE_CONTROL, controlGroup);\n              break;\n            case CONTROL_GROUP.NOTICE_CONTROL:\n              this.emit('notify', CONTROL_GROUP.NOTICE_CONTROL, controlGroup);\n              break;\n            default:\n              break;\n          }\n        }\n      }\n    }\n  }]);\n\n  return ApolloControl;\n}(EventEmitter);\n\nmodule.exports = ApolloControl;\n\n//# sourceURL=webpack://ApolloSIP/./src/UA/ApolloControl.js?");

/***/ }),

/***/ "./src/UA/ApolloProvision.js":
/*!***********************************!*\
  !*** ./src/UA/ApolloProvision.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar Utils = __webpack_require__(/*! ../Base/Utils */ \"./src/Base/Utils.js\");\nvar debug = __webpack_require__(/*! ../Base/Debug */ \"./src/Base/Debug.js\")('Apollo:Provision');\n\nvar PROVISION_GROUP = {\n  SERVER_CONFIGURATION: 'serverConfiguration',\n  ENDPOINT_CONFIGURATION: 'endpointConfiguration'\n};\n\nmodule.exports = function (_EventEmitter) {\n  _inherits(ApolloProvision, _EventEmitter);\n\n  _createClass(ApolloProvision, null, [{\n    key: 'PROVISION_GROUP',\n    get: function get() {\n      return PROVISION_GROUP;\n    }\n  }]);\n\n  function ApolloProvision(ua) {\n    _classCallCheck(this, ApolloProvision);\n\n    var _this = _possibleConstructorReturn(this, (ApolloProvision.__proto__ || Object.getPrototypeOf(ApolloProvision)).call(this));\n\n    _this._ua = ua;\n    _this._target = ua.get('uri');\n    _this._expires = 3600;\n    _this._event = 'apollo-provisioning';\n    _this._contentType = 'application/apollo-provisioning+xml';\n    _this._extraHeaders = ['Accept: ' + _this._contentType];\n    _this._subscription = null;\n    return _this;\n  }\n\n  _createClass(ApolloProvision, [{\n    key: 'subscribe',\n    value: function subscribe(provisionGroup) {\n      var _this2 = this;\n\n      var body = {\n        provisionGroupList: {\n          provisionGroup: []\n        }\n      };\n\n      if (!Array.isArray(provisionGroup)) {\n        provisionGroup = [provisionGroup];\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = provisionGroup[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var provision = _step.value;\n\n          body.provisionGroupList.provisionGroup.push({\n            '@name': provision\n          });\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this._subscription = this._ua.subscribe(this._target, this._event, {\n        expires: this._expires,\n        extraHeaders: this._extraHeaders,\n        body: Utils.xmlify(body),\n        contentType: this._contentType,\n        eventHandlers: {\n          progress: function progress() {\n            debug('subscription progress.');\n          },\n          successed: function successed() {\n            debug('subscription successed.');\n          },\n          failed: function failed(data) {\n            debug('subscription failed. %s', data.cause);\n          },\n          notify: function notify(data) {\n            _this2.onNotify(data);\n          }\n        }\n      });\n    }\n  }, {\n    key: 'unsubscribe',\n    value: function unsubscribe() {\n      debug('unsubscribe()');\n\n      if (this._subscription) {\n        this._subscription.terminate();\n      }\n    }\n  }, {\n    key: 'onNotify',\n    value: function onNotify(data) {\n      debug('onNotify: %o', data);\n\n      var xml = data.notify;\n      var obj = Utils.objectify(xml);\n\n      if (obj && obj['provisionGroupList']) {\n        var provisionGroupList = obj['provisionGroupList'];\n\n        if (provisionGroupList) {\n          var provisionGroup = provisionGroupList['provisionGroup'];\n          var provisionName = '';\n\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = provisionGroup[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var provision = _step2.value;\n\n              provisionName = provision['@name'];\n\n              switch (provisionName) {\n                case PROVISION_GROUP.SERVER_CONFIGURATION:\n                  this.emit('notify', PROVISION_GROUP.SERVER_CONFIGURATION, provision);\n                  break;\n                case PROVISION_GROUP.ENDPOINT_CONFIGURATION:\n                  this.emit('notify', PROVISION_GROUP.ENDPOINT_CONFIGURATION, provision);\n                  break;\n                default:\n                  break;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'PROVISION_GROUP',\n    get: function get() {\n      return PROVISION_GROUP;\n    }\n  }]);\n\n  return ApolloProvision;\n}(EventEmitter);\n\n//# sourceURL=webpack://ApolloSIP/./src/UA/ApolloProvision.js?");

/***/ }),

/***/ "./src/UA/UA.js":
/*!**********************!*\
  !*** ./src/UA/UA.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar SIP = __webpack_require__(/*! ../Base/SIP */ \"./src/Base/SIP.js\");\nvar URL = __webpack_require__(/*! url */ \"url\");\nvar Base64 = __webpack_require__(/*! js-base64 */ \"./node_modules/js-base64/base64.js\").Base64;\nvar SocketInterface = __webpack_require__(/*! ../Socket/SocketInterface */ \"./src/Socket/SocketInterface.js\");\nvar ApolloControl = __webpack_require__(/*! ./ApolloControl */ \"./src/UA/ApolloControl.js\");\nvar ApolloProvision = __webpack_require__(/*! ./ApolloProvision */ \"./src/UA/ApolloProvision.js\");\nvar debug = SIP.debug('Apollo:UA');\n\nmodule.exports = function (_SIP$UA) {\n  _inherits(UA, _SIP$UA);\n\n  function UA(configuration) {\n    _classCallCheck(this, UA);\n\n    var _sockets = [];\n\n    if (!Array.isArray(configuration.servers)) {\n      configuration.servers = [configuration.servers];\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = configuration.servers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var s = _step.value;\n\n        var url = s;\n\n        if (Object.prototype.hasOwnProperty.call(s, 'url')) {\n          url = s.url;\n\n          var socket = SocketInterface.Create({\n            server: url,\n            socketOptions: configuration.socketOptions,\n            proxy: configuration.proxy\n          });\n\n          _sockets.push({ socket: socket, weight: s.weight });\n        } else {\n          var _socket = SocketInterface.Create({\n            server: url,\n            socketOptions: configuration.socketOptions,\n            proxy: configuration.proxy\n          });\n\n          _sockets.push({ socket: _socket });\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    configuration.sockets = _sockets;\n\n    var _this = _possibleConstructorReturn(this, (UA.__proto__ || Object.getPrototypeOf(UA)).call(this, configuration));\n\n    Object.assign(_this._configuration, {\n      // common config\n      servers: undefined,\n      proxy: undefined,\n      socketOptions: undefined,\n      debug: true,\n      // peer connection config\n      iceServers: undefined, // [ { urls: 'stun:stun.l.google.com:19302' } ]\n      iceTransportPolicy: 'all', // all | relay\n      iceCandidatePoolSize: 0,\n      // rtc config\n      DtlsSrtpKeyAgreement: true,\n      googIPv6: false,\n      // rtc offer/answer config\n      // the number of audio streams to receive when creating an offer.\n      offerToReceiveAudio: true,\n      // the number of video streams to receive when creating an offer.\n      offerToReceiveVideo: true,\n      // call config\n      anonymous: false,\n      // apollo service config\n      conferenceFactoryUri: undefined,\n      capabilities: undefined,\n      negotiateUrl: undefined,\n      phonebookUrl: undefined,\n      autopUrl: undefined,\n      endpointConfig: undefined,\n      serverConfig: undefined\n    });\n\n    var optional = ['servers', 'proxy', 'socketOptions', 'debug', 'iceServers', 'iceTransportPolicy', 'iceCandidatePoolSize', 'DtlsSrtpKeyAgreement', 'googIPv6', 'offerToReceiveAudio', 'offerToReceiveVideo', 'anonymous'];\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = optional[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var parameter = _step2.value;\n\n        if (configuration.hasOwnProperty(parameter)) {\n          var value = configuration[parameter];\n\n          if (SIP.Utils.isEmpty(value)) {\n            continue;\n          }\n\n          _this._configuration[parameter] = value;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    if (_this._configuration.debug) {\n      SIP.debug.enable('SIP:* Apollo:*');\n    }\n\n    _this._apolloControl = null;\n    _this._apolloProvision = null;\n    return _this;\n  }\n\n  _createClass(UA, [{\n    key: 'get',\n    value: function get(parameter) {\n      switch (parameter) {\n        case 'iceServers':\n          return this._configuration.iceServers;\n\n        case 'iceTransportPolicy':\n          return this._configuration.iceTransportPolicy;\n\n        case 'iceCandidatePoolSize':\n          return this._configuration.iceCandidatePoolSize;\n\n        case 'DtlsSrtpKeyAgreement':\n          return this._configuration.DtlsSrtpKeyAgreement;\n\n        case 'googIPv6':\n          return this._configuration.googIPv6;\n\n        case 'offerToReceiveAudio':\n          return this._configuration.offerToReceiveAudio;\n\n        case 'offerToReceiveVideo':\n          return this._configuration.offerToReceiveVideo;\n\n        case 'conferenceFactoryUri':\n          return this._configuration.conferenceFactoryUri;\n\n        case 'capabilities':\n          return this._configuration.capabilities;\n\n        case 'negotiateUrl':\n          return this._configuration.negotiateUrl;\n\n        case 'phonebookUrl':\n          return this._configuration.phonebookUrl;\n\n        case 'anonymous':\n          return this._configuration.anonymous;\n\n        case 'uri':\n          return this._configuration.uri;\n\n        default:\n          return _get(UA.prototype.__proto__ || Object.getPrototypeOf(UA.prototype), 'get', this).call(this, parameter);\n      }\n    }\n  }, {\n    key: 'set',\n    value: function set(parameter, value) {\n      switch (parameter) {\n        case 'iceServers':\n          this._configuration.iceServers = value;\n          break;\n\n        case 'iceTransportPolicy':\n          this._configuration.iceTransportPolicy = value;\n          break;\n\n        case 'iceCandidatePoolSize':\n          this._configuration.iceCandidatePoolSize = value;\n          break;\n\n        case 'DtlsSrtpKeyAgreement':\n          this._configuration.DtlsSrtpKeyAgreement = value;\n          break;\n\n        case 'googIPv6':\n          this._configuration.googIPv6 = value;\n          break;\n\n        case 'offerToReceiveAudio':\n          this._configuration.offerToReceiveAudio = value;\n          break;\n\n        case 'offerToReceiveVideo':\n          this._configuration.offerToReceiveVideo = value;\n          break;\n\n        case 'conferenceFactoryUri':\n          this._configuration.conferenceFactoryUri = value;\n          break;\n\n        case 'capabilities':\n          this._configuration.capabilities = value;\n          break;\n\n        case 'negotiateUrl':\n          this._configuration.negotiateUrl = value;\n          break;\n\n        case 'phonebookUrl':\n          this._configuration.phonebookUrl = value;\n          break;\n\n        case 'anonymous':\n          this._configuration.anonymous = value;\n          break;\n\n        default:\n          return _get(UA.prototype.__proto__ || Object.getPrototypeOf(UA.prototype), 'set', this).call(this, parameter, value);\n      }\n    }\n  }, {\n    key: 'registered',\n    value: function registered(data) {\n      _get(UA.prototype.__proto__ || Object.getPrototypeOf(UA.prototype), 'registered', this).call(this, data);\n\n      this.subscribeApolloService();\n    }\n  }, {\n    key: 'registrationFailed',\n    value: function registrationFailed(data) {\n      var _this2 = this;\n\n      debug('registrationFailed: ' + data.cause);\n\n      if (data.cause && data.cause === SIP.C.causes.REDIRECTED) {\n        debug('Try redirect');\n\n        var response = data.response;\n        var contacts = response.getHeaders('contact').length;\n        var contact = null;\n        var transportUrl = URL.parse(this._transport.url);\n        var sockets = [];\n\n        while (contacts--) {\n          contact = response.parseHeader('contact', contacts);\n          var server = URL.format({\n            hostname: contact.uri.host,\n            port: transportUrl.port || contact.uri.port,\n            protocol: transportUrl.protocol,\n            slashes: true\n          });\n\n          var socket = SocketInterface.Create({\n            server: server,\n            socketOptions: this._configuration.socketOptions,\n            proxy: this._configuration.proxy\n          });\n\n          var weight = Number.parseFloat(contact.getParam('q'));\n\n          sockets.push({\n            socket: socket,\n            weight: weight\n          });\n        }\n\n        this.stop();\n        this.once('disconnected', function () {\n          _this2._transport._setSocket(sockets);\n          _this2._transport._getSocket();\n          _this2.start();\n        });\n      } else {\n        _get(UA.prototype.__proto__ || Object.getPrototypeOf(UA.prototype), 'registrationFailed', this).call(this, data);\n      }\n    }\n  }, {\n    key: 'subscribeApolloService',\n    value: function subscribeApolloService() {\n      // subscribe apollo control\n      if (!this._apolloControl) {\n        this._apolloControl = new ApolloControl(this);\n        this._apolloControl.on('notify', this.onApolloControl.bind(this));\n      }\n\n      this._apolloControl.subscribe([ApolloControl.CONTROL_GROUP.DEVICE_CONTROL, ApolloControl.CONTROL_GROUP.CONFIG_CONTROL, ApolloControl.CONTROL_GROUP.NOTICE_CONTROL]);\n\n      // subscribe apollo provision\n      if (!this._apolloProvision) {\n        this._apolloProvision = new ApolloProvision(this);\n        this._apolloProvision.on('notify', this.onApolloProvision.bind(this));\n      }\n\n      this._apolloProvision.subscribe([ApolloProvision.PROVISION_GROUP.SERVER_CONFIGURATION, ApolloProvision.PROVISION_GROUP.ENDPOINT_CONFIGURATION]);\n    }\n  }, {\n    key: 'onApolloControl',\n    value: function onApolloControl(controlGroup, configuration) {\n      var action = configuration['action'];\n      var actionName = action['@name'];\n\n      switch (controlGroup) {\n        case ApolloControl.CONTROL_GROUP.CONFIG_CONTROL:\n          if (actionName === 'turnRefresh') {\n            var servers = action['configGroup'];\n            var iceServers = [];\n\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n              for (var _iterator3 = servers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var server = _step3.value;\n                var Server = server.Server,\n                    UDPPort = server.UDPPort,\n                    Username = server.Username,\n                    Password = server.Password;\n\n                var type = server['@name'] || 'stun';\n\n                iceServers.push({\n                  urls: URL.format({\n                    hostname: Server,\n                    port: UDPPort,\n                    protocol: type.toLowerCase(),\n                    slashes: false\n                  }),\n                  username: Base64.decode(Username),\n                  credential: Base64.decode(Password)\n                });\n              }\n            } catch (err) {\n              _didIteratorError3 = true;\n              _iteratorError3 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                  _iterator3.return();\n                }\n              } finally {\n                if (_didIteratorError3) {\n                  throw _iteratorError3;\n                }\n              }\n            }\n\n            this.set('iceServers', iceServers);\n            this.emit('iceServerUpdated', iceServers);\n            debug('iceServerUpdated : %o', iceServers);\n          }\n          break;\n        case ApolloControl.CONTROL_GROUP.DEVICE_CONTROL:\n          break;\n        case ApolloControl.CONTROL_GROUP.NOTICE_CONTROL:\n          if (actionName === 'bookConferenceUpdate') {\n            this.emit('bookConferenceUpdated', action['xml-body']);\n            debug('bookConferenceUpdated : %o', action['xml-body']);\n          }\n          break;\n      }\n    }\n  }, {\n    key: 'onApolloProvision',\n    value: function onApolloProvision(provisionGroup, configuration) {\n      switch (provisionGroup) {\n        case ApolloProvision.PROVISION_GROUP.ENDPOINT_CONFIGURATION:\n          for (var attr in configuration) {\n            if (configuration.hasOwnProperty(attr)) {\n              var value = configuration[attr];\n\n              if (attr === 'phonebook-url') {\n                var phonebookUrl = value['@url'];\n\n                this.set('phonebookUrl', phonebookUrl);\n                this.emit('phonebookUrlUpdated', phonebookUrl);\n                debug('phonebookUrlUpdated : %s', phonebookUrl);\n              }\n              if (attr === 'negotiate-url') {\n                var negotiateUrl = value['@url'];\n\n                this.set('negotiateUrl', negotiateUrl);\n                this.emit('negotiateUrlUpdated', negotiateUrl);\n                debug('negotiateUrlUpdated : %s', negotiateUrl);\n              }\n              if (attr === 'autop-url') {\n                var autopUrl = value['@url'];\n\n                this.set('autopUrl', autopUrl);\n                this.emit('autopUrlUpdated', autopUrl);\n                debug('autopUrlUpdated : %s', autopUrl);\n              }\n            }\n          }\n          break;\n        case ApolloProvision.PROVISION_GROUP.SERVER_CONFIGURATION:\n          for (var _attr in configuration) {\n            if (configuration.hasOwnProperty(_attr)) {\n              var _value = configuration[_attr];\n\n              if (_attr === 'conference-factory-uri') {\n                var conferenceFactoryUri = _value;\n\n                this.set('conferenceFactoryUri', conferenceFactoryUri);\n                this.emit('conferenceFactoryUriUpdated', conferenceFactoryUri);\n                debug('conferenceFactoryUriUpdated : %s', conferenceFactoryUri);\n              }\n              if (_attr === 'capabilities') {\n                var capabilities = _value;\n\n                this.set('capabilities', capabilities);\n                this.emit('capabilitiesUpdated', capabilities);\n                debug('capabilitiesUpdated : %o', capabilities);\n              }\n            }\n          }\n          break;\n      }\n    }\n  }]);\n\n  return UA;\n}(SIP.UA);\n\n//# sourceURL=webpack://ApolloSIP/./src/UA/UA.js?");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"buffer\");\n\n//# sourceURL=webpack://ApolloSIP/external_%22buffer%22?");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"child_process\");\n\n//# sourceURL=webpack://ApolloSIP/external_%22child_process%22?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=webpack://ApolloSIP/external_%22crypto%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack://ApolloSIP/external_%22events%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack://ApolloSIP/external_%22fs%22?");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");\n\n//# sourceURL=webpack://ApolloSIP/external_%22http%22?");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"https\");\n\n//# sourceURL=webpack://ApolloSIP/external_%22https%22?");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"net\");\n\n//# sourceURL=webpack://ApolloSIP/external_%22net%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");\n\n//# sourceURL=webpack://ApolloSIP/external_%22os%22?");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"tty\");\n\n//# sourceURL=webpack://ApolloSIP/external_%22tty%22?");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");\n\n//# sourceURL=webpack://ApolloSIP/external_%22url%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack://ApolloSIP/external_%22util%22?");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"zlib\");\n\n//# sourceURL=webpack://ApolloSIP/external_%22zlib%22?");

/***/ })

/******/ });
});